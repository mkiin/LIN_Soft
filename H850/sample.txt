/*""FILE COMMENT""*************************************************************
 * System Name  : S/R System
 * File Name    : f_lin_if.c
 * Contests     : 
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2003.11.28
 *""FILE COMMENT END""*********************************************************/

#pragma	section	lin

/******************************************************************************/
/* Header File Include 														  */
/******************************************************************************/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_nmc.h"
#include "l_slin_drv_h83687.h"

#include "p_lin_apl.h"
#include "p_comdwn_tmr.h"

#include "f_lin_if.h"

/*============================================================*/
/*  構造体変数                                                */
/*============================================================*/
static xn_rx_dat_id28_t	xnl_rx_dat_id28;	/* ボディーＥＣＵ情報①受信データ */
static xn_rx_dat_id29_t	xnl_rx_dat_id29;	/* ボディーＥＣＵ情報②受信データ */
static xn_rx_dat_id2a_t	xnl_rx_dat_id2a;	/* ボディーＥＣＵ情報③受信データ */
static xn_rx_dat_id22_t	xnl_rx_dat_id22;	/* ボディーＥＣＵ情報④受信データ */
static xn_rx_dat_id2b_t	xnl_rx_dat_id2b;	/* Ｐ／ＷマスタＳＷ情報①データ取得処理 */

xn_tx_dat_id23_t	xng_tx_dat_id23;		/* Ｓ／Ｒ情報送信データ	*/
/*============================================================*/
/*  ローカル変数                                              */
/*============================================================*/
static u1  u1l_lin_flg;

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : LIN通信情報取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : 各ECUからの情報データを取り込む
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : ECU情報①取得処理			f_vog_ecu1st_get( void )
 *				   : ECU情報②取得処理			f_vog_ecu2nd_get( void )
 *				   : ECU情報③取得処理			f_vog_ecu3rd_get( void )
 *				   : ECU情報④取得処理			f_vog_ecu4th_get( void )
 *				   : P/WマスタSW情報①取得処理	f_vog_pwsw1st_get( void )
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.21
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_get_lin_dat(void)
{
	f_vog_ecu1st_get();					/* ECU情報①取得処理			*/
	f_vog_ecu2nd_get();					/* ECU情報②取得処理			*/
	f_vog_ecu3rd_get();					/* ECU情報③取得処理			*/
	f_vog_ecu4th_get();					/* ECU情報④取得処理			*/
	f_vog_pwsw1st_get();				/* P/WマスタSW情報①取得処理	*/
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報①データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報①よりキー連動、ワイヤレス連動データ、
 * 				   : 通信IG信号、D席カーテシ信号を取り込む
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id28_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id28_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu1st_get(void)
{
	u1 u1a_lin_sleep_ans;		/* LIN通信スリープ条件検査結果	*/

    /* ボディーECU情報①(ID=28h)の受信が完了していれば */
    if( U1G_LIN_BIT_SET == F1g_lin_rxframe_id28h ){
        /* ボディーECU情報①(ID=28h)の受信完了フラグ */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id28h = U1G_LIN_BIT_CLR;
        l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* ボディーECU情報①(ID=28h)のレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id28h ){
            /* ボディーECU情報①(ID=28h)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id28h = U1G_LIN_BYTE_CLR;
	        l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else {	/* 受信が正常に完了したら	*/
	        /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id28_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報①(ID=28h)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID28H, U1G_LIN_4,  xnl_rx_dat_id28.u1_rx_byte);
			F_comdwn_01 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id28_cmdwn();		/* 途絶判定タイマ初期化	*/
            /* テンポラリバッファから読み出した値を、参照用構造体に格納 */
           	F_lin_ig	  = Fll_lin_ig;
#ifndef U1G_REAR_SW_SELECT
           	F_lin_pws     = Fll_lin_pws;
#endif
#ifdef U1G_BUZZER_SELECT
            F_lin_dcty	  = Fll_lin_dcty;
#endif
#ifdef U1G_REMOTE_SELECT
           	F_lin_kpwu    = Fll_lin_kpwu;
           	F_lin_kpwd    = Fll_lin_kpwd;
            F_lin_wpwu 	  = Fll_lin_wpwu;
            F_lin_wpwd	  = Fll_lin_wpwd;
            F_lin_spwu	  = Fll_lin_spwu;
#endif
			}
	} else {
	}
	u1a_lin_sleep_ans = l_nm_rd_slv_stat_ch1();			/* LINスリープ条件検査	*/

	if( U1G_LIN_SLVSTAT_SLEEP == u1a_lin_sleep_ans ){	/* Q. スリープ前提条件成立？	*/
		p_vog_tmr_start_id28_cmdwn();					/* 途絶判定タイマ初期化	*/
	}
	else {
		if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id28_cmdwn() ){			/* 途絶してたら	*/
			F_comdwn_01  = U1G_LIN_BIT_SET;							/* 途絶判定フラグセット	*/
		    F_id28_first = U1G_LIN_BIT_SET;							/* ボディーECU情報①初回受信初期化 */
			/*---------- DCTYは不定として扱う ---------- */
			F_lin_ig	  = U1G_LIN_BIT_CLR;						/* IG = off(デフォルト)にセット		*/
#ifndef U1G_REAR_SW_SELECT
			F_lin_pws     = U1G_LIN_BIT_CLR;						/* PWS = off(デフォルト)にセット	*/
#endif
#ifdef U1G_REMOTE_SELECT
 			xng_lin_info_rmt.u1_lin_info_rmt = U1G_LIN_BYTE_CLR;	/* リモート信号デフォルト値設定*/
#endif
		} else {
		}
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報②データ取得処
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報②より仕向データを取り込み仕向地を決定する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id29_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id29_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu2nd_get(void)
{
	u1	u1a_lin_cmt;

    /* ボディーECU情報②(ID=29h)の受信が完了していれば */
    if( U1G_LIN_BIT_SET == F1g_lin_rxframe_id29h ){
        /* ボディーECU情報②(ID=29h)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id29h = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* ボディーECU情報②(ID=29h)のレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id29h ){
            /* ボディーECU情報②(ID=29h)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id29h = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
		    /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id29_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報②(ID=29h)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID29H, U1G_LIN_4,  xnl_rx_dat_id29.u1_rx_byte);
			F_comdwn_02 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id29_cmdwn();		/* 途絶判定タイマ初期化	*/
            /* テンポラリバッファから読み出した値を、参照用構造体に格納 */
            U1g_lin_spd = U1l_lin_spd;
            u1a_lin_cmt = U1l_lin_cmt;
            
            /* 仕向を判断する */
            switch( (u2)u1a_lin_cmt ){
            	case(U1G_CMT_JPN):
            	case(U1G_CMT_EUR):
            	case(U1G_CMT_MNE):
            	case(U1G_CMT_CHN):
            	case(U1G_CMT_GEN):
            	case(U1G_CMT_AUS):
#ifndef U1G_REAR_SW_SELECT
					U1g_lin_cmt = U1G_DEST_JPN;
	           		break;
#endif
            	case(U1G_CMT_USA):
            	case(U1G_CMT_NON):
            	default:
               		U1g_lin_cmt = U1G_DEST_USA;
                	break;
            }
        }
    } else {
	}
	if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id29_cmdwn() ){	/* 途絶してたら	*/
		F_comdwn_02  = U1G_LIN_BIT_SET;					/* 途絶判定フラグセット	*/
	    U1g_lin_spd = U1G_LIN_BYTE_CLR;					/* 車速デフォルト値設定 */
	} else {
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報③データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報③の通信状態を検出し、データを取得する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id2a_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id2a_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu3rd_get(void)
{
    /* ボディーECU情報③(ID=2ah)の受信が完了していれば */
    if( U1G_FLB_TRUE == F1g_lin_rxframe_id2ah ){
        /* ボディーECU情報①(ID=2ah)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
		F1g_lin_rxframe_id2ah = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

       /* フレームレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id2ah ){
            /* ボディーECU情報③(ID=2ah)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id2ah = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
	        /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id2a_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報③(ID=2ah)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID2AH, U1G_LIN_4,  xnl_rx_dat_id2a.u1_rx_byte);
			F_comdwn_03 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id2a_cmdwn(); 		/* 途絶判定タイマ初期化	*/
        }
	} else {
	}
	if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id2a_cmdwn() ){	/* 途絶判定していたら	*/
		F_comdwn_03  = U1G_LIN_BIT_SET;					/* 途絶判定フラグセット	*/
	} else {
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報④データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報④の通信状態を検出し、データを取得する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id22_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id22_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu4th_get(void)
{
    /* ボディーECU情報④(ID=22h)の受信が完了していれば */
    if( U1G_FLB_TRUE == F1g_lin_rxframe_id22h ){
        /* ボディーECU情報④(ID=22h)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id22h = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* フレームレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id22h ){
            /* ボディーECU情報④(ID=22h)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id22h = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
	        /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id22_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報④(ID=22h)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID22H, U1G_LIN_4,  xnl_rx_dat_id22.u1_rx_byte);
			F_comdwn_04 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id22_cmdwn(); 		/* 途絶判定タイマ初期化	*/
        }
	} else {
	}
	if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id22_cmdwn() ){	/* 途絶判定していたら	*/
		F_comdwn_04  = U1G_LIN_BIT_SET;					/* 途絶判定フラグセット	*/
	} else {
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Ｐ／ＷマスタＳＷ情報①データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Ｐ／ＷマスタＳＷ①の通信状態を検出し、データを取得する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   :				l_flg_clr()	bit clear
 *				   :				l_u8_rd()   1byte data read
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id2b_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id2b_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_pwsw1st_get(void)
{
    /* P/WマスタSW情報①(ID=2Bh)の受信が完了していれば */
    if( U1G_LIN_BIT_SET == F1g_lin_rxframe_id2bh ){
        /* P/WマスタSW情報①(ID=2Bh)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id2bh  = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* P/WマスタSW情報①(ID=2Bh)のレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id2bh ){
            /* P/WマスタSW情報①(ID=2Bh)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id2bh = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
    	    /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id2b_first = U1G_LIN_BIT_CLR;	
            /* P/WマスタSW情報①(ID=2Bh)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID2BH, U1G_LIN_4,  xnl_rx_dat_id2b.u1_rx_byte);
			F_comdwn_05  = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id2b_cmdwn();  		/* 途絶判定タイマ初期化	*/
            /* テンポラリバッファから読み出した値を、参照用構造体に格納 */
#ifdef U1G_REAR_SW_SELECT
           	F_lin_wl = Fll_lin_wl;				/* ウインドロック信号取得 */
#endif
        }
	} else {
		if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id2b_cmdwn() ){	/* 途絶してたら	*/
			F_comdwn_05  = U1G_FLB_TRUE;                 	/* 途絶判定フラグセット	*/
#ifdef U1G_REAR_SW_SELECT
           	F_lin_wl = U1G_LIN_BIT_CLR;				/* ウインドロック信号デフォルト値設定 */
#endif
		} else {
		}
	}
}


/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ワーニング出力確定処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : 閉じ忘れ情報をLIN通信により出力する
 * 				   : 
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : 警告情報取得   p_vog_caution_get_msg()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.22
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_lin_warn_send(void)
{
#ifdef U1G_BUZZER_SELECT
	u1	u1a_warning_stat = p_u1g_warning_get_out_stat();
	
	/* スライド/チルト警告灯 点灯要求判定	*/
	if( U1G_FLB_TRUE == u1a_warning_stat ){
		Fll_lin_srbz = U1G_LIN_BIT_SET;
	} else {
		Fll_lin_srbz = U1G_LIN_BIT_CLR;
	}
#endif
	l_slot_wr_ch1(U1G_LIN_FRAME_ID23H, U1G_LIN_4, xng_tx_dat_id23.u1_tx_byte);
}

/***** End of File *****/




/*""FILE COMMENT""*************************************************************
 * System Name  : S/R System
 * File Name    : f_lin_if.c
 * Contests     : 
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2003.11.28
 *""FILE COMMENT END""*********************************************************/

#pragma	section	lin

/******************************************************************************/
/* Header File Include 														  */
/******************************************************************************/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_nmc.h"
#include "l_slin_drv_h83687.h"

#include "p_lin_apl.h"
#include "p_comdwn_tmr.h"

#include "f_lin_if.h"

/*============================================================*/
/*  構造体変数                                                */
/*============================================================*/
static xn_rx_dat_id28_t	xnl_rx_dat_id28;	/* ボディーＥＣＵ情報①受信データ */
static xn_rx_dat_id29_t	xnl_rx_dat_id29;	/* ボディーＥＣＵ情報②受信データ */
static xn_rx_dat_id2a_t	xnl_rx_dat_id2a;	/* ボディーＥＣＵ情報③受信データ */
static xn_rx_dat_id22_t	xnl_rx_dat_id22;	/* ボディーＥＣＵ情報④受信データ */
static xn_rx_dat_id2b_t	xnl_rx_dat_id2b;	/* Ｐ／ＷマスタＳＷ情報①データ取得処理 */

xn_tx_dat_id23_t	xng_tx_dat_id23;		/* Ｓ／Ｒ情報送信データ	*/
/*============================================================*/
/*  ローカル変数                                              */
/*============================================================*/
static u1  u1l_lin_flg;

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : LIN通信情報取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : 各ECUからの情報データを取り込む
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : ECU情報①取得処理			f_vog_ecu1st_get( void )
 *				   : ECU情報②取得処理			f_vog_ecu2nd_get( void )
 *				   : ECU情報③取得処理			f_vog_ecu3rd_get( void )
 *				   : ECU情報④取得処理			f_vog_ecu4th_get( void )
 *				   : P/WマスタSW情報①取得処理	f_vog_pwsw1st_get( void )
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.21
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_get_lin_dat(void)
{
	f_vog_ecu1st_get();					/* ECU情報①取得処理			*/
	f_vog_ecu2nd_get();					/* ECU情報②取得処理			*/
	f_vog_ecu3rd_get();					/* ECU情報③取得処理			*/
	f_vog_ecu4th_get();					/* ECU情報④取得処理			*/
	f_vog_pwsw1st_get();				/* P/WマスタSW情報①取得処理	*/
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報①データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報①よりキー連動、ワイヤレス連動データ、
 * 				   : 通信IG信号、D席カーテシ信号を取り込む
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id28_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id28_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu1st_get(void)
{
	u1 u1a_lin_sleep_ans;		/* LIN通信スリープ条件検査結果	*/

    /* ボディーECU情報①(ID=28h)の受信が完了していれば */
    if( U1G_LIN_BIT_SET == F1g_lin_rxframe_id28h ){
        /* ボディーECU情報①(ID=28h)の受信完了フラグ */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id28h = U1G_LIN_BIT_CLR;
        l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* ボディーECU情報①(ID=28h)のレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id28h ){
            /* ボディーECU情報①(ID=28h)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id28h = U1G_LIN_BYTE_CLR;
	        l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else {	/* 受信が正常に完了したら	*/
	        /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id28_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報①(ID=28h)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID28H, U1G_LIN_4,  xnl_rx_dat_id28.u1_rx_byte);
			F_comdwn_01 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id28_cmdwn();		/* 途絶判定タイマ初期化	*/
            /* テンポラリバッファから読み出した値を、参照用構造体に格納 */
           	F_lin_ig	  = Fll_lin_ig;
#ifndef U1G_REAR_SW_SELECT
           	F_lin_pws     = Fll_lin_pws;
#endif
#ifdef U1G_BUZZER_SELECT
            F_lin_dcty	  = Fll_lin_dcty;
#endif
#ifdef U1G_REMOTE_SELECT
           	F_lin_kpwu    = Fll_lin_kpwu;
           	F_lin_kpwd    = Fll_lin_kpwd;
            F_lin_wpwu 	  = Fll_lin_wpwu;
            F_lin_wpwd	  = Fll_lin_wpwd;
            F_lin_spwu	  = Fll_lin_spwu;
#endif
			}
	} else {
	}
	u1a_lin_sleep_ans = l_nm_rd_slv_stat_ch1();			/* LINスリープ条件検査	*/

	if( U1G_LIN_SLVSTAT_SLEEP == u1a_lin_sleep_ans ){	/* Q. スリープ前提条件成立？	*/
		p_vog_tmr_start_id28_cmdwn();					/* 途絶判定タイマ初期化	*/
	}
	else {
		if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id28_cmdwn() ){			/* 途絶してたら	*/
			F_comdwn_01  = U1G_LIN_BIT_SET;							/* 途絶判定フラグセット	*/
		    F_id28_first = U1G_LIN_BIT_SET;							/* ボディーECU情報①初回受信初期化 */
			/*---------- DCTYは不定として扱う ---------- */
			F_lin_ig	  = U1G_LIN_BIT_CLR;						/* IG = off(デフォルト)にセット		*/
#ifndef U1G_REAR_SW_SELECT
			F_lin_pws     = U1G_LIN_BIT_CLR;						/* PWS = off(デフォルト)にセット	*/
#endif
#ifdef U1G_REMOTE_SELECT
 			xng_lin_info_rmt.u1_lin_info_rmt = U1G_LIN_BYTE_CLR;	/* リモート信号デフォルト値設定*/
#endif
		} else {
		}
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報②データ取得処
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報②より仕向データを取り込み仕向地を決定する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id29_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id29_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu2nd_get(void)
{
	u1	u1a_lin_cmt;

    /* ボディーECU情報②(ID=29h)の受信が完了していれば */
    if( U1G_LIN_BIT_SET == F1g_lin_rxframe_id29h ){
        /* ボディーECU情報②(ID=29h)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id29h = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* ボディーECU情報②(ID=29h)のレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id29h ){
            /* ボディーECU情報②(ID=29h)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id29h = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
		    /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id29_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報②(ID=29h)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID29H, U1G_LIN_4,  xnl_rx_dat_id29.u1_rx_byte);
			F_comdwn_02 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id29_cmdwn();		/* 途絶判定タイマ初期化	*/
            /* テンポラリバッファから読み出した値を、参照用構造体に格納 */
            U1g_lin_spd = U1l_lin_spd;
            u1a_lin_cmt = U1l_lin_cmt;
            
            /* 仕向を判断する */
            switch( (u2)u1a_lin_cmt ){
            	case(U1G_CMT_JPN):
            	case(U1G_CMT_EUR):
            	case(U1G_CMT_MNE):
            	case(U1G_CMT_CHN):
            	case(U1G_CMT_GEN):
            	case(U1G_CMT_AUS):
#ifndef U1G_REAR_SW_SELECT
					U1g_lin_cmt = U1G_DEST_JPN;
	           		break;
#endif
            	case(U1G_CMT_USA):
            	case(U1G_CMT_NON):
            	default:
               		U1g_lin_cmt = U1G_DEST_USA;
                	break;
            }
        }
    } else {
	}
	if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id29_cmdwn() ){	/* 途絶してたら	*/
		F_comdwn_02  = U1G_LIN_BIT_SET;					/* 途絶判定フラグセット	*/
	    U1g_lin_spd = U1G_LIN_BYTE_CLR;					/* 車速デフォルト値設定 */
	} else {
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報③データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報③の通信状態を検出し、データを取得する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id2a_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id2a_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu3rd_get(void)
{
    /* ボディーECU情報③(ID=2ah)の受信が完了していれば */
    if( U1G_FLB_TRUE == F1g_lin_rxframe_id2ah ){
        /* ボディーECU情報①(ID=2ah)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
		F1g_lin_rxframe_id2ah = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

       /* フレームレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id2ah ){
            /* ボディーECU情報③(ID=2ah)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id2ah = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
	        /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id2a_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報③(ID=2ah)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID2AH, U1G_LIN_4,  xnl_rx_dat_id2a.u1_rx_byte);
			F_comdwn_03 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id2a_cmdwn(); 		/* 途絶判定タイマ初期化	*/
        }
	} else {
	}
	if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id2a_cmdwn() ){	/* 途絶判定していたら	*/
		F_comdwn_03  = U1G_LIN_BIT_SET;					/* 途絶判定フラグセット	*/
	} else {
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーECU情報④データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ボディーECU情報④の通信状態を検出し、データを取得する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id22_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id22_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_ecu4th_get(void)
{
    /* ボディーECU情報④(ID=22h)の受信が完了していれば */
    if( U1G_FLB_TRUE == F1g_lin_rxframe_id22h ){
        /* ボディーECU情報④(ID=22h)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id22h = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* フレームレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id22h ){
            /* ボディーECU情報④(ID=22h)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id22h = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
	        /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id22_first = U1G_LIN_BIT_CLR;	
            /* ボディーECU情報④(ID=22h)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID22H, U1G_LIN_4,  xnl_rx_dat_id22.u1_rx_byte);
			F_comdwn_04 = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id22_cmdwn(); 		/* 途絶判定タイマ初期化	*/
        }
	} else {
	}
	if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id22_cmdwn() ){	/* 途絶判定していたら	*/
		F_comdwn_04  = U1G_LIN_BIT_SET;					/* 途絶判定フラグセット	*/
	} else {
	}
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Ｐ／ＷマスタＳＷ情報①データ取得処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Ｐ／ＷマスタＳＷ①の通信状態を検出し、データを取得する
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : スロットデータ一括読み込み(LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ関数)
 *				   :                l_slot_rd_ch1(l_frame_handle  u1a_lin_frm,
 *				   :						 l_u8 u1a_lin_cnt, l_u8 * pta_lin_data) 
 *				   :				l_flg_clr()	bit clear
 *				   :				l_u8_rd()   1byte data read
 *				   : 通信途絶監視ﾀｲﾏ起動処理
 *				   :				p_vog_tmr_start_id2b_cmdwn()
 *				   : 通信途絶判定処理
 *				   :				p_u1g_tmr_jdg_id2b_cmdwn()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.12
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_pwsw1st_get(void)
{
    /* P/WマスタSW情報①(ID=2Bh)の受信が完了していれば */
    if( U1G_LIN_BIT_SET == F1g_lin_rxframe_id2bh ){
        /* P/WマスタSW情報①(ID=2Bh)の受信完了フラグをクリア */
        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
        F1g_lin_rxframe_id2bh  = U1G_LIN_BIT_CLR;
	    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */

        /* P/WマスタSW情報①(ID=2Bh)のレスポンスエラーが発生した場合 */
        if( U1G_LIN_BYTE_CLR != F4g_lin_errframe_id2bh ){
            /* P/WマスタSW情報①(ID=2Bh)のエラーフラグを クリアする */
	        u1l_lin_flg = l_u1g_lin_irq_dis();         /* 割り込み禁止設定 */
            F4g_lin_errframe_id2bh = U1G_LIN_BYTE_CLR;
		    l_vog_lin_irq_res( u1l_lin_flg );          /* 割り込み設定復元 */
        }
        else{	/* 受信が正常に完了したら	*/
    	    /* 初回受信フラグ設定 1→0で受信受信済み */
	    	F_id2b_first = U1G_LIN_BIT_CLR;	
            /* P/WマスタSW情報①(ID=2Bh)のレスポンスバッファからテンポラリバッファに読み出す */
			l_slot_rd_ch1(U1G_LIN_FRAME_ID2BH, U1G_LIN_4,  xnl_rx_dat_id2b.u1_rx_byte);
			F_comdwn_05  = U1G_LIN_BIT_CLR;		/* 途絶判定フラグクリア */
			p_vog_tmr_start_id2b_cmdwn();  		/* 途絶判定タイマ初期化	*/
            /* テンポラリバッファから読み出した値を、参照用構造体に格納 */
#ifdef U1G_REAR_SW_SELECT
           	F_lin_wl = Fll_lin_wl;				/* ウインドロック信号取得 */
#endif
        }
	} else {
		if( U1G_FLB_TRUE == p_u1g_tmr_jdg_id2b_cmdwn() ){	/* 途絶してたら	*/
			F_comdwn_05  = U1G_FLB_TRUE;                 	/* 途絶判定フラグセット	*/
#ifdef U1G_REAR_SW_SELECT
           	F_lin_wl = U1G_LIN_BIT_CLR;				/* ウインドロック信号デフォルト値設定 */
#endif
		} else {
		}
	}
}


/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ワーニング出力確定処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : 閉じ忘れ情報をLIN通信により出力する
 * 				   : 
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : 警告情報取得   p_vog_caution_get_msg()
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.07.22
 *""FUNC COMMENT END""*********************************************************/ 
void  f_vog_lin_warn_send(void)
{
#ifdef U1G_BUZZER_SELECT
	u1	u1a_warning_stat = p_u1g_warning_get_out_stat();
	
	/* スライド/チルト警告灯 点灯要求判定	*/
	if( U1G_FLB_TRUE == u1a_warning_stat ){
		Fll_lin_srbz = U1G_LIN_BIT_SET;
	} else {
		Fll_lin_srbz = U1G_LIN_BIT_CLR;
	}
#endif
	l_slot_wr_ch1(U1G_LIN_FRAME_ID23H, U1G_LIN_4, xng_tx_dat_id23.u1_tx_byte);
}

/***** End of File *****/



/*""FILE COMMENT""*************************************************************
 * System Name  : S/R System
 * File Name    : f_lin_main.c
 * Contests     : 
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2003.11.28
 *""FILE COMMENT END""*********************************************************/

#pragma	section	lin

/******************************************************************************/
/* Header File Include 														  */
/******************************************************************************/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_nmc.h"

#include "p_lin_apl.h"
#include "f_dev_inthdr_h8tiny.h"
#include "f_lin_main.h"
#include "f_diag_if.h"
#include "f_sys_fail.h"
#include "f_lin_if.h"
#include "f_sleep_ctl_srf.h"
#include "f_diag_main.h"
#include "p_piosw.h"
#include "p_piosw_ig.h"
#include "p_comdwn_tmr.h"
#include "p_mtr.h"
#include "f_lin_if.h"

#pragma interrupt ( f_vogi_inthdr_irq0 )
#pragma interrupt ( f_vogi_inthdr_tmr_z0 )
#pragma interrupt ( f_vogi_inthdr_sci3_2 )

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Lin通信初期化処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Lin Driver及びSCI2などの初期化を行う
 *-----------------------------------------------------------------------------
 * 引数            : u1 u1a_mode 
 *				   : U1G_FLB_TRUE  - RESET時に呼び出して初期化を行う
 *				   : U1G_FLB_FALSE - WakeUp時に呼び出して初期化を行う
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ システム初期化API関数 		l_sys_init() 
 *				   :		SCI2初期化関数 						f_vog_ini_sci3_2()
 *				   :		バッファ、ドライバの初期化API関数   l_ifc_init_**()
 *				   :		NM用 初期化API関数  				l_nm_init_**()
 *				   :		LIN通信接続API関数  				l_ifc_connect_**()
 *				   : 					** は、ﾃﾞﾊﾞｲｽに依存する
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.14
 *""FUNC COMMENT END""*********************************************************/
void  f_vog_lin_init( u1 u1a_mode )
{
	/* 同期フラグ : フレーム送信完了フラグクリア */
	F1g_lin_txframe_id23h = U1G_LIN_BIT_CLR;
	
	/* 同期フラグ : フレーム受信完了フラグクリア */
	F1g_lin_rxframe_id28h = U1G_LIN_BIT_CLR;
	F1g_lin_rxframe_id29h = U1G_LIN_BIT_CLR;
	F1g_lin_rxframe_id2bh = U1G_LIN_BIT_CLR;
	F1g_lin_rxframe_id2ah = U1G_LIN_BIT_CLR;
	F1g_lin_rxframe_id22h = U1G_LIN_BIT_CLR;

	/* 初回受信フラグの初期化(受信したらクリア) */
	/* --------ボディーECU情報①は、リセット時のみ初期化する ----------------- */ 
	if( U1G_FLB_TRUE == u1a_mode ) { 
	    F_id28_first = U1G_LIN_BIT_SET;		/* ボディーECU情報①初回受信初期化 */
	}
	else {
	}
    F_id29_first = U1G_LIN_BIT_SET;		/* ボディーECU情報②初回受信初期化		*/
    F_id2a_first = U1G_LIN_BIT_SET;		/* ボディーECU情報③初回受信初期化		*/
    F_id22_first = U1G_LIN_BIT_SET;		/* ボディーECU情報④初回受信初期化		*/
    F_id2b_first = U1G_LIN_BIT_SET;		/* P/WマスタSW情報初回受信初期化		*/

	F_comdwn_01 = U1G_LIN_BIT_CLR;		/* ボディーECU情報①途絶判定フラグクリア */
	F_comdwn_02 = U1G_LIN_BIT_CLR;		/* ボディーECU情報②途絶判定フラグクリア */
	F_comdwn_03 = U1G_LIN_BIT_CLR;		/* ボディーECU情報③途絶判定フラグクリア */
	F_comdwn_04 = U1G_LIN_BIT_CLR;		/* ボディーECU情報④途絶判定フラグクリア */
	F_comdwn_05 = U1G_LIN_BIT_CLR;		/* P/WマスタSW情報途絶判定フラグクリア	 */

	p_vog_tmr_start_id28_cmdwn();		/* ボディーECU情報①途絶判定タイマ初期化 */
	p_vog_tmr_start_id29_cmdwn();		/* ボディーECU情報②途絶判定タイマ初期化 */
	p_vog_tmr_start_id2a_cmdwn();		/* ボディーECU情報③途絶判定タイマ初期化 */
	p_vog_tmr_start_id22_cmdwn();		/* ボディーECU情報④途絶判定タイマ初期化 */
	p_vog_tmr_start_id2b_cmdwn();  		/* P/WマスタSW情報途絶判定タイマ初期化	 */

    if( U1G_LIN_OK != l_sys_init() ){       	/* システム初期化API */
        /* LIN通信システム初期化が出来なかった場合フェイルセーフ処理をおこなう */
		f_vog_set_fail_cpu();					/* ＣＰＵリセット処理 */
    }
	else {
	}
	
    l_ifc_init_ch1();                            /* バッファ、ドライバの初期化API */
    l_nm_init_ch1();                             /* NM用 初期化API */
	
	/* 送受信スロットはデフォルトで有効になっているため、必要があればここで無効をセットすること	*/
	l_slot_disable_ch1(U1G_LIN_FRAME_ID3DH); 	/* 送信フレームスロットを無効にする */
    
    if( U1G_LIN_OK != l_ifc_connect_ch1() ){     /* LIN通信接続API */
        /* LIN通信接続が出来なかった場合フェイルセーフ処理をおこなう */
		f_vog_set_fail_cpu();					 /* ＣＰＵリセット処理 */
    }
	else {
    }
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Lin通信受信メイン処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Lin通信の受信制御処理を行う
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : Sleep要因判定関数	f_u1l_ans_sleep_check() 
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.14
 *""FUNC COMMENT END""*********************************************************/
void  f_vog_lin_rcv_main(void)
{
	f_vog_get_lin_dat();					/* LIN受信データ取得処理	*/
	f_vog_get_diag_mode();					/* ダイアグモード取得処理		*/
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Lin通信送信メイン処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Lin通信の送信制御処理を行う
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : Sleep要因判定関数	f_u1l_ans_sleep_check() 
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.14
 *""FUNC COMMENT END""*********************************************************/
void  f_vog_lin_snd_main(void)
{
	f_vog_lin_warn_send();					/* ＬＩＮデータ送信処理		*/
	f_vog_diag_main();
	f_vog_diag_mng_rsps();					/* ダイアグ応答送信管理処理	*/
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Lin通信制御メイン処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Lin通信の送信制御処理を行う
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : Sleep要因判定関数	f_u1l_ans_sleep_check() 
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.14
 *""FUNC COMMENT END""*********************************************************/
void  f_vog_lin_mng_ctrl(void)
{
	l_u8   u1a_slp_req;			/* スリープ要因フラグ	*/
	xn_ref_mtr_t	xna_mtr_ref;

	p_vog_mtr_get_msg( &xna_mtr_ref );			/* モータ状態取得		*/
	/** スリープ禁止／ウェイクアップ要因の判定 **/
	if( U1G_FLB_TRUE == F1g_lin_p_bus_err_ch1 ){	/* フィジカル・バスエラー発生	*/
		F1g_lin_p_bus_err_ch1 = U1G_LIN_BIT_CLR;	/* エラー発生フラグクリア		*/
		u1a_slp_req = U1G_LIN_SLP_REQ_FORCE;		/* 強制スリープ要因有り 		*/
	} else {
#ifdef U1G_BUZZER_SELECT
		if(( U1G_FLB_TRUE == Fll_lin_srbz )  ||
			( U1G_FLB_TRUE == xna_mtr_ref.u1_flb_stat_mov )){
#else
		if( U1G_FLB_TRUE == xna_mtr_ref.u1_flb_stat_mov ){
#endif
			u1a_slp_req = U1G_LIN_SLP_REQ_OFF;		/* スリープ要求無し,又はウェイクアップ要因有り */
		}
		else {
			u1a_slp_req = U1G_LIN_SLP_REQ_ON;		/* スリープ要求有り,又はウェイクアップ要因無し */
		}
	}
	l_nm_tick_ch1(u1a_slp_req);				/* NM用Tick処理API			*/
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : 外部割り込み処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : Synch Break 検出及び Wake-up ﾊﾟﾙｽの検出
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ 外部INT(IRQ)関数 l_ifc_aux_**() 
 *		   		   : 				** は、ﾃﾞﾊﾞｲｽに依存する
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.14
 *""FUNC COMMENT END""*********************************************************/
void  f_vogi_inthdr_irq0(void)
{
    /* APIを呼び出す */
    l_ifc_aux_ch1();
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ﾀｲﾏｰZ0処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : WAIT BIT の挿入及びﾍｯﾀﾞﾀｲﾑｱｳﾄ、ﾚｽﾎﾟﾝｽﾀｲﾑｱｳﾄの検出
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ ﾌﾚｰﾑﾀｲﾏ制御関数 l_ifc_tm_**() 
 *		   		   : 			** は、ﾃﾞﾊﾞｲｽに依存する
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.14
 *""FUNC COMMENT END""*********************************************************/
void  f_vogi_inthdr_tmr_z0(void)
{
    /* APIを呼び出す */
    l_ifc_tm_ch1();
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : SCI2受信割り込み処理
 *-----------------------------------------------------------------------------
 * 宣言            : 
 *-----------------------------------------------------------------------------
 * 機能            : ﾃﾞｰﾀ一文字受信
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : LINｽﾚｰﾌﾞﾗｲﾌﾞﾗﾘ ﾃﾞｰﾀ一文字受信関数 l_ifc_rx_**() 
 *		   		   : 			** は、ﾃﾞﾊﾞｲｽに依存する
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.06.17
 *""FUNC COMMENT END""*********************************************************/
void f_vogi_inthdr_sci3_2( void )
{
    /* APIを呼び出す */
    l_ifc_rx_ch1();
}

/***** End of File *****/




/*""FILE COMMENT""*************************************************************
 * System Name  : S/R system
 * File Name    : f_lin_main.h
 * Contests     : LIN ʐM   C       w b _
 * Model        : SRF ėp
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2004.07.15
 *""FILE COMMENT END""*********************************************************/

#ifndef F_LIN_MAIN_H
#define F_LIN_MAIN_H

/******************************************************************************
 * Header File Include
 ******************************************************************************/
#include "l_stddef.h"

/******************************************************************************
 * Definition section
 ******************************************************************************/

/******************************************************************************
 * declaretion section
 ******************************************************************************/
void f_vog_lin_init( u1 u1a_mode );
void f_vog_lin_rcv_main(void);
void f_vog_lin_snd_main(void);
void f_vog_lin_mng_ctrl(void);
void f_vogi_inthdr_irq0(void);
void f_vogi_inthdr_tmr_z0(void);
void f_vogi_inthdr_sci3_2( void );

#endif /* F_LIN_MAIN_H */

/*--- end of file ---*/



/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_api.h                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*           ･直接値"8"を"U1G_LIN_8"に変更                  */
/*         : 2005.02.10 Ver 2.00                            */
/*           ･"U1G_LIN_8"を"U1G_LIN_MAX_DL"に変更           */
/*           ･ライブラリリリース用にユーザ編集部分を削除    */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_API_H_INCLUDE__
#define __L_SLIN_API_H_INCLUDE__


/* フレーム名の定義 */
#define  U1G_LIN_FRAME_ID28H           	( (u1)(0x00u) )
#define  U1G_LIN_FRAME_ID29H           	( (u1)(0x01u) )
#define  U1G_LIN_FRAME_ID2AH           	( (u1)(0x02u) )
#define  U1G_LIN_FRAME_ID22H           	( (u1)(0x03u) )
#define  U1G_LIN_FRAME_ID2BH           	( (u1)(0x04u) )
#define  U1G_LIN_FRAME_ID23H           	( (u1)(0x05u) )
#define  U1G_LIN_FRAME_ID24H         	( (u1)(0x06u) )
#define  U1G_LIN_FRAME_ID3CH           	( (u1)(0x07u) )
#define  U1G_LIN_FRAME_ID3DH           	( (u1)(0x08u) )


/* シグナルの名前(Table Type) */
/* ビットシンボルテーブル構造(LDF: Frames, Signals) */
typedef union {
    l_u8    u1g_lin_byte[U1G_LIN_MAX_DL];    /******    !!!この行は変更削除を行わないでください!!!    ******/
	struct	{
		l_u16	u1g_lin_frame28_01:8;

		l_u8	u1g_flb_kpwu:1;			/* キー連動P/W UP信号 */
		l_u8	u1g_flb_kpwd:1;			/* キー連動P/W DOWN信号 */
		l_u8	u1g_flb_wpwu:1;			/* ワイヤレス連動P/W UP信号 */
		l_u8	u1g_flb_wpwd:1;			/* ワイヤレス連動P/W DOWN信号 */

		l_u8	u1g_flb_spwu:1;			/* スマート連動P/W UP信号 */
		l_u8	reserved1   :1;
		l_u8	u1g_flb_pws :1;			/* P/W作動許可信号 */
		l_u8	u1g_flb_ig  :1;			/* ボディーECU IG SW信号 */

		l_u8	u1g_flb_dcty:1;			/* D席カーテシSW信号	*/
		l_u8	reserved2:7;

		l_u8	u1g_lin_frame28_04:8;
		l_u8	reserved3:8;
		l_u8	reserved4:8;
		l_u8	reserved5:8;
		l_u8	reserved6:8;
	} st_frame_bdb1s01;
	struct	{
		l_u8	reserved1:6;
		l_u8	u1g_dat_rl:2;			/* ハンドル情報 */
		l_u8	u1g_dat_cmt:8;			/* 仕向情報 */
		l_u8	u1g_dat_spd:8;			/* 車速情報	*/
		l_u8	u1g_dat_amd:8;			/* 外気温	*/

		l_u8	reserved2:8;
		l_u8	reserved3:8;
		l_u8	reserved4:8;
		l_u8	reserved5:8;
	} st_frame_bdb1s02; 
	struct	{
		l_u8	reserved1:4;
		l_u8	u1g_flb_warn_srbz:1;	/* S/Rウォーニング信号	*/
		l_u8	reserved2:1;
		l_u8	reserved3:1;
		l_u8	reserved4:1;

		l_u8	u1g_lin_frame23_02:8;
		l_u8	u1g_lin_frame23_03:8;
		l_u8	u1g_lin_frame23_04:8;
		l_u8	reserved5:8;
		l_u8	reserved6:8;
		l_u8	reserved7:8;
		l_u8	reserved8:8;
	} st_frame_srf1s01;
	struct	{
		l_u8	u1g_lin_frame24_01:8;

		l_u8	u1g_flb_kupc:1;			/* カスタマイズ情報(キー連動P/W UP有無)	*/
		l_u8	u1g_flb_kdnc:1;			/* カスタマイズ情報(キー連動P/W DN有無)	*/
		l_u8	reserved1   :1;			/* リザーブ	*/
		l_u8	u1g_flb_jpc :1;			/* カスタマイズ情報(挟み込み防止ロジック)	*/

		l_u8	u1g_flb_wupc:1;			/* カスタマイズ情報(ワイヤレス連動P/W UP有無)*/
		l_u8	u1g_flb_wdnc:1;			/* カスタマイズ情報(ワイヤレス連動P/W DN有無)*/
		l_u8	u1g_flb_supc:1;			/* カスタマイズ情報(スマート連動P/W UP有無)  */
		l_u8	reserved2	:1;			/* リザーブ */

		l_u8	u1g_lin_frame24_03:8;
		l_u8	u1g_lin_frame24_04:8;
		l_u8	reserved4:8;
		l_u8	reserved5:8;
		l_u8	reserved6:8;
		l_u8	reserved7:8;
	} st_frame_dpw1s01;
	struct	{
		l_u8	u1g_lin_frame3c_01:8;
		l_u8	u1g_lin_frame3c_02:8;
		l_u8	u1g_lin_frame3c_03:8;
		l_u8	u1g_lin_frame3c_04:8;
		l_u8	u1g_lin_frame3c_05:8;
		l_u8	u1g_lin_frame3c_06:8;
		l_u8	u1g_lin_frame3c_07:8;
		l_u8	u1g_lin_frame3c_08:8;
	} st_frame_srfdiag; 
} un_lin_data_type;


/* 同期フラグ : フレーム送信完了フラグ */
#define  F1g_lin_txframe_id23h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot6
#define  F1g_lin_txframe_id3dh          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot9

/* 同期フラグ : フレーム受信完了フラグ */
#define  F1g_lin_rxframe_id28h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot1
#define  F1g_lin_rxframe_id29h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot2
#define  F1g_lin_rxframe_id2ah          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot3
#define  F1g_lin_rxframe_id22h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot4
#define  F1g_lin_rxframe_id2bh          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot5
#define  F1g_lin_rxframe_id24h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot7
#define  F1g_lin_rxframe_id3ch          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot8

/* 同期フラグ : フレームエラーの発生状況フラグ */
#define  F4g_lin_errframe_id28h         xng_lin_frm_buf[0].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id29h         xng_lin_frm_buf[1].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id2ah         xng_lin_frm_buf[2].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id22h         xng_lin_frm_buf[3].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id2bh         xng_lin_frm_buf[4].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id23h         xng_lin_frm_buf[5].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id24h         xng_lin_frm_buf[6].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id3ch         xng_lin_frm_buf[7].un_state.st_err.u2g_lin_err
#define  F4g_lin_errframe_id3dh         xng_lin_frm_buf[8].un_state.st_err.u2g_lin_err



/***************************************************************************/
/***************************************************************************/
/*              !!!以降は 変更、削除をおこなわないで下さい!!!              */
/***************************************************************************/
/***************************************************************************/

/* 同期フラグ: Physical Busエラー発生状況フラグ */
#define  F1g_lin_p_bus_err_ch1          xng_lin_sts_buf.un_state.st_bit.u2g_lin_phy_bus_err

/* 同期フラグ：ヘッダエラーの発生状況フラグ（エラー個別） */
#define  F1g_lin_header_err_timeout_ch1 xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_time
#define  F1g_lin_header_err_uart_ch1    xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_uart
#define  F1g_lin_header_err_synch_ch1   xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_synch
#define  F1g_lin_header_err_parity_ch1  xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_pari

/* 同期フラグ：ヘッダエラーの発生状況フラグ（エラー一括） */
#define  F4g_lin_header_err_ch1         xng_lin_sts_buf.un_state.st_err.u2g_lin_e_head


/********************************/
/* LIN API MACRO/EXTERN         */
/********************************/
/***** API関数 外部参照宣言 *****/
extern void     l_ifc_init_ch1(void);
extern void     l_ifc_init_com_ch1(void);
extern void     l_ifc_init_drv_ch1(void);
extern l_bool   l_ifc_connect_ch1(void);
extern l_bool   l_ifc_disconnect_ch1(void);
extern void     l_ifc_wake_up_ch1(void);
extern l_u16    l_ifc_read_status_ch1(void);
extern void     l_ifc_sleep_ch1(void);
extern void     l_ifc_run_ch1(void);
extern void     l_ifc_rx_ch1(void);
extern void     l_ifc_tm_ch1(void);
extern void     l_ifc_aux_ch1(void);
extern l_u16    l_ifc_read_lb_status_ch1(void);
extern void     l_slot_enable_ch1(l_frame_handle  u1a_lin_frm);
extern void     l_slot_disable_ch1(l_frame_handle  u1a_lin_frm);
extern void     l_slot_rd_ch1(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, l_u8* pta_lin_data);
extern void     l_slot_wr_ch1(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, const l_u8* pta_lin_data);
extern void     l_slot_set_default_ch1(l_frame_handle u1a_lin_frm);
extern void     l_slot_set_fail_ch1(l_frame_handle  u1a_lin_frm);

#endif

/***** End of File *****/




/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_cmn.c                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#pragma	section	lin

/***** ヘッダ インクルード *****/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"

/*** 関数のプロトタイプ宣言(API) ***/
l_bool l_sys_init(void);

/*===========================================================================================*/

/**************************************************/
/*  システム初期化 処理(API)                      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_bool  l_sys_init(void)
{
    l_u8   u1a_lin_parachk;
    l_u8   u1a_lin_tblchk;
    l_bool u2a_lin_result;

    /* パラメータチェック */
    u1a_lin_parachk = l_u1g_lin_para_chk();

    if( u1a_lin_parachk != U1G_LIN_OK ){
        u2a_lin_result = U2G_LIN_NG;
    }
    else{
        /* テーブルパラメータチェック */
        u1a_lin_tblchk = l_u1g_lin_tbl_chk();

        if( u1a_lin_tblchk != U1G_LIN_OK ){
            u2a_lin_result = U2G_LIN_NG;
        }
        else{
            u2a_lin_result = U2G_LIN_OK;
        }
    }

    return( u2a_lin_result );
}

/***** End of File *****/




/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_cmn.h                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_CMN_H_INCLUDE__
#define __L_SLIN_CMN_H_INCLUDE__

/***** 型宣言 *****/
typedef unsigned char   l_u8;
typedef unsigned int    l_u16;
typedef unsigned long   l_u32;
typedef unsigned int    l_bool;
typedef unsigned char   l_frame_handle;

/***** 定数定義 *****/
/* Wakeup検出 */
#define  U1G_LIN_WP_UART_USE        (0)             /* WAKEUP検出にUARTを使用        */
#define  U1G_LIN_WP_INT_USE         (1)             /* WAKEUP検出にINT割り込みを使用 */

#define  U1G_LIN_ENDIAN_LITTLE      (0)             /* リトルエンディアンタイプ */
#define  U1G_LIN_ENDIAN_BIG         (1)             /* ビッグエンディアンタイプ */

/* 通信ボーレート */
#define  U1G_LIN_BAUDRATE_2400      (0)             /* 通信ボーレート2400bpsを使用  */
#define  U1G_LIN_BAUDRATE_9600      (1)             /* 通信ボーレート9600bpsを使用  */
#define  U1G_LIN_BAUDRATE_19200     (2)             /* 通信ボーレート19200bpsを使用 */

/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
#define  U1G_LIN_EDGE_INT_NON       (0)
#define  U1G_LIN_EDGE_INT_UP        (1)
#define  U1G_LIN_EDGE_INT_DOWN      (2)
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */

/* unsigned char型のOK/NG */
#define  U1G_LIN_OK                 ((l_u8)0)       /* 処理成功 */
#define  U1G_LIN_NG                 ((l_u8)1)       /* 処理失敗 */

/* bool型のOK/NG */
#define  U2G_LIN_OK                 ((l_bool)0)     /* 処理成功 */
#define  U2G_LIN_NG                 ((l_bool)1)     /* 処理失敗 */

/* LINステータス */
#define  U2G_LIN_STS_RESET          ((l_u16)0)      /* LINステータス = RESET       */
#define  U2G_LIN_STS_SLEEP          ((l_u16)1)      /* LINステータス = SLEEP       */
#define  U2G_LIN_STS_RUN_STANDBY    ((l_u16)2)      /* LINステータス = RUN STANDBY */
#define  U2G_LIN_STS_RUN            ((l_u16)3)      /* LINステータス = RUN         */

#define  U1G_LIN_MAX_SLOT_NUM       ((l_u8)64)      /* スロット最大数 */

#define  U1G_LIN_DATA_SUM_LEN       ((l_u8)9)       /* データ長(8バイト)＋チェックサム長(1バイト) */

#define  U1G_LIN_WORD_BIT           ((l_u8)16)      /* word型をbitで分割(16bit) */

/* ID Info Send/Recv Setting */
#define  U1G_LIN_CMD_SND            ((l_u8)0)       /* 送信フレーム */
#define  U1G_LIN_CMD_RCV            ((l_u8)1)       /* 受信フレーム */

/* NM使用/未使用(unsigned char型) */
#define  U1G_LIN_NM_NO_USE          ((l_u8)0)       /* NM未使用 */
#define  U1G_LIN_NM_USE             ((l_u8)1)       /* NM使用   */

#define  U1G_LIN_NO_FRAME           ((l_u8)0xFF)    /* 未登録フレーム(ID = 0xFF) */

#define  U2G_LIN_MASK_FF            ((l_u16)0x00FF) /* FFh(下位バイト)のマスク */

/* システム異常フラグ */
#define  U1G_LIN_SYSERR_STAT        ((l_u8)1)       /* LINステータスが規定値以外 */
#define  U1G_LIN_SYSERR_DIV         ((l_u8)2)       /* 0除算発生 */

/* Ver 2.00 追加:意味のあるデファイン名に変更 */
/* LINレスポンスバッファのレジスタ */
#define  U1G_LIN_MAX_DL             ((l_u8)8)       /* 最大データサイズ */
/* Ver 2.00 追加:意味のあるデファイン名に変更 */

/* ID Info DL Setting */
#define  U1G_LIN_DL_1               ((l_u8)0x01)
#define  U1G_LIN_DL_2               ((l_u8)0x02)
#define  U1G_LIN_DL_3               ((l_u8)0x03)
#define  U1G_LIN_DL_4               ((l_u8)0x04)
#define  U1G_LIN_DL_5               ((l_u8)0x05)
#define  U1G_LIN_DL_6               ((l_u8)0x06)
#define  U1G_LIN_DL_7               ((l_u8)0x07)
#define  U1G_LIN_DL_8               ((l_u8)0x08)
#define  U1G_LIN_DL_n               ((l_u8)0x0F)


/* unsigned char型 */
#define  U1G_LIN_BIT_CLR            ((l_u8)0)
#define  U1G_LIN_BIT_SET            ((l_u8)1)
#define  U1G_LIN_BYTE_CLR           ((l_u8)0x00)

#define  U1G_LIN_0                  ((l_u8)0)
#define  U1G_LIN_1                  ((l_u8)1)
#define  U1G_LIN_2                  ((l_u8)2)
#define  U1G_LIN_3                  ((l_u8)3)
#define  U1G_LIN_4                  ((l_u8)4)
#define  U1G_LIN_5                  ((l_u8)5)
#define  U1G_LIN_6                  ((l_u8)6)
#define  U1G_LIN_7                  ((l_u8)7)
#define  U1G_LIN_8                  ((l_u8)8)
#define  U1G_LIN_16                 ((l_u8)16)
#define  U1G_LIN_32                 ((l_u8)32)
#define  U1G_LIN_48                 ((l_u8)48)
#define  U1G_LIN_64                 ((l_u8)64)


/* unsigned int型 */
#define  U2G_LIN_BIT_CLR            ((l_u16)0)
#define  U2G_LIN_BIT_SET            ((l_u16)1)
#define  U2G_LIN_BYTE_CLR           ((l_u16)0x00)
#define  U2G_LIN_WORD_CLR           ((l_u16)0x0000)

#define  U2G_LIN_1                  ((l_u16)1)
#define  U2G_LIN_2                  ((l_u16)2)
#define  U2G_LIN_4                  ((l_u16)4)
#define  U2G_LIN_8                  ((l_u16)8)
#define  U2G_LIN_10                 ((l_u16)10)
#define  U2G_LIN_12                 ((l_u16)12)
#define  U2G_LIN_14                 ((l_u16)14)


/* unsigned long型 */
#define  U4G_LIN_LONG_CLR           ((l_u32)0x00000000)

#define  U4G_LIN_1                  ((l_u32)1)

/* NULL */
#define  U1G_LIN_NULL               (0u)

/***** API関数 外部参照宣言(extern) *****/
extern l_bool l_sys_init(void);

/***** その他の関数 外部参照宣言(extern) *****/
extern l_u8  l_u1g_lin_para_chk(void);
extern l_u8  l_u1g_lin_tbl_chk(void);
/***** APIマクロ宣言 *****/
#define  l_bool_rd(x)       (x)
#define  l_u8_rd(x)         (x)
#define  l_u16_rd(x)        (x)
#define  l_bool_wr(x, v)    ( (x) = (v) )
#define  l_u8_wr(x, v)      ( (x) = (v) )
#define  l_u16_wr(x, v)     ( (x) = (v) )
#define  l_flg_tst(x)       (x)
#define  l_flg_clr(x)       ( (x) = 0 )

#endif

/***** End of File *****/




/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_core_h83687.c                       */
/* Version     : 2.10                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         : H8/3687                                    */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*         : 2005.04.21 Ver 2.10                            */
/*""FILE COMMENT END""***************************************/

#pragma	section	lin

/***** ヘッダ インクルード *****/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_core_h83687.h"
/* Ver 1.01 追加:アセンブラ関数プロトタイプ宣言のため -> start */
#include "l_slin_drv_h83687.h"
/* Ver 1.01 追加:アセンブラ関数プロトタイプ宣言のため <- end */

/***** 関数プロトタイプ宣言 *****/
/*-- API関数定義(extern) --*/
void   l_ifc_init_ch1(void);
void   l_ifc_init_com_ch1(void);
void   l_ifc_init_drv_ch1(void);
l_bool l_ifc_connect_ch1(void);
l_bool l_ifc_disconnect_ch1(void);
void   l_ifc_wake_up_ch1(void);
l_u16  l_ifc_read_status_ch1(void);
void   l_ifc_sleep_ch1(void);
void   l_ifc_run_ch1(void);
l_u16  l_ifc_read_lb_status_ch1(void);
void   l_slot_enable_ch1(l_frame_handle  u1a_lin_frm);
void   l_slot_disable_ch1(l_frame_handle  u1a_lin_frm);
void   l_slot_rd_ch1(l_frame_handle  u1a_lin_frm, l_u8 u1a_lin_cnt, l_u8 * pta_lin_data);
void   l_slot_wr_ch1(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, const l_u8 * pta_lin_data);
void   l_slot_set_default_ch1(l_frame_handle u1a_lin_frm);
void   l_slot_set_fail_ch1(l_frame_handle  u1a_lin_frm);
/*-- 関数定義(extern) --*/
void   l_vog_lin_rx_int(l_u8 u1a_lin_data, l_u8 u1a_lin_err);
void   l_vog_lin_tm_int(void);
void   l_vog_lin_irq_int(void);
void   l_vog_lin_set_nm_info(l_u8  u1a_lin_nm_info);
l_u8   l_u1g_lin_tbl_chk(void);

/*-- 関数定義(static) --*/
static void   l_vol_lin_set_wakeup(void);
static void   l_vol_lin_set_synchbreak(void);
static void   l_vol_lin_set_frm_complete(l_u8  u1a_lin_err);

/*** 変数定義(static) ***/
static st_lin_id_slot_type  xnl_lin_id_sl;              /* 使用中のフレームのIDとスロット番号の管理テーブル */
static l_u8   u1l_lin_slv_sts;                          /* スレーブタスク用ステータス */
static l_u8   u1l_lin_frm_sz;                           /* データサイズ */
static l_u8   u1l_lin_rs_cnt;                           /* 送受信データカウンタ */
static l_u8   u1l_lin_rs_tmp[ U1G_LIN_DATA_SUM_LEN ];   /* 送受信データ用tmpバッファ(Data + Checksum) 9バイト */
static l_u16  u2l_lin_chksum;                           /* チェックサム格納 */
static l_u16  u2l_lin_herr_cnt;                         /* ヘッダタイムアウトエラー回数カウンタ（Physical Busエラー検出用） */

/*===========================================================================================*/

/**********************************/
/* MCU非依存API関数処理           */
/**********************************/
/**************************************************/
/*  バッファ、ドライバの初期化処理(API)           */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_init_ch1(void)
{
    l_ifc_init_com_ch1();                                               /* LINバッファの初期化(API) */
    xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RESET;    /* RESET状態にする */
    l_ifc_init_drv_ch1();                                               /* LINドライバの初期化(API) */
    u1g_lin_syserr = U1G_LIN_BYTE_CLR;                                  /* システム異常フラグのクリア */
}

/**************************************************/
/*  LINバッファの初期化 処理(API)                 */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_init_com_ch1(void)
{
    l_u8    u1a_lin_lp1;
    l_u8    u1a_lin_flg;

  /*--- LINステータスバッファ初期化 ---*/
    /* NADのセット */
    xng_lin_sts_buf.un_state.st_bit.u2g_lin_nad = U2G_LIN_NAD;

    /* Physical Busエラーフラグのクリア */
    xng_lin_sts_buf.un_state.st_bit.u2g_lin_phy_bus_err = U2G_LIN_BIT_CLR;

    /* ヘッダーエラーフラグのクリア */
    xng_lin_sts_buf.un_state.st_err.u2g_lin_e_head = U2G_LIN_BYTE_CLR;

    /* 送受信処理完了フラグのクリア */
    xng_lin_sts_buf.un_rs_flg1.u2g_lin_word = U2G_LIN_WORD_CLR;
    xng_lin_sts_buf.un_rs_flg2.u2g_lin_word = U2G_LIN_WORD_CLR;
    xng_lin_sts_buf.un_rs_flg3.u2g_lin_word = U2G_LIN_WORD_CLR;
    xng_lin_sts_buf.un_rs_flg4.u2g_lin_word = U2G_LIN_WORD_CLR;

    /*--- LINフレームバッファ初期化 ---*/
    for( u1a_lin_lp1 = U1G_LIN_0; u1a_lin_lp1 < U1G_LIN_MAX_SLOT; u1a_lin_lp1++ ){

        u1a_lin_flg = l_u1g_lin_irq_dis();                                  /* 割り込み禁止設定 */

        /* ステータス部分(エラーフラグ等)クリア */
        xng_lin_frm_buf[ u1a_lin_lp1 ].un_state.u2g_lin_word = U2G_LIN_BYTE_CLR;

        /* LINバッファのデータ部をデフォルト値で初期化する */
        /* デフォルト値設定 */
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_0 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_1 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_2 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_3 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_4 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_5 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_6 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_7 ];

        l_vog_lin_irq_res( u1a_lin_flg );                                   /* 割り込み設定復元 */
    }
}


/**************************************************/
/*  LINドライバの初期化 処理(API)                 */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_init_drv_ch1(void)
{
/* Ver 1.01 削除:未使用変数のため -> start */
/*    l_u8    u1a_lin_lp; */
/* Ver 1.01 削除:未使用変数のため <- end */

    /*** UARTの初期化 ***/
    l_vog_lin_uart_init();

    /*** Timerの初期化 ***/
    l_vog_lin_timer_init();

    /*** 外部INTの初期化 ***/
    l_vog_lin_int_init();

    u2l_lin_herr_cnt = U2G_LIN_WORD_CLR;                                /* Physical Busエラー検出カウンタクリア */

    /* スレーブタスクのステータスを確認 */
    switch( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts ){
    /* SLEEP状態 */
    case ( U2G_LIN_STS_SLEEP ):
        l_vol_lin_set_wakeup();                                         /* Wakeup待機設定 */
        break;
    /* RUN状態 / RUN STANDBY状態 */
    case ( U2G_LIN_STS_RUN_STANDBY ):
    case ( U2G_LIN_STS_RUN ):
        /* SynchBreak受信待ち状態に設定 */
        xng_lin_bus_sts.u2g_lin_word &= U2G_LIN_STSBUF_CLR;             /* リードステータスバッファのクリア */

        l_vol_lin_set_synchbreak();                                     /* Synch Break受信待ち設定 */

        break;
    default:
        /* 上記以外は、何もしない */
        break;
    }
}


/**************************************************/
/*  LIN通信接続 処理(API)                         */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_bool  l_ifc_connect_ch1(void)
{
    l_bool  u2a_lin_result;

    /* ステータスがRESET状態の場合 */
    if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RESET ) {
        /* SLEEPへ移行 */
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_SLEEP;        /* SLEEP状態へ移行 */
        l_vol_lin_set_wakeup();                                                 /* Wakeup待機設定 */

        u2a_lin_result = U2G_LIN_OK;
    }
    /* RESET状態以外の場合 */
    else {
        u2a_lin_result = U2G_LIN_NG;
    }

    return( u2a_lin_result );
}


/**************************************************/
/*  LIN切断 処理(API)                             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_bool  l_ifc_disconnect_ch1(void)
{
    l_bool  u2a_lin_result;
    l_u8   u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

    /* SLEEP状態の場合 */
    if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_SLEEP ){
        /* タイマの停止 */
        l_vog_lin_frm_tm_stop();
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RESET;
      /* UARTによるWAKEUP検出の場合 */
      #if U1G_LIN_WAKEUP == U1G_LIN_WP_UART_USE
        l_vog_lin_rx_dis();                                     /* 受信割り込みを禁止する */
      /* INT割り込みによるWAKEUP検出の場合 */
      #elif U1G_LIN_WAKEUP == U1G_LIN_WP_INT_USE
        l_vog_lin_int_dis();                                    /* INT割り込みを禁止する */
      #endif

        u2a_lin_result = U2G_LIN_OK;
    }
    /* RESET状態の場合 */
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RESET ){
        /* なにもせず、処理成功を返す */
        u2a_lin_result = U2G_LIN_OK;
    }
    /* SLEEPでもRESETでもない場合 */
    else{
        u2a_lin_result = U2G_LIN_NG;
    }

    l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */

    return( u2a_lin_result );
}


/**************************************************/
/*  wakeupコマンド送信 処理(API)                  */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_wake_up_ch1(void)
{
/* Ver 2.10 変更（管理番号15）:Wakeupパルス送信後、立下りエッジで検出した時のWakeupパルス送信中断対策 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
    l_u16   u2a_lin_sts_tmp;

    /* ステータスをtmpに格納 */
    u2a_lin_sts_tmp = xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts;

    /* SLEEP / RUN STANDBY状態の場合 */
    if( (u2a_lin_sts_tmp == U2G_LIN_STS_SLEEP)
     || (u2a_lin_sts_tmp == U2G_LIN_STS_RUN_STANDBY) ){

        /* wakeupパルスを送信 */
        l_vog_lin_tx_char( U1G_LIN_SND_WAKEUP_DATA );
    }
    /* SLEEP状態以外の場合 なにもしない */
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
    l_u8   u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                          /* 割り込み禁止設定 */
    
    /* RUN STANDBY状態の場合 */
    if(xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN_STANDBY){
        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
        /* wakeupパルスを送信 */
        l_vog_lin_tx_char( U1G_LIN_SND_WAKEUP_DATA );
    }
    /* SLEEP状態場合 */
    else if(xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_SLEEP){
      /* UARTによるWAKEUP検出の場合 */
      #if U1G_LIN_WAKEUP == U1G_LIN_WP_UART_USE
        l_vog_lin_rx_dis();                                     /* 受信割り込みを禁止する */
      /* INT割り込みによるWAKEUP検出の場合 */
      #elif U1G_LIN_WAKEUP == U1G_LIN_WP_INT_USE
        l_vog_lin_int_dis();                                    /* INT割り込みを禁止する */
      #endif
        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
        /* wakeupパルスを送信 */
        l_vog_lin_tx_char( U1G_LIN_SND_WAKEUP_DATA );
        l_vog_lin_bit_tm_set( U1G_LIN_BYTE_LENGTH );            /* 送信完了待ちタイマセット(1バイト長) */
    }
    /* RUN STANDBY / SLEEP状態以外の場合 */
    else{
        /* なにもしない */
        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
    }
/* Ver 2.10 変更（管理番号15）:Wakeupパルス送信後、立下りエッジで検出した時のWakeupパルス送信中断対策 */
}


/**************************************************/
/*  LINバス状態リード 処理(API)                   */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： LINバス状態                            */
/**************************************************/
l_u16  l_ifc_read_status_ch1(void)
{
    l_u16  u2a_lin_result;
    l_u8   u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

    u2a_lin_result = xng_lin_bus_sts.u2g_lin_word;
    xng_lin_bus_sts.u2g_lin_word &= U2G_LIN_STSBUF_CLR;     /* ステータスクリア */

    l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */

    return( u2a_lin_result );
}


/**************************************************/
/*  SLEEP状態移行 処理(API)                       */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_sleep_ch1(void)
{
    l_u8   u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

    /* RUN / RUN STANDBY状態の場合 */
    if( (xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN)
     || (xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN_STANDBY) ){

        l_vog_lin_frm_tm_stop();                                            /* タイマ停止 */

        /* SLEEPへ移行 */ 
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_SLEEP;    /* SLEEP状態に移行 */
        l_vol_lin_set_wakeup();                                             /* Wakeup待機設定 */
    }
    /* RUN / RUN STANDBY以外の場合 なにもしない */

    l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */

}


/**************************************************/
/*  LINステータスのリード 処理(API)               */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： LINステータス                          */
/**************************************************/
l_u16  l_ifc_read_lb_status_ch1(void)
{
    l_u16  u2a_lin_result;

    /* 現在のLINステータスを格納 */
    u2a_lin_result = xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts;

    return( u2a_lin_result );
}


/**************************************************/
/*  スロット有効フラグクリア処理(API)             */
/*------------------------------------------------*/
/*  引数： frame: フレーム名                      */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_enable_ch1(l_frame_handle  u1a_lin_frm)
{
    /* 引数値が範囲内の場合 */
    if( u1a_lin_frm < U1G_LIN_MAX_SLOT ){
        /* LINバッファ スロット有効 */
        xng_lin_frm_buf[ u1a_lin_frm ].un_state.st_bit.u2g_lin_no_use = U2G_LIN_BIT_CLR;
    }
    /* 引数値が範囲外の場合 なにもしない */
}


/**************************************************/
/*  スロット無効フラグセット処理(API)             */
/*------------------------------------------------*/
/*  引数： frame: フレーム名                      */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_disable_ch1(l_frame_handle  u1a_lin_frm)
{
    /* 引数値が範囲内の場合 */
    if( u1a_lin_frm < U1G_LIN_MAX_SLOT ){
        /* LINバッファ スロット無効 */
        xng_lin_frm_buf[ u1a_lin_frm ].un_state.st_bit.u2g_lin_no_use = U2G_LIN_BIT_SET;
    }
    /* 引数値が範囲外の場合 なにもしない */
}


/**************************************************/
/*  バッファ スロット読み出し処理(API)            */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : 読み出すフレーム名      */
/*         u1a_lin_cnt  : 読み出しデータ長        */
/*         pta_lin_data : データ格納先ポインタ    */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_rd_ch1(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, l_u8 * pta_lin_data)
{
    l_u8  u1a_lin_flg;

    /* ポインタ(引数値)がNULL以外の場合 */
    if( pta_lin_data != U1G_LIN_NULL){
        /* 引数値が範囲内の場合 */
        if( u1a_lin_frm < U1G_LIN_MAX_SLOT ){

            u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

            switch( u1a_lin_cnt ) {
            case ( U1G_LIN_8 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                pta_lin_data[ U1G_LIN_5 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                pta_lin_data[ U1G_LIN_6 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ];
                pta_lin_data[ U1G_LIN_7 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ];
                break;
            case ( U1G_LIN_7 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                pta_lin_data[ U1G_LIN_5 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                pta_lin_data[ U1G_LIN_6 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ];
                break;
            case ( U1G_LIN_6 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                pta_lin_data[ U1G_LIN_5 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                break;
            case ( U1G_LIN_5 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                break;
            case ( U1G_LIN_4 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                break;
            case ( U1G_LIN_3 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                break;
            case ( U1G_LIN_2 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                break;
            case ( U1G_LIN_1 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                break;
            default:
                /* 指定サイズ異常の為、何もしない */
                break;
            }

            l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
        }
        /* 引数が範囲外の場合 何もしない */
    }
    /* ポインタ(引数値)がNULLの場合 何もしない */
}


/**************************************************/
/*  バッファ スロット書き込み処理(API)            */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : 書き込むフレーム名      */
/*         u1a_lin_cnt  : 書き込みデータ長        */
/*         pta_lin_data : 書き込み格納元ポインタ  */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_wr_ch1(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, const l_u8 * pta_lin_data)
{
    l_u8  u1a_lin_flg;

    /* ポインタ(引数値)がNULL以外の場合 */
    if( pta_lin_data != U1G_LIN_NULL){
        /* 引数値が範囲内の場合 */
        if( u1a_lin_frm < U1G_LIN_MAX_SLOT ){

            u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

            switch( u1a_lin_cnt ) {
            case ( U1G_LIN_8 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] = pta_lin_data[ U1G_LIN_5 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ] = pta_lin_data[ U1G_LIN_6 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ] = pta_lin_data[ U1G_LIN_7 ];
                break;
            case ( U1G_LIN_7 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] = pta_lin_data[ U1G_LIN_5 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ] = pta_lin_data[ U1G_LIN_6 ];
                break;
            case ( U1G_LIN_6 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] = pta_lin_data[ U1G_LIN_5 ];
                break;
            case ( U1G_LIN_5 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                break;
            case ( U1G_LIN_4 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                break;
            case ( U1G_LIN_3 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                break;
            case ( U1G_LIN_2 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                break;
            case ( U1G_LIN_1 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                break;
            default:
                /* 指定サイズ異常の為、何もしない */
                break;
            }

            l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
        }
        /* 引数値が範囲外の場合 何もしない */
    }
    /* ポインタ(引数値)がNULLの場合 何もしない */
}


/**************************************************/
/*  バッファスロット初期値設定処理(API)           */
/*------------------------------------------------*/
/*  引数： フレーム名                             */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_set_default_ch1(l_frame_handle  u1a_lin_frm)
{
    l_u8  u1a_lin_flg;

    /* 引数値が範囲内の場合 */
    if( u1a_lin_frm < U1G_LIN_MAX_SLOT ){

        u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

        /* デフォルト値設定 */
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_0 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_1 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_2 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_3 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_4 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_5 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_6 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_7 ];

        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
    }
    /* 引数値が範囲外の場合 なにもしない */
}


/**************************************************/
/*  バッファスロットFAIL値設定処理(API)           */
/*------------------------------------------------*/
/*  引数： フレーム名                             */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_set_fail_ch1(l_frame_handle  u1a_lin_frm)
{
    l_u8  u1a_lin_flg;

    /* 引数値が範囲内の場合 */
    if( u1a_lin_frm < U1G_LIN_MAX_SLOT ){

        u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

        /* フェイル値設定 */
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_0];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_1];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_2];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_3];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_4];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_5];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_6];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_7];

        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
    }
    /* 引数値が範囲外の場合 なにもしない */
}


/**************************************************/
/*  RUN状態移行 処理(API)                         */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_run_ch1(void)
{
    l_u8   u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                          /* 割り込み禁止設定 */

    /* SLEEP状態の場合 */
    if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_SLEEP ){
        /* RUN STANDBY状態へ移行 */
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RUN_STANDBY;

        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */

        l_ifc_init_drv_ch1();                                   /* ドライバ部の初期化 */
    /* SLEEP以外の場合 なにもしない */
    }else{
        l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定復元 */
    }
}


/**************************************************/
/*  受信割り込み発生                              */
/*------------------------------------------------*/
/*  引数： data : 受信データ                      */
/*         err  : 受信エラーフラグ                */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_rx_int(l_u8 u1a_lin_data, l_u8 u1a_lin_err)
{
    l_u8  u1a_lin_protid;

    /*** SLEEP状態の場合 ***/
    if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_SLEEP ){
        /* WAKEUPコマンド受信(UARTによるWAKEUP検出) */
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RUN_STANDBY;      /* RUN STANDBY状態へ移行 */
        l_ifc_init_drv_ch1();                                                       /* ドライバ部の初期化 */
    }
    /*** RUN STANDBY状態の場合 ***/
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN_STANDBY ){
        /* Synch Break(UART)待ち状態 */
        if( u1l_lin_slv_sts == U1G_LIN_SLSTS_BREAK_UART_WAIT ){
            /* Framingエラー発生 */
            if( (u1a_lin_err & U1G_LIN_FRAMING_ERR_ON) == U1G_LIN_FRAMING_ERR_ON ) {
                /* 受信データが00hならば、SynchBreak受信 */
                if( u1a_lin_data == U1G_LIN_SYNCH_BREAK_DATA ) {
                    xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RUN;          /* RUN状態へ移行 */
                    /* ヘッダタイムアウトタイマセット */
                    l_vog_lin_bit_tm_set( U1G_LIN_HEADER_MAX_TIME - U1G_LIN_BYTE_LENGTH );
                    /* SynchBreak(IRQ待ち)状態に移行 */
                    u1l_lin_slv_sts = U1G_LIN_SLSTS_BREAK_IRQ_WAIT;
                    l_vog_lin_rx_dis();
                }
                /* 受信データが00h以外ならば */
                else {
                    /* エラーフラグのリセット */
                    l_vog_lin_rx_enb();                                            /* Synch Break待ち */
                }
            }
            /* Over Runエラーの発生 */
            else if( (u1a_lin_err & U1G_LIN_OVERRUN_ERR) != U1G_LIN_BYTE_CLR ) {
                /* エラーフラグのリセット */
                l_vog_lin_rx_enb();                                            /* Synch Break待ち */
            }
            /* エラー未発生 */
            else {
                /* エラー発生していない場合は何もしない */
            }
        }
    }
    /*** RUN状態の場合 ***/
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN ){
        /* スレーブタスクのステータスを確認 */
        switch( u1l_lin_slv_sts ){
        /*** Synch Break(UART)待ち状態 ***/
        case( U1G_LIN_SLSTS_BREAK_UART_WAIT ):
            /* Framingエラー発生 */
            if( (u1a_lin_err & U1G_LIN_FRAMING_ERR_ON) == U1G_LIN_FRAMING_ERR_ON ) {
                /* 受信データが00hならば、SynchBreak受信 */
                if( u1a_lin_data == U1G_LIN_SYNCH_BREAK_DATA ) {
                     /* ヘッダタイムアウトタイマセット */
                    l_vog_lin_bit_tm_set( U1G_LIN_HEADER_MAX_TIME - U1G_LIN_BYTE_LENGTH );
                    /* SynchBreak(IRQ待ち)状態に移行 */
                    u1l_lin_slv_sts = U1G_LIN_SLSTS_BREAK_IRQ_WAIT;
                    l_vog_lin_rx_dis();
                }
                /* 受信データが00h以外ならば */
                else {
                    /* エラーフラグのリセット */
                    l_vog_lin_rx_enb();                                            /* Synch Break待ち */
                }
            }
            /* Over Runエラーの発生 */
            else if( (u1a_lin_err & U1G_LIN_OVERRUN_ERR) != U1G_LIN_BYTE_CLR ) {
                /* エラーフラグのリセット */
                l_vog_lin_rx_enb();                                            /* Synch Break待ち */
            }
            /* エラー未発生 */
            else {
                /* エラー発生していない場合は何もしない */
            }
            break;
        /*** Synch Break(IRQ)待ち状態 ***/
        case( U1G_LIN_SLSTS_BREAK_IRQ_WAIT ):
            /* 何もしない */
            break;
        /*** Synch Field待ち状態 ***/
        case( U1G_LIN_SLSTS_SYNCHFIELD_WAIT ):
            /* UARTエラーが発生した場合 */
            if( (u1a_lin_err & U1G_LIN_UART_ERR_ON) != U1G_LIN_BYTE_CLR ){
                xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_uart = U2G_LIN_BIT_SET;       /* UARTエラー */
                xng_lin_bus_sts.st_bit.u2g_lin_head_err = U2G_LIN_BIT_SET;              /* Headerエラー */

                l_vol_lin_set_synchbreak();                                             /* Synch Break受信待ち設定 */
            }
            /* UARTエラーなしの場合 */
            else{
                /* 受信データが55h以外の場合 */
                if( u1a_lin_data != U1G_LIN_SYNCH_FIELD_DATA ){
                    xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_synch = U2G_LIN_BIT_SET;  /* Synch Fieldエラー */
                    xng_lin_bus_sts.st_bit.u2g_lin_head_err = U2G_LIN_BIT_SET;          /* Headerエラー */

                    l_vol_lin_set_synchbreak();                                         /* Synch Break受信待ち設定 */
                }
                /* 正常Synch Field受信 */
                else{
                    u1l_lin_slv_sts = U1G_LIN_SLSTS_IDENTFIELD_WAIT;                    /* Ident Field待ち状態 */
                }
            }
            break;
        /*** Ident Field待ち状態 ***/
        case( U1G_LIN_SLSTS_IDENTFIELD_WAIT ):
            /* UARTエラーが発生した場合 */
            if( (u1a_lin_err & U1G_LIN_UART_ERR_ON) != U1G_LIN_BYTE_CLR ){
                xng_lin_bus_sts.st_bit.u2g_lin_head_err = U2G_LIN_BIT_SET;              /* Headerエラー */
                xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_uart = U2G_LIN_BIT_SET;       /* UARTエラー */

                l_vol_lin_set_synchbreak();                                             /* Synch Break受信待ち設定 */
            }
            /* UARTエラーなし */
            else{
                /* PARITYエラーが発生した場合 */
/* Ver 2.00 変更:QACワーニング対応 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
                u1a_lin_protid = u1g_lin_protid_tbl[ u1a_lin_data & U1G_LIN_ID_PARITY_MASK ];
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
                u1a_lin_protid = u1g_lin_protid_tbl[ (u1a_lin_data & U1G_LIN_ID_PARITY_MASK) ];
/* Ver 2.00 変更:QACワーニング対応 */
                if( u1a_lin_data != u1a_lin_protid ){
                    xng_lin_bus_sts.st_bit.u2g_lin_head_err = U2G_LIN_BIT_SET;          /* Headerエラー */
                    xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_pari = U2G_LIN_BIT_SET;   /* PARITYエラー */

                    l_vol_lin_set_synchbreak();                                         /* Synch Break受信待ち設定 */
                }
                /* PARITYエラーなし */
                else{
                    /* ID,フレームモードを管理変数に格納 */
/* Ver 2.00 変更:コンパイルワーニング対策 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
                    xnl_lin_id_sl.u1g_lin_id = ( u1a_lin_data & U1G_LIN_ID_PARITY_MASK );   /* パリティを省く */
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
                    xnl_lin_id_sl.u1g_lin_id = (l_u8)( u1a_lin_data & U1G_LIN_ID_PARITY_MASK );   /* パリティを省く */
/* Ver 2.00 変更:コンパイルワーニング対策 */
                    xnl_lin_id_sl.u1g_lin_slot = u1g_lin_id_tbl[ xnl_lin_id_sl.u1g_lin_id ];

                    /* SLEEPコマンドIDを受信した場合(必ずレスポンス受信動作となる) */
                    if( xnl_lin_id_sl.u1g_lin_id == U1G_LIN_SLEEP_ID ){
                        /* フレームが[定義] かつ LINバッファのスロットが[未使用設定]の場合 */
                        if( (xnl_lin_id_sl.u1g_lin_slot != U1G_LIN_NO_FRAME)
                         && (xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_no_use == U2G_LIN_BIT_SET) ){
                            xnl_lin_id_sl.u1g_lin_slot = U1G_LIN_NO_FRAME;              /* フレーム[未定義]に変更 */
                        }
                        u2l_lin_herr_cnt = U2G_LIN_WORD_CLR;                            /* Physical Busエラー検出カウンタクリア */

                        u2l_lin_chksum = U2G_LIN_WORD_CLR;                              /* チェックサム演算用変数の初期化 */
                        u1l_lin_rs_cnt = U1G_LIN_BYTE_CLR;                              /* データ送信カウンタの初期化 */
                        u1l_lin_frm_sz = U1G_LIN_DL_8;                                  /* SLEEP時のフレームサイズは8固定 */
                        /* 応答タイムアウトタイマの起動 */
/* Ver 2.00 変更:コンパイルワーニング対策 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
                        l_vog_lin_rcv_tm_set( (u1l_lin_frm_sz + U1G_LIN_1) * U1G_LIN_BYTE_LENGTH );
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
                        l_vog_lin_rcv_tm_set( (l_u8)((u1l_lin_frm_sz + U1G_LIN_1) * U1G_LIN_BYTE_LENGTH) );
/* Ver 2.00 変更:コンパイルワーニング対策 */

                        u1l_lin_slv_sts = U1G_LIN_SLSTS_RCVDATA_WAIT;                   /* データ受信待ち状態 */
                    }
                    /* SLEEPコマンド以外の場合 */
                    else{
                        /* フレームが[未定義] もしくは LINバッファのスロットが[未使用設定]の場合 */
                        if( (xnl_lin_id_sl.u1g_lin_slot == U1G_LIN_NO_FRAME)
                         || (xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_no_use == U2G_LIN_BIT_SET) ){

                            l_vol_lin_set_synchbreak();                                 /* Synch Break受信待ち設定 */
                        }
                        /* 処理対象フレームの場合 */
                        else{
                            u2l_lin_herr_cnt = U2G_LIN_WORD_CLR;                        /* Physical Busエラー検出カウンタクリア */

                            /* 現在のフレームデータ長 */
                            u1l_lin_frm_sz = xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_frm_sz;

                            /*-- [受信フレーム時] --*/
                            if( xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_sndrcv == U1G_LIN_CMD_RCV ){
                                u2l_lin_chksum = U2G_LIN_WORD_CLR;                      /* チェックサム演算用変数の初期化 */
                                u1l_lin_rs_cnt = U1G_LIN_BYTE_CLR;                      /* データ受信カウンタの初期化 */

                                /* 応答タイムアウトタイマの起動 */
/* Ver 2.00 変更:コンパイルワーニング対策 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
                                l_vog_lin_rcv_tm_set( (u1l_lin_frm_sz + U1G_LIN_1) * U1G_LIN_BYTE_LENGTH );
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
                                l_vog_lin_rcv_tm_set( (l_u8)((u1l_lin_frm_sz + U1G_LIN_1) * U1G_LIN_BYTE_LENGTH) );
/* Ver 2.00 変更:コンパイルワーニング対策 */

                                u1l_lin_slv_sts = U1G_LIN_SLSTS_RCVDATA_WAIT;           /* データ受信待ち状態 */
                            }
                            /*-- [送信フレーム時] --*/
                            else if( xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_sndrcv == U1G_LIN_CMD_SND ){
                                l_vog_lin_frm_tm_stop();                                /* ヘッダタイムアウトタイマの停止 */
                                u2l_lin_chksum = U2G_LIN_WORD_CLR;                      /* チェックサム演算用変数の初期化 */
                                u1l_lin_rs_cnt = U1G_LIN_BYTE_CLR;                      /* データ送信カウンタの初期化 */

                                l_vog_lin_rx_dis();                                     /* 送信時は受信割り込み禁止 */

                                /* NM使用設定フレームの場合 */
                                if( xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_nm_use == U1G_LIN_NM_USE ){
                                    /* LINフレームバッファのNM部分(データ1のbit4-7)をクリア */
                                    /* NM部分のクリア */
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                     &= U1G_LIN_BUF_NM_CLR_MASK;
                                    /* LINフレームに レスポンス送信ステータスをセット */
/* Ver 2.00 変更:直接値->デファイン名に変更 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[0]
                                     |= ( u1g_lin_nm_info & U1G_LIN_NM_INFO_MASK );
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
                                    /* C0005 (I) Precision lostのコンパイルワーニングが出るが情報の損失はおこさないため問題なし */
                                    /* 修正した場合、生成コードが変わってしまうため現状のままとする */
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                     |= ( u1g_lin_nm_info & U1G_LIN_NM_INFO_MASK );
/* Ver 2.00 変更:直接値->デファイン名に変更 */
                                }

                                /* LINバッファのデータを 送信用tmpバッファにコピー */
                                u1l_lin_rs_tmp[ U1G_LIN_0 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                                u1l_lin_rs_tmp[ U1G_LIN_1 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                                u1l_lin_rs_tmp[ U1G_LIN_2 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                                u1l_lin_rs_tmp[ U1G_LIN_3 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                                u1l_lin_rs_tmp[ U1G_LIN_4 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                                u1l_lin_rs_tmp[ U1G_LIN_5 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                                u1l_lin_rs_tmp[ U1G_LIN_6 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ];
                                u1l_lin_rs_tmp[ U1G_LIN_7 ] =
                                 xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ];

                                l_vog_lin_bit_tm_set( U1G_LIN_RSSP );                   /* レスポンススペース待ちタイマセット */

                                u1l_lin_slv_sts = U1G_LIN_SLSTS_SNDDATA_WAIT;           /* データ送信待ち状態 */
                            }
                            /*-- [送信でも受信でもない] --*/
                            else{
                                /* 登録エラー */
                                l_vol_lin_set_synchbreak();                             /* Synch Break受信待ち設定 */
                            }
                        }
                    }
                }
            }
            break;
        /*** データ受信待ち状態 ***/
        case ( U1G_LIN_SLSTS_RCVDATA_WAIT ):
            /* UARTエラー発生 */
            if( (u1a_lin_err & U1G_LIN_UART_ERR_ON) != U1G_LIN_BYTE_CLR ){
                /* SLEEPコマンドIDで、フレーム未定義の場合 */
                if( (xnl_lin_id_sl.u1g_lin_id == U1G_LIN_SLEEP_ID) && (xnl_lin_id_sl.u1g_lin_slot == U1G_LIN_NO_FRAME) ){
                    /* 何もせず Synch Break待ち状態へ */
                    l_vol_lin_set_synchbreak();                                         /* Synch Break受信待ち設定 */
                }
                /* SLEEPコマンドIDではない、もしくはフレーム定義ありの場合 */
                else{
                    /* UARTエラー */
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_e_uart = U2G_LIN_BIT_SET;

                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                       /* エラーありレスポンス完了 */

                    l_vol_lin_set_synchbreak();                                         /* Synch Break受信待ち設定 */
                }
            }
            /* UARTエラーなし */
            else{
                /* データ部の受信割り込み処理 */
                if( u1l_lin_rs_cnt < u1l_lin_frm_sz ){                                  /* DL + 1 */
                    u1l_lin_rs_tmp[ u1l_lin_rs_cnt ] = u1a_lin_data;                    /* データを tmp に格納 */
                    u1l_lin_rs_cnt++;
                    u2l_lin_chksum += (l_u16)u1a_lin_data;
                    u2l_lin_chksum = ( u2l_lin_chksum & U2G_LIN_MASK_FF ) + ( (u2l_lin_chksum >> U2G_LIN_8) & U2G_LIN_MASK_FF );
                }
                /* チェックサム部の受信割り込み処理 */
                else{

                    u2l_lin_chksum = ~u2l_lin_chksum;                                   /* チェックサム反転 */

                    /* チェックサムエラー発生の場合 */
                    if( (l_u8)u2l_lin_chksum != u1a_lin_data ){
                        /* SLEEPコマンドIDで、フレーム未定義の場合 */
                        if( (xnl_lin_id_sl.u1g_lin_id == U1G_LIN_SLEEP_ID) && (xnl_lin_id_sl.u1g_lin_slot == U1G_LIN_NO_FRAME) ){
                            /* 何もせず Synch Break待ち状態へ */
                            l_vol_lin_set_synchbreak();                                 /* Synch Break受信待ち設定 */
                        }
                        /* SLEEPコマンドIDではない、もしくはフレーム定義ありの場合 */
                        else{
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_e_sum = U2G_LIN_BIT_SET;

                            l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );               /* エラーありレスポンス完了 */

                            l_vol_lin_set_synchbreak();                                 /* Synch Break受信待ち設定 */
                        }
                    }
                    /* チェックサムエラーなし */
                    else{
                        /* SLEEPコマンドID(=3Ch)の場合 */
                        if( xnl_lin_id_sl.u1g_lin_id == U1G_LIN_SLEEP_ID ){
                            /* 1バイト目のデータが00hの場合 */
                            if( u1l_lin_rs_tmp[ U1G_LIN_0 ] == U1G_LIN_SLEEP_DATA ){
                                /* SLEEPコマンドとして受信 */
                                l_vog_lin_frm_tm_stop();                                            /* タイマ停止 */
                                xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_SLEEP;    /* SLEEP状態に移行 */
                                l_vol_lin_set_wakeup();                                             /* Wakeup待機設定 */
                            }
                            /* 1バイト目のデータが00h以外の場合 */
                            else{
                                /* フレーム定義ありの場合 */
                                if( xnl_lin_id_sl.u1g_lin_slot != U1G_LIN_NO_FRAME ){
                                    /* 通常フレームとして受信 */
                                    /* LINバッファにデータを格納(フレームサイズ - 1) */
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_0 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_1 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_2 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_3 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_4 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_5 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_6 ];
                                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ] =
                                     u1l_lin_rs_tmp[ U1G_LIN_7 ];

                                    /* LINバッファにチェックサムを格納 */
                                    xng_lin_frm_buf[xnl_lin_id_sl.u1g_lin_slot].un_state.st_bit.u2g_lin_chksum = (l_u16)(u1a_lin_data);

                                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_OFF );                  /* 転送成功 */
                                    l_vol_lin_set_synchbreak();                                     /* Synch Break受信待ち設定 */
                                }
                                /* フレーム未定義の場合 */
                                else{
                                    /* 何もせずに Synch Break受信待ち状態にする */
                                    l_vol_lin_set_synchbreak();                                     /* Synch Break受信待ち設定 */
                                }
                            }
                        }
                        /* SLEEPコマンド以外のID の場合 */
                        else{
                            /* LINバッファにデータを格納(フレームサイズ - 1) */
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_0 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_1 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_2 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_3 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_4 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_5 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_6 ];
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ] =
                             u1l_lin_rs_tmp[ U1G_LIN_7 ];

                            /* LINバッファにチェックサムを格納 */
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_chksum = (l_u16)(u1a_lin_data);

                            l_vol_lin_set_frm_complete( U1G_LIN_ERR_OFF );              /* 転送成功 */

                            l_vol_lin_set_synchbreak();                                 /* Synch Break受信待ち設定 */
                        }
                    }
                }
            }
            break;
        /*** 通常処理される事はない ***/
        default:
            l_vol_lin_set_synchbreak();                                                 /* Synch Break受信待ち設定 */
            break;
        }
    }
    /*** 上記ステータス以外(RESET, その他)の場合 ***/
    else{
        /* 通常は発生しない処理 */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;                                           /* システム異常(LINステータス) */
    }
}


/**************************************************/
/*  タイマ割り込み発生                            */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_tm_int(void)
{
    l_u8  l_u1a_lin_read_back;

    /*** RUN STANDBY状態の場合 ***/
    if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN_STANDBY ){
        /*** Synch Break(UART)待ち状態 ***/
        if( u1l_lin_slv_sts == U1G_LIN_SLSTS_BREAK_UART_WAIT ){
            /* Physical Busエラー */
            xng_lin_sts_buf.un_state.st_bit.u2g_lin_phy_bus_err = U2G_LIN_BIT_SET;
            xng_lin_bus_sts.st_bit.u2g_lin_bus_err = U2G_LIN_BIT_SET;
        }
    }
    /*** RUN状態の場合 ***/
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN ){
        /* スレーブタスクのステータスを確認 */
        switch( u1l_lin_slv_sts ){
        /*** Synch Break(UART)待ち状態 ***/
        case ( U1G_LIN_SLSTS_BREAK_UART_WAIT ):
            /* Physical Busエラー */
            xng_lin_sts_buf.un_state.st_bit.u2g_lin_phy_bus_err = U2G_LIN_BIT_SET;
            xng_lin_bus_sts.st_bit.u2g_lin_bus_err = U2G_LIN_BIT_SET;
            break;
        /*** Synch Break(IRQ)待ち状態 / Synch Field待ち状態 / Ident Field待ち状態 ***/
        case ( U1G_LIN_SLSTS_BREAK_IRQ_WAIT ):
        case ( U1G_LIN_SLSTS_SYNCHFIELD_WAIT ):
        case ( U1G_LIN_SLSTS_IDENTFIELD_WAIT ):
            /* header timeoutエラー */
            xng_lin_bus_sts.st_bit.u2g_lin_head_err = U2G_LIN_BIT_SET;                      /* Headerエラー */
            xng_lin_sts_buf.un_state.st_bit.u2g_lin_e_time = U2G_LIN_BIT_SET;               /* Header Timeout */
            /* Physical Busエラーチェック */
            if(u2l_lin_herr_cnt >= U2G_LIN_HERR_LIMIT){
                /* Physical Busエラー */
                xng_lin_sts_buf.un_state.st_bit.u2g_lin_phy_bus_err = U2G_LIN_BIT_SET;
                xng_lin_bus_sts.st_bit.u2g_lin_bus_err = U2G_LIN_BIT_SET;
                u2l_lin_herr_cnt = U2G_LIN_WORD_CLR;                                        /* Physical Busエラー検出カウンタクリア */
            }else{
                u2l_lin_herr_cnt++;                                                         /* Physical Busエラー検出カウンタ増加 */
            }
            l_vol_lin_set_synchbreak();                                                     /* Synch Break受信待ち設定 */
            break;
        /*** データ受信待ち状態 ***/
        case ( U1G_LIN_SLSTS_RCVDATA_WAIT ):
            /* SLEEPコマンドIDで、フレーム定義なしの場合 */
            if( (xnl_lin_id_sl.u1g_lin_id == U1G_LIN_SLEEP_ID) && (xnl_lin_id_sl.u1g_lin_slot == U1G_LIN_NO_FRAME) ){
                /* 何もせず Synch Break待ち状態へ */
                l_vol_lin_set_synchbreak();                                                 /* Synch Break受信待ち設定 */
            }
            else{
                /* No Responseエラー */
                xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_e_nores = U2G_LIN_BIT_SET;

                l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                               /* エラーありレスポンス完了 */
                l_vol_lin_set_synchbreak();                                                 /* Synch Break受信待ち設定 */
            }
            break;
        /*** データ送信待ち状態 ***/
        case ( U1G_LIN_SLSTS_SNDDATA_WAIT ):
            /* データ送信2バイト目以降 */
            if( u1l_lin_rs_cnt > U1G_LIN_0 ){
                l_u1a_lin_read_back = l_u1g_lin_read_back( u1l_lin_rs_tmp[ u1l_lin_rs_cnt - U1G_LIN_1 ] );
                /* リードバック失敗(受信割り込みがかからない場合、もしくは受信バッファの内容が引数と異なる) */
                if( l_u1a_lin_read_back != U1G_LIN_OK ){
                    /* BITエラー */
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_e_bit = U2G_LIN_BIT_SET;
                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                           /* エラーありレスポンス完了 */
    
                    l_vol_lin_set_synchbreak();                                             /* Synch Break受信待ち設定 */
                }
                /* リードバック成功 */
                else{
                    /* 最後まで送信 */
                    if( u1l_lin_rs_cnt > u1l_lin_frm_sz ){                                  /* DL + 1 */

                        l_vol_lin_set_frm_complete( U1G_LIN_ERR_OFF );                      /* 転送成功 */

                        l_vol_lin_set_synchbreak();                                         /* Synch Break受信待ち設定 */
                    }
                    /* まだ全てのデータを送信完了していない場合 */
                    else{
                        /* データの送信(チェックサムまで送信していない) */
                        if( u1l_lin_rs_cnt < u1l_lin_frm_sz ){
                            u2l_lin_chksum += (l_u16)u1l_lin_rs_tmp[ u1l_lin_rs_cnt ];
                            u2l_lin_chksum = ( u2l_lin_chksum & U2G_LIN_MASK_FF ) + ( (u2l_lin_chksum >> U2G_LIN_8) & U2G_LIN_MASK_FF );
                        }
                        /* チェックサムの送信 */
                        else{
                            /* 送信用tmpバッファにコピー */
/* Ver 2.00 変更:コンパイルワーニング対策 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
                            u1l_lin_rs_tmp[ u1l_lin_frm_sz ] = ~( (l_u8)u2l_lin_chksum );
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
                            u1l_lin_rs_tmp[ u1l_lin_frm_sz ] = (l_u8)(~( (l_u8)u2l_lin_chksum ));
/* Ver 2.00 変更:コンパイルワーニング対策 */
                            /* LINバッファにもコピー */
                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_bit.u2g_lin_chksum
                             = (l_u16)u1l_lin_rs_tmp[ u1l_lin_frm_sz ];
                        }

                        l_vog_lin_tx_char( u1l_lin_rs_tmp[ u1l_lin_rs_cnt ] );              /* データ送信 */
                        l_vog_lin_bit_tm_set( U1G_LIN_BYTE_LENGTH + U1G_LIN_BTSP );         /* データ10bit + Inter-Byte Space */
                        u1l_lin_rs_cnt++;
                    }
                }
            }
            /* データ送信1バイト目 */
            else{
                u2l_lin_chksum += (l_u16)u1l_lin_rs_tmp[ u1l_lin_rs_cnt ];
                u2l_lin_chksum = ( u2l_lin_chksum & U2G_LIN_MASK_FF ) + ( (u2l_lin_chksum >> U2G_LIN_8) & U2G_LIN_MASK_FF );

                l_vog_lin_tx_char( u1l_lin_rs_tmp[ u1l_lin_rs_cnt ] );                      /* データ送信 */
                l_vog_lin_bit_tm_set( U1G_LIN_BYTE_LENGTH + U1G_LIN_BTSP );                 /* データ10bit + Inter-Byte Space */
                u1l_lin_rs_cnt++;
            }
            break;
        /*** 通常処理される事は ない ***/
        default:
            l_vol_lin_set_synchbreak();                                                     /* Synch Break受信待ち設定 */
            break;
        }

    }
/* Ver 2.10 追加（管理番号15）:Wakeupパルス送信後、立下りエッジで検出した時のWakeupパルス送信中断対策 */
    /*** SLEEP状態の場合 ***/
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_SLEEP ){
        /* WAKEUPコマンド送信完了時のWakeup動作 */
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RUN_STANDBY;              /* RUN STANDBY状態へ移行 */
        l_ifc_init_drv_ch1();                                                               /* ドライバ部の初期化 */
    }
/* Ver 2.10 追加（管理番号15）:Wakeupパルス送信後、立下りエッジで検出した時のWakeupパルス送信中断対策 */
    /*** RESET状態の場合(規定外の状態を含む) ***/
    else{
        /* 通常は発生しない処理 */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;                                               /* システム異常(LINステータス) */
    }
}

/**************************************************/
/*  外部INT割り込み発生                           */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_irq_int(void)
{
    /*** SLEEP状態の場合 ***/
    if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_SLEEP ){
        /* RUN STANDBY状態へ移行 */
        xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts = U2G_LIN_STS_RUN_STANDBY;
        l_ifc_init_drv_ch1();                                                   /* ドライバ部の初期化 */
    }
    /*** RUN STANDBY状態の場合 ***/
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN_STANDBY ){
        /*** Synch Break(UART)待ち状態 ***/
        if( u1l_lin_slv_sts == U1G_LIN_SLSTS_BREAK_UART_WAIT ){
            /* このタイミングのIRQ割り込みは無視する */
        }
        /*** Synch Break(UART)待ち状態以外 ***/
        else{
            /* 通常発生しないが、フェール処理を実施 */
            l_vol_lin_set_synchbreak();
        }
    }
    /*** RUN状態の場合 ***/
    else if( xng_lin_sts_buf.un_state.st_bit.u2g_lin_sts == U2G_LIN_STS_RUN ){
        /*** Synch Break(UART)待ち状態 ***/
        if( u1l_lin_slv_sts == U1G_LIN_SLSTS_BREAK_UART_WAIT ){
            /* このタイミングのIRQ割り込みは無視する */
        }
        /*** Synch Break(IRQ)待ち状態 ***/
        else if( u1l_lin_slv_sts == U1G_LIN_SLSTS_BREAK_IRQ_WAIT ){
            u1l_lin_slv_sts = U1G_LIN_SLSTS_SYNCHFIELD_WAIT;                    /* Synch Field待ち状態に移行 */
            l_vog_lin_int_dis();                                                /* INT割り込みを禁止する */
            l_vog_lin_rx_enb();                                                 /* 受信割り込み許可 */
        }
        /*** Synch Break(UART/IRQ)待ち状態以外 ***/
        else{
            /* 通常発生しないが、フェール処理を実施 */
            l_vol_lin_set_synchbreak();
        }
    }
    else{
        /* 何もしない */
    }
}


/**************************************************/
/*  Wakeup検出待ちへの設定処理                    */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
static void  l_vol_lin_set_wakeup(void)
{
  /* WAKEUP検出方法がUARTの場合 */
  #if U1G_LIN_WAKEUP == U1G_LIN_WP_UART_USE
    l_vog_lin_int_dis();                                /* INT割り込みを禁止 */
    l_vog_lin_rx_enb();                                 /* 受信割り込み許可 */
  /* WAKEUP検出方法がINTの場合 */
  #elif U1G_LIN_WAKEUP == U1G_LIN_WP_INT_USE
    l_vog_lin_rx_dis();                                 /* 受信割り込み禁止 */
/* Ver 2.00 変更:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
    l_vog_lin_int_enb();                                /* INT割り込みを許可 */
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
    l_vog_lin_int_enb_wakeup();                         /* INT割り込みを許可 */
/* Ver 2.00 変更:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
  #endif
}


/**************************************************/
/*  Synch Break受信待ち設定処理                   */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
static void  l_vol_lin_set_synchbreak(void)
{
    l_vog_lin_bus_tm_set();                             /* Physical Bus Error検出タイマ起動 */
    l_vog_lin_rx_enb();                                 /* 受信割り込み許可 */
    l_vog_lin_int_enb();                                /* INT割り込みを許可 */
    u1l_lin_slv_sts = U1G_LIN_SLSTS_BREAK_UART_WAIT;    /* Synch Break(UART)待ち状態に移行 */
}


/**************************************************/
/*  完了フラグの設定処理                          */
/*------------------------------------------------*/
/*  引数： err_stat : 完了状態                    */
/*         (0 / 1) : 正常完了 / 異常完了          */
/*  戻値： なし                                   */
/**************************************************/
static void  l_vol_lin_set_frm_complete(l_u8  u1a_lin_err)
{
    /* 転送成功、もしくは転送エラーのフラグが立っている場合(オーバーラン) */
    if( (xng_lin_bus_sts.u2g_lin_word & U2G_LIN_BUS_STS_CMP_SET) != U2G_LIN_WORD_CLR ){
        xng_lin_bus_sts.st_bit.u2g_lin_ovr_run = U2G_LIN_BIT_SET;               /* オーバーラン */
    }
    /* 異常完了の場合 */
    if ( u1a_lin_err == U1G_LIN_ERR_ON ) {
        xng_lin_bus_sts.st_bit.u2g_lin_err_resp = U2G_LIN_BIT_SET;              /* エラー有りレスポンス */
    }
    /* 正常完了の場合 */
    else {
        xng_lin_bus_sts.st_bit.u2g_lin_ok_resp = U2G_LIN_BIT_SET;               /* 正常完了 */
/* Ver 2.00 変更:無効にしたフレームが無効にならない場合がある。 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
        xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.u2g_lin_word = U2G_LIN_BYTE_CLR;   /* エラーフラグのクリア */
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
        xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].un_state.st_err.u2g_lin_err = U2G_LIN_BYTE_CLR;  /* エラーフラグのクリア */
/* Ver 2.00 変更:無効にしたフレームが無効にならない場合がある。 */
    }

    /* 保護IDのセット */
    xng_lin_bus_sts.st_bit.u2g_lin_last_id = (l_u16)u1g_lin_protid_tbl[ xnl_lin_id_sl.u1g_lin_id ];

    /* 送受信処理完了フラグのセット */
    if( xnl_lin_id_sl.u1g_lin_slot < U1G_LIN_16 ){
        xng_lin_sts_buf.un_rs_flg1.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot ];
    }
    else if( xnl_lin_id_sl.u1g_lin_slot < U1G_LIN_32 ){
        xng_lin_sts_buf.un_rs_flg2.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot - U1G_LIN_16 ];
    }
    else if( xnl_lin_id_sl.u1g_lin_slot < U1G_LIN_48 ){
        xng_lin_sts_buf.un_rs_flg3.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot - U1G_LIN_32 ];
    }
    else if( xnl_lin_id_sl.u1g_lin_slot < U1G_LIN_64 ){
        xng_lin_sts_buf.un_rs_flg4.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot - U1G_LIN_48 ];
    }
    else {
        /* 通常発生しないので処理なし */
    }
}


/**************************************************/
/*  NM情報データのセット 処理                     */
/*------------------------------------------------*/
/*  引数： NM情報データ                           */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_set_nm_info( l_u8  u1a_lin_nm_info )
{
    u1g_lin_nm_info = u1a_lin_nm_info;
}


/**************************************************/
/*  テーブルのチェック 処理                       */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_u8  l_u1g_lin_tbl_chk(void)
{
    l_u8  u1a_lin_result;
    l_u8  u1a_lin_lp1;

    u1a_lin_result = U1G_LIN_OK;

    /* ID情報テーブルのチェック */
/* Ver 2.00 変更:直接値->デファイン名に変更 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
    for( u1a_lin_lp1 = 0; u1a_lin_lp1 < U1G_LIN_MAX_SLOT_NUM; u1a_lin_lp1++ ){
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
    for( u1a_lin_lp1 = U1G_LIN_0; u1a_lin_lp1 < U1G_LIN_MAX_SLOT_NUM; u1a_lin_lp1++ ){
/* Ver 2.00 変更:直接値->デファイン名に変更 */
        /* ID情報(0x00 - スロット最大値, FFh) */
        if( U1G_LIN_MAX_SLOT <= u1g_lin_id_tbl[ u1a_lin_lp1 ] ){
            /* フレーム未定義(=FFh)以外の場合 */
            if( u1g_lin_id_tbl[ u1a_lin_lp1 ] != U1G_LIN_NO_FRAME ){
                u1a_lin_result = U1G_LIN_NG;
            }
        }
    }
    /* スロット情報テーブルのチェック */
/* Ver 2.00 変更:直接値->デファイン名に変更 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
    for( u1a_lin_lp1 = 0; u1a_lin_lp1 < U1G_LIN_MAX_SLOT; u1a_lin_lp1++ ){
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
    for( u1a_lin_lp1 = U1G_LIN_0; u1a_lin_lp1 < U1G_LIN_MAX_SLOT; u1a_lin_lp1++ ){
/* Ver 2.00 変更:直接値->デファイン名に変更 */
        /* フレームサイズ(1 - 8) */
        if( (xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_frm_sz < U1G_LIN_DL_1)
         || (U1G_LIN_DL_8 < xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_frm_sz) ){
            u1a_lin_result = U1G_LIN_NG;
        }
    }

    return( u1a_lin_result );
}

/***** End of File *****/


/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_core_h83687.h                       */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         : H8/3687                                    */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_CORE_H83687_H_INCLUDE__
#define __L_SLIN_CORE_H83687_H_INCLUDE__


/*** 定数定義 ***/
#define  U1G_LIN_SYNCH_BREAK_DATA       ((l_u8)0x00)    /* SYNCH BREAKのデータ = 00h */
#define  U1G_LIN_SYNCH_FIELD_DATA       ((l_u8)0x55)    /* SYNCH FIELDのデータ = 55h */

#if U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_2400
 #define  U1G_LIN_SND_WAKEUP_DATA       ((l_u8)0xFF)    /* WAKEUPデータ = FFh */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_9600
/* Ver 2.00 変更:ウェイクアップ信号の標準値を"0x80"に変更 */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
 #define  U1G_LIN_SND_WAKEUP_DATA       ((l_u8)0xF8)    /* WAKEUPデータ = F8h */
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
 #define  U1G_LIN_SND_WAKEUP_DATA       ((l_u8)0x80)    /* WAKEUPデータ = 80h */
/* Ver 2.00 変更:ウェイクアップ信号の標準値を"0x80"に変更 */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_19200
 #define  U1G_LIN_SND_WAKEUP_DATA       ((l_u8)0x80)    /* WAKEUPデータ = 80h */
#endif

#define  U1G_LIN_SLEEP_ID               ((l_u8)0x3C)    /* SLEEPコマンドID = 3Ch  */
#define  U1G_LIN_SLEEP_DATA             ((l_u8)0x00)    /* SLEEPコマンドのData0 = 0x00 */

#define  U1G_LIN_HEADER_MAX_TIME        ((l_u8)49)      /* ヘッダータイムアウトMAX値 */
#define  U1G_LIN_BYTE_LENGTH            ((l_u8)10)      /* 1バイト長(10bit) */

#define  U2G_LIN_STSBUF_CLR             ((l_u16)0xFF00) /* リード用ステータスバッファのクリア値 */
#define  U1G_LIN_UART_ERR_ON            ((l_u8)0x0F)    /* 受信バッファレジスタの上位(エラー)ビットON */

#define  U1G_LIN_FRAMING_ERR_ON         ((l_u8)0x02)    /* 受信バッファレジスタのフレーミングエラービットON */
#define  U1G_LIN_FRAMING_ERR            ((l_u8)0x0A)    /* フレーミングエラーチェック */
#define  U1G_LIN_OVERRUN_ERR            ((l_u8)0x09)    /* オーバーランエラーチェック */
#define  U1G_LIN_ID_PARITY_MASK         ((l_u8)0x3F)    /* 保護IDパリティビットマスク(3Fh) */

#define  U2G_LIN_BUS_STS_CMP_SET        ((l_u16)0x0003) /* 転送完了かエラー応答完了がセットされている */

#define  U1G_LIN_BUF_NM_CLR_MASK        ((l_u8)0x0F)    /* LINフレームバッファのNM部分(Data1 bit4-7)クリアマスク */
#define  U1G_LIN_NM_INFO_MASK           ((l_u8)0xF0)    /* NM情報テーブルのreserve部 クリア用マスク */

#define  U1G_LIN_SLSTS_BREAK_UART_WAIT  ((l_u8)0)       /* スレーブタスクのステータス = Synch Break(UART)待ち */
#define  U1G_LIN_SLSTS_BREAK_IRQ_WAIT   ((l_u8)1)       /* スレーブタスクのステータス = Synch Break(IRQ)待ち */
#define  U1G_LIN_SLSTS_SYNCHFIELD_WAIT  ((l_u8)2)       /* スレーブタスクのステータス = Synch Field待ち */
#define  U1G_LIN_SLSTS_IDENTFIELD_WAIT  ((l_u8)3)       /* スレーブタスクのステータス = Ident Field待ち */
#define  U1G_LIN_SLSTS_RCVDATA_WAIT     ((l_u8)4)       /* スレーブタスクのステータス = データ受信待ち */
#define  U1G_LIN_SLSTS_SNDDATA_WAIT     ((l_u8)5)       /* スレーブタスクのステータス = データ送信待ち */

#define  U1G_LIN_ERR_OFF                ((l_u8)0)       /* 正常に転送完了 */
#define  U1G_LIN_ERR_ON                 ((l_u8)1)       /* エラーありレスポンス完了 */

#define  U2G_LIN_HERR_LIMIT          ((l_u16)510)       /* 25000bitタイム分のヘッダタイム回数(25000 / 49) */

/*** テーブル構造定義 ***/
/* 現在処理しているフレームのIDとスロット番号を管理 */
typedef struct {
    l_u8  u1g_lin_id;                       /* ID (00h-3Fh) */
    l_u8  u1g_lin_slot;                     /* SLOT No. (1-64) */
} st_lin_id_slot_type;


/*** 関数のプロトタイプ宣言(extern) ***/
extern void   l_vog_lin_bit_tm_set(l_u8 u1a_lin_bit);
extern void   l_vog_lin_rcv_tm_set(l_u8 u1a_lin_bit);
extern void   l_vog_lin_bus_tm_set(void);
extern void   l_vog_lin_tx_char(l_u8 u1a_lin_data);
/* Ver 1.01 変更:トヨタコーディングルール対応 -> start */
/* extern l_bool l_u1g_lin_read_back(l_u8 u1a_lin_data); */
extern l_u8   l_u1g_lin_read_back(l_u8 u1a_lin_data);
/* Ver 1.01 変更:トヨタコーディングルール対応 <- end */
extern void   l_vog_lin_frm_tm_stop(void);
extern void   l_vog_lin_rx_enb(void);
extern void   l_vog_lin_rx_dis(void);
extern void   l_vog_lin_uart_init(void);
extern void   l_vog_lin_timer_init(void);
extern void   l_vog_lin_int_init(void);
extern void   l_vog_lin_int_enb(void);
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
extern void  l_vog_lin_int_enb_wakeup(void);
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
extern void   l_vog_lin_int_dis(void);

/*** アセンブリ関数のプロトタイプ宣言(extern) ***/
extern l_u8   l_u1g_lin_irq_dis(void);
extern void   l_vog_lin_irq_res(l_u8 u1a_lin_flg);

#endif

/***** End of File *****/



/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_def.h                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*           ･U1G_LIN_EDGE_INTを追加                        */
/*           ･ライブラリリリース用のデフォルト設定に変更    */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_DEF_H_INCLUDE__
#define __L_SLIN_DEF_H_INCLUDE__

#define  U2G_LIN_NAD                    ((l_u16)0x01)
#define  U1G_LIN_MAX_SLOT               ((l_u8)11)
#define  U1G_LIN_UART                   (U1G_LIN_SCI2)
#define  U1G_LIN_BAUDRATE               (U1G_LIN_BAUDRATE_9600)
#define  U1G_LIN_BRGSRC                 (U1G_LIN_BRGSRC_F1)
#define  U1G_LIN_BRG                    ((l_u8)39)                /* 12MHz,9600bps +1した値を定義 */
#define  U1G_LIN_TM                     (U1G_LIN_TIMERZ0)
#define  U1G_LIN_RSSP                   ((l_u8)1)
#define  U1G_LIN_BTSP                   ((l_u8)1)
#define  U1G_LIN_WAKEUP                 (U1G_LIN_WP_INT_USE)
#define  U1G_LIN_WP_INT                 (U1G_LIN_WP_INT0)
#define  U1G_LIN_EDGE_INT               (U1G_LIN_EDGE_INT_NON)
#define  U1G_LIN_ENDIAN_TYPE            (U1G_LIN_ENDIAN_BIG)

#endif

/***** End of File *****/




/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_drv_h83687.c                        */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         : H8/3687                                    */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#pragma	section	lin

/*=== MCU依存部分 ===*/
/***** ヘッダ インクルード *****/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_sfr_h83687.h"
#include "l_slin_drv_h83687.h"

/***** 関数プロトタイプ宣言 *****/
/*-- API関数(extern) --*/
void  l_ifc_rx_ch1(void);
void  l_ifc_tm_ch1(void);
void  l_ifc_aux_ch1(void);

/*-- その他 MCU依存関数(extern) --*/
void   l_vog_lin_uart_init(void);
void   l_vog_lin_timer_init(void);
void   l_vog_lin_int_init(void);
void   l_vog_lin_rx_enb(void);
void   l_vog_lin_rx_dis(void);
void   l_vog_lin_int_enb(void);
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
void  l_vog_lin_int_enb_wakeup(void);
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
void   l_vog_lin_int_dis(void);
void   l_vog_lin_tx_char(l_u8 u1a_lin_data);
l_u8   l_u1g_lin_read_back(l_u8 u1a_lin_data);
void   l_vog_lin_bit_tm_set(l_u8 u1a_lin_bit);
void   l_vog_lin_rcv_tm_set(l_u8 u1a_lin_bit);
void   l_vog_lin_bus_tm_set(void);
void   l_vog_lin_frm_tm_stop(void);
l_u8   l_u1g_lin_para_chk(void);

/*** 変数(static) ***/
static l_u16  u2l_lin_tm_bit;           /* 1bitタイム値 */
static l_u16  u2l_lin_tm_maxbit;        /* 0xFFFFカウント分のビット長 */
static l_u16  u2l_lin_tm_cnt;           /* タイマカウンタ */

/**************************************************/

/********************************/
/* MCU依存のAPI関数処理         */
/********************************/
/**************************************************/
/*  UARTレジスタの初期化 処理                     */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_uart_init(void)
{
    l_u8    u1a_lin_flg;
    l_u8    u1a_lin_errflg;
    l_u8    u1a_lin_rdata;

    /*** SCIの初期化 ***/
    u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

    U1G_LIN_REG_SCR3.u1l_lin_byte = U1G_LIN_SCR3_INIT;      /* シリアルコントロールレジスタ3の設定 */
                                                            /* シリアルモードレジスタの設定 */
  #if U1G_LIN_BRGSRC == U1G_LIN_BRGSRC_F1
    U1G_LIN_REG_SMR.u1l_lin_byte = U1G_LIN_SMR_INIT | ( U1G_LIN_SMR_MASK & U1G_LIN_0 );
  #elif U1G_LIN_BRGSRC == U1G_LIN_BRGSRC_F4
    U1G_LIN_REG_SMR.u1l_lin_byte = U1G_LIN_SMR_INIT | ( U1G_LIN_SMR_MASK & U1G_LIN_1 );
  #endif

    U1G_LIN_REG_BRR.u1l_lin_byte = U1G_LIN_BRG - U1G_LIN_1; /* ビットレートの設定 */
    U1G_LIN_FLG_PMTXD = U1G_LIN_BIT_SET;                    /* ポートモード:TXD端子出力機能の選択 */
    if( U1G_LIN_FLG_SRF == U1G_LIN_BIT_SET ) {              /* 受信データ空読み */
        u1a_lin_rdata = U1G_LIN_REG_RDR.u1l_lin_byte;
    }
    u1a_lin_errflg = U1G_LIN_FLG_SOER;                      /* オーバーランエラーのクリア */
    U1G_LIN_FLG_SOER = U1G_LIN_BIT_CLR;
    u1a_lin_errflg = U1G_LIN_FLG_SFER;                      /* フレーミングエラーのクリア */
    U1G_LIN_FLG_SFER = U1G_LIN_BIT_CLR;
    u1a_lin_errflg = U1G_LIN_FLG_SPER;                      /* パリティーエラーのクリア */
    U1G_LIN_FLG_SPER = U1G_LIN_BIT_CLR;
    U1G_LIN_FLG_SREN = U1G_LIN_BIT_SET;                     /* 受信イネーブル */
    U1G_LIN_FLG_STEN = U1G_LIN_BIT_SET;                     /* 送信イネーブル */

    l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定を復元 */

}


/**************************************************/
/*  Timerレジスタの初期化 処理                    */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_timer_init(void)
{
    l_u8    u1a_lin_flg;
    l_u8    u1a_tmp_rdata;

    /*** 1Bitタイマ値のセット ***/
  #if U1G_LIN_BRGSRC == U1G_LIN_BRGSRC_F1
    u2l_lin_tm_bit = ( (l_u16)U1G_LIN_BRG * U2G_LIN_FRM_TM_SRC_1 ) * U2G_LIN_4;
  #elif U1G_LIN_BRGSRC == U1G_LIN_BRGSRC_F4
    u2l_lin_tm_bit = ( (l_u16)U1G_LIN_BRG * U2G_LIN_FRM_TM_SRC_4 ) * U2G_LIN_4;
  #endif

    /* 0xFFFFHカウント分のビット長のセット */
    /* ０除算のチェック */
    if(u2l_lin_tm_bit != U2G_LIN_BYTE_CLR){
        u2l_lin_tm_maxbit = U2G_LIN_WORD_LIMIT / u2l_lin_tm_bit;
    }else{
        /* 通常ありえない処理 */
        u2l_lin_tm_maxbit = U2G_LIN_1;
        u1g_lin_syserr = U1G_LIN_SYSERR_DIV;                /* 0除算発生 */
    }

    /*** Timerの初期化 ***/
    u1a_lin_flg = l_u1g_lin_irq_dis();                      /* 割り込み禁止設定 */

    U1G_LIN_FLG_TMST = U2G_LIN_BIT_CLR;                     /* タイマ停止 */
    U1G_LIN_REG_TCR.u1l_lin_byte = U1G_LIN_FRM_TCR_INIT;    /* タイマコントロールレジスタの設定 */
                                                            /* GRAのコンペアマッチ */
                                                            /* 内部クロックのφ/8でカウント */
    U1G_LIN_REG_TIORA.u1l_lin_byte = U1G_LIN_FRM_TIORA_INIT;/* タイマI/Oコントロールレジスタの設定 */

    u1a_tmp_rdata = U1G_LIN_REG_TSR.u1l_lin_byte;           /* クリアのためのダミー読み込み */
    U1G_LIN_REG_TSR.u1l_lin_byte = U2G_LIN_BYTE_CLR;        /* タイマステータスレジスタのクリア */
    U1G_LIN_REG_TIER.u1l_lin_byte = U1G_LIN_FRM_TIER_INIT;  /* タイマインタラプトイネーブルレジスタの設定 */

    l_vog_lin_irq_res( u1a_lin_flg );                       /* 割り込み設定を復元 */

}


/**************************************************/
/*  外部INTレジスタの初期化 処理                  */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_init(void)
{
    l_u8    u1a_lin_flg;

    /*** INTの初期化 ***/
    u1a_lin_flg = l_u1g_lin_irq_dis();              /* 割り込み禁止設定 */

    U1G_LIN_FLG_INTIC = U1G_LIN_BIT_CLR;            /* 割り込み要求ディセーブル */
    U1G_LIN_FLG_INTEG = U1G_LIN_BIT_SET;            /* 立上りエッジ検出を選択 */
    U1G_LIN_FLG_PMIRQ = U1G_LIN_BIT_SET;            /* ポートモード:IRQ入力端子の選択 */
    l_vog_lin_nop();
    l_vog_lin_nop();
    l_vog_lin_nop();
    U1G_LIN_FLG_INTIR = U1G_LIN_BIT_CLR;            /* 割り込み要求フラグクリア */

    l_vog_lin_irq_res( u1a_lin_flg );               /* 割り込み設定を復元 */

}


/**************************************************/
/*  データの一文字受信処理(API)                   */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
/*  UART受信割り込みの際に呼び出されるAPI         */
/**************************************************/
void  l_ifc_rx_ch1(void)
{
    l_u8    u1a_lin_rx_status;
    l_u8    u1a_lin_rx_data;
    l_u8    u1a_lin_rx_err;

    /* 受信データ取得 */
    u1a_lin_rx_data = U1G_LIN_REG_RDR.u1l_lin_byte;

    /* 受信ステータス取得 */
    u1a_lin_rx_status = U1G_LIN_REG_SSR.u1l_lin_byte;

    /* 受信エラー情報の生成 */
    u1a_lin_rx_err = U1G_LIN_BYTE_CLR;
    if( (u1a_lin_rx_status & U1G_LIN_SOER_MASK) != 0 ) {
        u1a_lin_rx_err |= U1G_LIN_SOER_SET;                 /* オーバランエラー発生 */
    }
    if( (u1a_lin_rx_status & U1G_LIN_SFER_MASK) != 0 ) {
        u1a_lin_rx_err |= U1G_LIN_SFER_SET;                 /* フレーミングエラー発生 */
    }
    if( (u1a_lin_rx_status & U1G_LIN_SPER_MASK) != 0 ) {
        u1a_lin_rx_err |= U1G_LIN_SPER_SET;                 /* パリティエラー発生 */
    }

    l_vog_lin_rx_int( u1a_lin_rx_data, u1a_lin_rx_err );     /* スレーブタスクに受信報告 */

}


/**************************************************/
/*  フレームタイマ制御処理(API)                   */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
/*  タイマ割り込みの際に呼び出されるAPI           */
/**************************************************/
void  l_ifc_tm_ch1(void)
{
    l_u8    u1a_lin_rdata;

    /* タイマステータスレジスタのクリア */
    u1a_lin_rdata = U1G_LIN_REG_TSR.u1l_lin_byte;   /* ダミーリード */
    U1G_LIN_REG_TSR.u1l_lin_byte = U1G_LIN_BYTE_CLR;

    /* タイマカウントが"0"以上の場合 */
    if( u2l_lin_tm_cnt > U2G_LIN_WORD_CLR ){
        u2l_lin_tm_cnt--;                                           /* デクリメントして抜ける */
    }
    /* タイマカウントが"0"の場合 */
    else{
        U1G_LIN_FLG_TMST = U1G_LIN_BIT_CLR;                       /* タイマ停止 */

        l_vog_lin_tm_int();                                         /* タイマ割り込み報告 */
    }
}


/**************************************************/
/*  外部INT割り込み制御処理(API)                  */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
/*  外部INT割り込みの際に呼び出されるAPI          */
/**************************************************/
void  l_ifc_aux_ch1(void)
{
    U1G_LIN_FLG_INTIR = U1G_LIN_BIT_CLR;        /* IRQ割り込み要求フラグクリア */
    l_vog_lin_irq_int();                        /* 外部INT割り込み報告 */
}


/***********************************/
/* MCU固有のSFR設定用関数処理      */
/***********************************/
/**************************************************/
/*  UART受信割り込み許可 処理                     */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_rx_enb(void)
{
    l_u8    u1a_lin_flg;
    l_u8    u1a_lin_errflg;
    l_u8    u1a_lin_rdata;

    u1a_lin_flg = l_u1g_lin_irq_dis();                  /* 割り込み禁止設定 */

    U1G_LIN_FLG_SREN = U1G_LIN_BIT_CLR;                 /* 受信ディセーブル */

    if( U1G_LIN_FLG_SRF == U1G_LIN_BIT_SET ) {          /* 受信データ空読み */
        u1a_lin_rdata = U1G_LIN_REG_RDR.u1l_lin_byte;
    }

    u1a_lin_errflg = U1G_LIN_FLG_SOER;                  /* オーバーランエラーのクリア */
    U1G_LIN_FLG_SOER = U1G_LIN_BIT_CLR;
    u1a_lin_errflg = U1G_LIN_FLG_SFER;                  /* フレーミングエラーのクリア */
    U1G_LIN_FLG_SFER = U1G_LIN_BIT_CLR;
    u1a_lin_errflg = U1G_LIN_FLG_SPER;                  /* パリティーエラーのクリア */
    U1G_LIN_FLG_SPER = U1G_LIN_BIT_CLR;

    U1G_LIN_FLG_SREN = U1G_LIN_BIT_SET;                 /* 受信イネーブル */
    U1G_LIN_FLG_SRIC = U1G_LIN_BIT_SET;                 /* 割り込み要求イネーブル */

    l_vog_lin_irq_res( u1a_lin_flg );                   /* 割り込み設定復元 */
}


/**************************************************/
/*  UART受信割り込み禁止 処理                     */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_rx_dis(void)
{
    l_u8    u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                  /* 割り込み禁止設定 */

    U1G_LIN_FLG_SRIC = U1G_LIN_BIT_CLR;                 /* 割り込み要求ディセーブル */

    l_vog_lin_irq_res( u1a_lin_flg );                   /* 割り込み設定復元 */
}


/**************************************************/
/*  INT割り込み許可 処理                          */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_enb(void)
{
    l_u8    u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                  /* 割り込み禁止設定 */

    U1G_LIN_FLG_INTIC = U1G_LIN_BIT_SET;                /* 割り込み要求イネーブル */
    U1G_LIN_FLG_INTIR = U1G_LIN_BIT_CLR;                /* 割り込み要求フラグクリア */

    l_vog_lin_irq_res( u1a_lin_flg );                   /* 割り込み設定復元 */
}


/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
/**************************************************/
/*  INT割り込み許可(Wakeupパルス検出用) 処理      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_enb_wakeup(void)
{
    l_u8    u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                  /* 割り込み禁止設定 */

    U1G_LIN_FLG_INTEG = U1G_LIN_INTEG_WPINI;            /* エッジ検出方向を設定 */
    U1G_LIN_FLG_INTIC = U1G_LIN_BIT_SET;                /* 割り込み要求イネーブル */
    U1G_LIN_FLG_INTIR = U1G_LIN_BIT_CLR;                /* 割り込み要求フラグクリア */

    l_vog_lin_irq_res( u1a_lin_flg );                   /* 割り込み設定復元 */
}
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */


/**************************************************/
/*  INT割り込み禁止 処理                          */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_dis(void)
{
    l_u8    u1a_lin_flg;

    u1a_lin_flg = l_u1g_lin_irq_dis();                  /* 割り込み禁止設定 */

    U1G_LIN_FLG_INTIC = U1G_LIN_BIT_CLR;                /* 割り込み要求ディセーブル */

    l_vog_lin_irq_res( u1a_lin_flg );                   /* 割り込み設定復元 */
}


/**************************************************/
/*  送信レジスタにデータをセットする 処理         */
/*------------------------------------------------*/
/*  引数： 送信データ                             */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_tx_char(l_u8 u1a_lin_data)
{
    /* 送信バッファレジスタに (1byte)データを入れる */
    U1G_LIN_REG_TDR.u1l_lin_byte = u1a_lin_data;
}


/**************************************************/
/*  リードバック 処理                             */
/*------------------------------------------------*/
/*  引数： リードバック比較用データ               */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 読込み成功 / 読込み失敗      */
/**************************************************/
l_u8 l_u1g_lin_read_back(l_u8 u1a_lin_data)
{
    l_u8    u1a_lin_readback_data;
    l_u8    u1a_lin_result;

    /* 受信データの有無をチェック */
    if( U1G_LIN_FLG_SRF == U1G_LIN_BIT_SET ) {
        /* エラーが発生しているかをチェック */
        if(    (U1G_LIN_FLG_SOER == U1G_LIN_BIT_SET)
            || (U1G_LIN_FLG_SFER == U1G_LIN_BIT_SET)
            || (U1G_LIN_FLG_SPER == U1G_LIN_BIT_SET) ) {
            u1a_lin_result = U1G_LIN_NG;
        }
        else {
            u1a_lin_readback_data = U1G_LIN_REG_RDR.u1l_lin_byte; /* 受信データ取得 */
            /* 受信バッファの内容と引数を比較 */
            if( u1a_lin_readback_data != u1a_lin_data ){
                u1a_lin_result = U1G_LIN_NG;
            }
            else{
                u1a_lin_result = U1G_LIN_OK;
            }
        }
    }
    else {
        u1a_lin_result = U1G_LIN_NG;
    }

    return( u1a_lin_result );
}


/**************************************************/
/*  Bitタイマの設定 処理                          */
/*------------------------------------------------*/
/*  引数： bit:タイマ設定値(bit長)                */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_bit_tm_set(l_u8 u1a_lin_bit)
{
    l_u16   u2a_lin_tmp_bit;

    l_vog_lin_frm_tm_stop();                                /* タイマ停止 */

    u2a_lin_tmp_bit = (l_u16)u1a_lin_bit;

    /* タイマ値がFFFFhを超える場合の計算 */
    if( u2a_lin_tmp_bit > u2l_lin_tm_maxbit ){
        u2l_lin_tm_cnt = u2a_lin_tmp_bit / u2l_lin_tm_maxbit;
        u2a_lin_tmp_bit /= (u2l_lin_tm_cnt + U2G_LIN_1);
    }
    else{
        u2l_lin_tm_cnt = U2G_LIN_BYTE_CLR;
    } 

    /* タイマカウンタ、GRAの設定 */
    U2G_LIN_REG_TCNT.u2l_lin_word = U2G_LIN_WORD_CLR;
    U2G_LIN_REG_GRA.u2l_lin_word = u2a_lin_tmp_bit * u2l_lin_tm_bit;

    /* タイマカウント動作開始 */
    U1G_LIN_FLG_TMST = U1G_LIN_BIT_SET;
}


/**************************************************/
/*  応答タイムアウトタイマセット 処理             */
/*------------------------------------------------*/
/*  引数： bit: レスポンス長(データ+チェックサム) */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_rcv_tm_set(l_u8 u1a_lin_bit)
{
    l_u16   u2a_lin_tmp_bit;
    l_u16   u2a_lin_rest_time;

    /* タイマカウントを停止します */
    U1G_LIN_FLG_TMST = U1G_LIN_BIT_CLR;

    /* (Data Length + Checksum) × 1.4 */
    u2a_lin_tmp_bit = ( ((l_u16)u1a_lin_bit * U2G_LIN_14) / U2G_LIN_10 );

    /* 割り込み要求ビットチェック */
    if( U1G_LIN_FLG_TMIR != U1G_LIN_BIT_CLR ){
        /* 残時間なし */
        u2a_lin_rest_time = U2G_LIN_WORD_CLR;
    }else{
        /* タイマ値の算出 */
        u2a_lin_rest_time = U2G_LIN_REG_GRA.u2l_lin_word - U2G_LIN_REG_TCNT.u2l_lin_word;
    }

    /* 割り込み要求ビットクリア */
    U1G_LIN_FLG_TMIR = U1G_LIN_BIT_CLR;

    /* タイマ値をビット長に置き換える */
    /* ０除算のチェック */
    if(u2l_lin_tm_bit != U2G_LIN_BYTE_CLR){
        u2a_lin_tmp_bit = (u2a_lin_rest_time / u2l_lin_tm_bit) + u2a_lin_tmp_bit;
    }
    else{
        /* 通常ありえない処理 */
        u2a_lin_tmp_bit = U2G_LIN_BYTE_CLR;
        u1g_lin_syserr = U1G_LIN_SYSERR_DIV;                /* 0除算発生 */
    } 

    /* タイマ値がFFFFhを超える場合の計算 */
    if( u2a_lin_tmp_bit > u2l_lin_tm_maxbit ){
        u2l_lin_tm_cnt = u2a_lin_tmp_bit / u2l_lin_tm_maxbit;
        u2a_lin_tmp_bit /= (u2l_lin_tm_cnt + U2G_LIN_1);
    }
    else{
        u2l_lin_tm_cnt = U2G_LIN_BYTE_CLR;
    } 

    /* タイマカウンタ、GRAの設定 */
    U2G_LIN_REG_TCNT.u2l_lin_word = U2G_LIN_WORD_CLR;
    U2G_LIN_REG_GRA.u2l_lin_word = u2a_lin_tmp_bit * u2l_lin_tm_bit;

    /* タイマカウント動作開始 */
    U1G_LIN_FLG_TMST = U1G_LIN_BIT_SET;


}


/**************************************************/
/*  Physical Busエラータイマの設定 処理           */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_bus_tm_set(void)
{
    l_u16   u2a_lin_tmp_bit;

    l_vog_lin_frm_tm_stop();                                /* タイマ停止 */

    u2a_lin_tmp_bit = U2G_LIN_BUS_TIMEOUT;

    /* タイマ値がFFFFhを超える場合の計算 */
    if( u2a_lin_tmp_bit > u2l_lin_tm_maxbit ){
        u2l_lin_tm_cnt = u2a_lin_tmp_bit / u2l_lin_tm_maxbit;
        u2a_lin_tmp_bit /= (u2l_lin_tm_cnt + U2G_LIN_1);
    }
    else{
        u2l_lin_tm_cnt = U2G_LIN_BYTE_CLR;
    } 

    /* タイマカウンタ、GRAの設定 */
    U2G_LIN_REG_TCNT.u2l_lin_word = U2G_LIN_WORD_CLR;
    U2G_LIN_REG_GRA.u2l_lin_word = u2a_lin_tmp_bit * u2l_lin_tm_bit;

    /* タイマカウント動作開始 */
    U1G_LIN_FLG_TMST = U1G_LIN_BIT_SET;
}


/**************************************************/
/*  タイマ停止 処理                               */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_frm_tm_stop(void)
{
    /* タイマカウントを停止します */
    U1G_LIN_FLG_TMST = U1G_LIN_BIT_CLR;

    /* 割り込み要求ビットをOFFします */
    U1G_LIN_FLG_TMIR = U1G_LIN_BIT_CLR;
}


/**************************************************/
/*  パラメータチェック 処理                       */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
/* 本関数内の条件判定文(５箇所)はすべて"C0004 (I) Constant as condition"のコンパイルワーニングとなる */
/* コンパイル時にユーザーが指定する定数値を式で評価しているため上記のワーニングが出る。問題なしとする。 */
l_u8  l_u1g_lin_para_chk(void)
{
    l_u8 u1a_lin_result;

    u1a_lin_result = U1G_LIN_OK;

    /* ノードアドレスのチェック(0x01 - 0xFF) */
    if( (U2G_LIN_NAD < U2G_LIN_NAD_MIN) || ( U2G_LIN_NAD_MAX < U2G_LIN_NAD) ){
        u1a_lin_result = U1G_LIN_NG;
    }
    /* 最大LINバッファスロット数(1 - 64) */
    if( (U1G_LIN_MAX_SLOT < U1G_LIN_MAX_SLOT_MIN) || (U1G_LIN_MAX_SLOT_MAX < U1G_LIN_MAX_SLOT) ){
        u1a_lin_result = U1G_LIN_NG;
    }
    /* BRGレジスタ値のチェック(0x01 - 0xFF) */
    if( (U1G_LIN_BRG < U1G_LIN_BRG_MIN) || (U1G_LIN_BRG_MAX < U1G_LIN_BRG) ){
        u1a_lin_result = U1G_LIN_NG;
    }
    /* In-Frame Responce Spaceのチェック(0 - 10) */
    if( (U1G_LIN_RSSP < U1G_LIN_RSSP_MIN) || (U1G_LIN_RSSP_MAX < U1G_LIN_RSSP) ){
        u1a_lin_result = U1G_LIN_NG;
    }
    /* Inter-Byte Spaceのチェック(1 - 4) */
    if( (U1G_LIN_BTSP < U1G_LIN_BTSP_MIN) || (U1G_LIN_BTSP_MAX < U1G_LIN_BTSP) ){
        u1a_lin_result = U1G_LIN_NG;
    }
    return( u1a_lin_result );
}

/***** End of File *****/



/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_drv_h83687.h                        */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         : H8/3687                                    */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_DRV_H83687_H_INCLUDE__
#define __L_SLIN_DRV_H83687_H_INCLUDE__


/*** MCU依存部分の定数定義 ***/

/** <UARTレジスタの設定値> **/
/* UxMRレジスタ */
#define  U1G_LIN_UMR_INIT           ((l_u8)0x05)        /* 8bit長 パリティ禁止 */
/* UxC0レジスタ */
#define  U1G_LIN_UC0_INIT           ((l_u8)0x10)        /* UxC0の初期値 */
/* UxC1レジスタ */
#define  U1G_LIN_UC1_TE_SET         ((l_u8)0x01)        /* 送信許可ビットセット */
#define  U1G_LIN_UC1_RE_SET         ((l_u8)0x04)        /* 受信許可ビットセット */
#define  U1G_LIN_UC1_RE_CLR_MASK    ((l_u8)0xFB)        /* 受信許可ビットクリア用マスク */

/** <SCI3レジスタの設定値> **/
/* SCR3 */
#define  U1G_LIN_SCR3_INIT          ((l_u8)0x00)        /* SCR3の初期値 */
/* SMR */
#define  U1G_LIN_SMR_INIT           ((l_u8)0x00)        /* bit長 8,パリティなし,stop bit長 1 */
#define  U1G_LIN_SMR_MASK           ((l_u8)0x03)        /* 分周値マスク */


/** <Timerレジスタの設定値> **/
#define  U1G_LIN_FRM_TCR_INIT       ((l_u8)0x23)        /* TCRの初期値 */
#define  U1G_LIN_FRM_TIORA_INIT     ((l_u8)0x00)        /* TIORAの初期値 */
#define  U1G_LIN_FRM_TIER_INIT      ((l_u8)0x01)        /* TIERの初期値 */

/* タイマレジスタ設定値計算用 */
#define  U2G_LIN_FRM_TM_SRC_1       ((l_u16)1)          /* 文周なし */
#define  U2G_LIN_FRM_TM_SRC_4       ((l_u16)4)          /* 4分周 */

/* Physical Busエラー検出タイマ 設定値計算用 */
#define  U2G_LIN_BUS_TIMEOUT        ((l_u16)25000)      /* 25000bit */

/** <外部INTレジスタ> **/
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */
#if U1G_LIN_EDGE_INT == U1G_LIN_EDGE_INT_UP
 #define U1G_LIN_INTEG_WPINI        ((l_u8)0x01)       /* INT割り込み極性 立ち上がりエッジ */
#elif U1G_LIN_EDGE_INT == U1G_LIN_EDGE_INT_DOWN
 #define U1G_LIN_INTEG_WPINI        ((l_u8)0x00)       /* INT割り込み極性 立ち下がりエッジ */
#elif U1G_LIN_EDGE_INT == U1G_LIN_EDGE_INT_NON
 #define U1G_LIN_INTEG_WPINI        ((l_u8)0x00)       /* INT割り込み極性 エッジ検出なし(立ち下がりエッジ) */
#endif
/* Ver 2.00 追加:ウェイクアップ信号検出エッジの極性切り替えへの対応 */

/* Ver 2.00 削除:未使用の定義のため */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
#define  U1G_LIN_IC_POL_SET         ((l_u8)0x10)       /* INT割り込み極性 立ち上がりエッジ */
#define  U1G_LIN_IC_LEVEL_MASK      ((l_u8)0xF8)
#define  U1G_LIN_IC_IR_SET          ((l_u8)0x08)
#define  U1G_LIN_IC_IR_CLR_MASK     ((l_u8)0xF7)
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
/* Ver 2.00 削除:未使用の定義のため */

#define  U2G_LIN_WORD_LIMIT         ((l_u16)0xFFFF)

/* Iフラグセット */
#define  U2G_LIN_I_FLAG_SET         ((l_u16)0x0040)

/* パラメータチェック範囲 */
#define  U2G_LIN_NAD_MIN            ((l_u16)0x01)
#define  U2G_LIN_NAD_MAX            ((l_u16)0xFF)
#define  U1G_LIN_MAX_SLOT_MIN       ((l_u8)1)
#define  U1G_LIN_MAX_SLOT_MAX       ((l_u8)64)
#define  U1G_LIN_BRG_MIN            ((l_u8)0x01)
#define  U1G_LIN_BRG_MAX            ((l_u8)0xFF)
#define  U1G_LIN_RSSP_MIN           ((l_u8)0)
#define  U1G_LIN_RSSP_MAX           ((l_u8)10)
#define  U1G_LIN_BTSP_MIN           ((l_u8)1)
#define  U1G_LIN_BTSP_MAX           ((l_u8)4)

/* CCRの割り込みマスクビット */
#define  U1G_LIN_IFLAG_CLR          ((l_u8)0)           /* CCRの割り込みマスクビット(I)=0(許可) */
#define  U1G_LIN_IFLAG_SET          ((l_u8)1)           /* CCRの割り込みマスクビット(I)=0(禁止) */

/* 受信ステータスのエラービットのマスク */
#define  U1G_LIN_SOER_MASK          ((l_u8)0x20)        /* オーバーランエラー */    
#define  U1G_LIN_SFER_MASK          ((l_u8)0x10)        /* フレーミングエラー */
#define  U1G_LIN_SPER_MASK          ((l_u8)0x08)        /* パリティエラー */

/* 受信ステータスのエラーセット値 */
#define  U1G_LIN_SOER_SET           ((l_u8)0x09)        /* オーバーランエラー */    
#define  U1G_LIN_SFER_SET           ((l_u8)0x0a)        /* フレーミングエラー */
#define  U1G_LIN_SPER_SET           ((l_u8)0x0c)        /* パリティエラー */

/*** 外部参照宣言 ***/
extern void  l_vog_lin_rx_int(l_u8 u1a_lin_data, l_u8 u1a_lin_err);
extern void  l_vog_lin_tm_int(void);
extern void  l_vog_lin_irq_int(void);

/*** アセンブリ関数参照宣言 ***/
/* Ver 1.01 削除:使用していない関数のため -> start */
/* extern void  l_vog_lin_set_imask_ccr(l_u8 u1a_lin_flg); */
/* extern l_u8  l_u1g_lin_get_imask_ccr(void); */
/* Ver 1.01 削除:使用していない関数のため <- end */
extern void  l_vog_lin_nop(void);

/* Ver 1.01 追加:宣言が抜けていたため -> start */
extern l_u8   l_u1g_lin_irq_dis(void);
extern void   l_vog_lin_irq_res(l_u8 u1a_lin_flg);
/* Ver 1.01 追加:宣言が抜けていたため <- end */

#endif

/***** End of File *****/




/*""FILE COMMENT""*******************************************/
/* System Name : NM Module for LSLib3687T                   */
/* File Name   : l_slin_nmc.c                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#pragma	section	lin

#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_nmc.h"

#define U1L_LIN_FLG_OFF             ((l_u8)0)
#define U1L_LIN_FLG_ON              ((l_u8)1)

#define U1L_LIN_SLPIND_SET          ((l_u8)0x80)    /* SLEEP_INDビットのセット用 */
#define U1L_LIN_WUPIND_SET          ((l_u8)0x40)    /* WAKEUP_INDビットのセット用 */
#define U1L_LIN_DATIND_SET          ((l_u8)0x20)    /* DATA_INDビットのセット用 */

/* スレーブタスク用変数 */
static l_u8  u1l_lin_mod_slvstat;                   /* NMスレーブステータス */
static l_u16 u2l_lin_tmr_slvst;                     /* Tslv_stカウンタ */
static l_u16 u2l_lin_tmr_wurty;                     /* Twurtyカウンタ */
static l_u16 u2l_lin_tmr_3brk;                      /* T3brksカウンタ */
static l_u16 u2l_lin_tmr_timeout;                   /* Ttimeoutカウンタ */
static l_u16 u2l_lin_tmr_data;                      /* Data.indカウンタ */
static l_u16 u2l_lin_cnt_retry;                     /* Retryカウンタ */
static l_u8  u1l_lin_wup_ind;                       /* Wakeup.ind情報フラグ */
static l_u8  u1l_lin_data_ind;                      /* Data.ind情報フラグ */
static l_u8  u1l_lin_cnt_msterr;                    /* マスタ監視用カウンタ */
static l_u8  u1l_lin_flg_msterr;                    /* マスタ異常発生フラグ */

/* 外部参照定義 */
extern void  l_vog_lin_set_nm_info(l_u8 u1a_lin_nm_info);

/* NM用APIプロトタイプ宣言 */
void l_nm_init_ch1(void);
void l_nm_tick_ch1(l_u8 u1a_lin_slp_req);
l_u8 l_nm_rd_slv_stat_ch1(void);
l_u8 l_nm_rd_mst_err_ch1(void);
void l_nm_clr_mst_err_ch1(void);

/****************************************************************************/
/*  NM用Tick処理API                                                         */
/*--------------------------------------------------------------------------*/
/*  引数：l_u8 slp_req                                                      */
/*          U1G_LIN_SLP_REQ_OFF(0)   :SLEEP要求無し、又はWAKEUP要因有り     */
/*          U1G_LIN_SLP_REQ_ON(1)    :SLEEP要求有り、又はWAKEUP要因無し     */
/*          U1G_LIN_SLP_REQ_FORCE(2) :強制SLEEP要求有り                     */
/*  戻値：なし                                                              */
/****************************************************************************/
void l_nm_tick_ch1(l_u8 u1a_lin_slp_req)
{
    l_u16 u2a_lin_stat;
    l_u8  u1a_lin_tmp_nm_dat;

    /* LINステータスのリード */
    u2a_lin_stat = l_ifc_read_lb_status_ch1();

    /* スレーブタスク用NMステータス管理処理 */
    switch (u2a_lin_stat) {
    /* LINステータスがSLEEP状態 */
    case (U2G_LIN_STS_SLEEP):
        switch (u1l_lin_mod_slvstat) {
        /* LINステータスがSLEEP状態 / NMスレーブステータスが起動後 */
        case (U1G_LIN_SLVSTAT_PON):
            /* 起動時は、スケジュール開始待ち状態にする */
            u2l_lin_tmr_slvst += U2G_LIN_NM_TIME_BASE;
            l_ifc_run_ch1();
            break;
        /* LINステータスがSLEEP状態 / NMスレーブステータスがWAKE_WAIT状態 */
        case (U1G_LIN_SLVSTAT_WAKE_WAIT):
            /* ウェイクアップ要因なし */
            if( u1a_lin_slp_req == U1G_LIN_SLP_REQ_ON ) {
                u2l_lin_tmr_timeout += U2G_LIN_NM_TIME_BASE;
                if( u2l_lin_tmr_timeout >= U2G_LIN_TM_TIMEOUT ) {
                    /* NMスレーブステータスをSLEEP状態に移行 */
                    u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_SLEEP;
                }
            }
            /* ウェイクアップ要因あり */
            else if( u1a_lin_slp_req == U1G_LIN_SLP_REQ_OFF ) {
                /* ウェイクアップ送信 */
                l_ifc_wake_up_ch1();
                u1l_lin_wup_ind = U1L_LIN_FLG_ON;
                u2l_lin_tmr_wurty = U2G_LIN_WORD_CLR;
                u2l_lin_cnt_retry = U2G_LIN_WORD_CLR;
                u2l_lin_tmr_timeout = U2G_LIN_WORD_CLR;
                u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_WAKE;
            }
            /* 強制スリープ要因あり */
            else if( u1a_lin_slp_req == U1G_LIN_SLP_REQ_FORCE ) {
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_SLEEP;
            }
            /* 上記以外 */
            else {
                /* 引数が範囲外の為、何もしない */
            }
            break;
        /* LINステータスがSLEEP状態 / NMスレーブステータスがSLEEP状態 */
        case (U1G_LIN_SLVSTAT_SLEEP):
            /* ウェイクアップ要因あり */
            if( u1a_lin_slp_req == U1G_LIN_SLP_REQ_OFF ) {
                l_ifc_wake_up_ch1();
                u1l_lin_wup_ind = U1L_LIN_FLG_ON;
                u2l_lin_tmr_wurty = U2G_LIN_WORD_CLR;
                u2l_lin_cnt_retry = U2G_LIN_WORD_CLR;
                u2l_lin_tmr_timeout = U2G_LIN_WORD_CLR;
                u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_WAKE;
            }
            break;
        /* LINステータスがSLEEP状態 / NMスレーブステータスがWAKE状態 */
        case (U1G_LIN_SLVSTAT_WAKE):
            /* Twurty時間経過後、ウェイクアップ再送する。*/
            u2l_lin_tmr_timeout += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_3brk += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_wurty += U2G_LIN_NM_TIME_BASE;
            if( u2l_lin_tmr_wurty >= U2G_LIN_TM_WURTY ) {
                if( u2l_lin_cnt_retry < U2G_LIN_CNT_RETRY ) {
                    /* ウェイクアップ再送 */
                    l_ifc_wake_up_ch1();
                    u2l_lin_cnt_retry++;
                    u2l_lin_tmr_wurty = U2G_LIN_WORD_CLR;
/* Ver 2.00 追加:T T3BRKの起点を変更 */
                    u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
/* Ver 2.00 追加:T T3BRKの起点を変更 */
                }
                else {
                    /* 2回ウェイクアップ再送後は、他WAKE状態に移行する。*/
                    u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_OTHER_WAKE;
                }
            }
            break;
        /* LINステータスがSLEEP状態 / NMスレーブステータスが他WAKE状態 */
        case (U1G_LIN_SLVSTAT_OTHER_WAKE):
            /* T3brks時間経過後、WAKE-WAIT状態に移行する */
            u2l_lin_tmr_timeout += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_3brk += U2G_LIN_NM_TIME_BASE;
            if( u2l_lin_tmr_3brk >= U2G_LIN_TM_3BRKS ) {
                u1l_lin_cnt_msterr++;
                if( u1l_lin_cnt_msterr >= U1G_LIN_CNT_MSTERR ) {
                    u1l_lin_flg_msterr = U1L_LIN_FLG_ON;
                }
                u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_WAKE_WAIT;
            }
            break;
        /* LINステータスがSLEEP状態 / NMスレーブステータスがACTIVE状態 */
        case (U1G_LIN_SLVSTAT_ACTIVE):
            /* SLEEP状態に移行する */
            u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_SLEEP;
            break;
        /* LINステータスがSLEEP状態 / NMスレーブステータスが上記以外 */
        default:
            /* 通常ありえないが、フェール処理としてSLEEP状態に移行 */
            u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_SLEEP;
            break;
        }
        break;
    /* LINステータスがRUN STANDBY状態 */
    case (U2G_LIN_STS_RUN_STANDBY):
        switch (u1l_lin_mod_slvstat) {
        /* LINステータスがRUN STANDBY状態 / NMスレーブステータスが起動後 */
        case (U1G_LIN_SLVSTAT_PON):
            /* Tslv_st時間経過後にWAKE-WAIT状態に移行する */
            u2l_lin_tmr_timeout += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_slvst += U2G_LIN_NM_TIME_BASE;
            if( u2l_lin_tmr_slvst >= U2G_LIN_TM_SLVST ) {
                l_ifc_sleep_ch1();
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_WAKE_WAIT;
            }
            break;
        /* LINステータスがRUN STANDBY状態 / NMスレーブステータスがWAKE_WAIT状態、又はSLEEP状態 */
        case (U1G_LIN_SLVSTAT_WAKE_WAIT):
        case (U1G_LIN_SLVSTAT_SLEEP):
            /* ウェイクアップ検出 */
            u2l_lin_tmr_timeout = U2G_LIN_WORD_CLR;
            u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_OTHER_WAKE;
            break;
        /* LINステータスがRUN STANDBY状態 / NMスレーブステータスがWAKE状態 */
        case (U1G_LIN_SLVSTAT_WAKE):
            u2l_lin_tmr_timeout += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_3brk += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_wurty += U2G_LIN_NM_TIME_BASE;
            if( u2l_lin_tmr_wurty >= U2G_LIN_TM_WURTY ) {
                if( u2l_lin_cnt_retry < U2G_LIN_CNT_RETRY ) {
                    l_ifc_wake_up_ch1();
                    u2l_lin_cnt_retry++;
                    u2l_lin_tmr_wurty = U2G_LIN_WORD_CLR;
/* Ver 2.00 追加:T T3BRKの起点を変更 */
                    u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
/* Ver 2.00 追加:T T3BRKの起点を変更 */
                }
                else {
                    u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_OTHER_WAKE;
                }
            }
            break;
        /* LINステータスがRUN STANDBY状態 / NMスレーブステータスが他WAKE状態 */
        case (U1G_LIN_SLVSTAT_OTHER_WAKE):
            /* T3brks時間経過後、WAKE-WAIT状態に移行する */
            u2l_lin_tmr_timeout += U2G_LIN_NM_TIME_BASE;
            u2l_lin_tmr_3brk += U2G_LIN_NM_TIME_BASE;
            if( u2l_lin_tmr_3brk >= U2G_LIN_TM_3BRKS ) {
                u1l_lin_cnt_msterr++;
                if( u1l_lin_cnt_msterr >= U1G_LIN_CNT_MSTERR ) {
                    u1l_lin_flg_msterr = U1L_LIN_FLG_ON;
                }
                l_ifc_sleep_ch1();
                u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_WAKE_WAIT;
            }
            break;
        /* LINステータスがRUN STANDBY状態 / NMスレーブステータスがACTIVE状態 */
        case (U1G_LIN_SLVSTAT_ACTIVE):
            /* SLEEP状態への移行 & 他ノードのウェイクアップ検出 */
            u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
            u2l_lin_tmr_timeout = U2G_LIN_WORD_CLR;
            u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_OTHER_WAKE;
            break;
        /* LINステータスがRUN STANDBY状態 / NMスレーブステータスが上記以外 */
        default:
            /* 通常ありえないが、フェール処理として他WAKE状態に移行 */
            u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
            u2l_lin_tmr_timeout = U2G_LIN_WORD_CLR;
            u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_OTHER_WAKE;
            break;
        }
        break;
    /* LINステータスがRUN状態 */
    case (U2G_LIN_STS_RUN):
        switch (u1l_lin_mod_slvstat) {
        /* LINステータスがRUN状態 / NMスレーブステータスがPASSIVE状態 */
        case (U1G_LIN_SLVSTAT_PON):
        case (U1G_LIN_SLVSTAT_WAKE_WAIT):
        case (U1G_LIN_SLVSTAT_SLEEP):
        case (U1G_LIN_SLVSTAT_WAKE):
        case (U1G_LIN_SLVSTAT_OTHER_WAKE):
            u1l_lin_cnt_msterr = U1G_LIN_BYTE_CLR;
            u1l_lin_flg_msterr = U1L_LIN_FLG_OFF;
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_ACTIVE;
            break;
        /* LINステータスがRUN状態 / NMスレーブステータスがACTIVE状態 */
        case (U1G_LIN_SLVSTAT_ACTIVE):
            /* 強制スリープ要因あり */
            if( u1a_lin_slp_req == U1G_LIN_SLP_REQ_FORCE ) {
                l_ifc_sleep_ch1();
                u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
                u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_SLEEP;
            }
            break;
        /* LINステータスがRUN状態 / NMスレーブステータスが上記以外 */
        default:
            /* 通常ありえないが、フェール処理としてACTIVE状態に移行 */
            u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_ACTIVE;
            break;
        }
        break;
    /* LINステータスが上記以外 */
    default:
        /* 通常は発生しない処理 */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;               /* システム異常(ステータス) */
        break;
    }

    /* Data.indの管理 */
    if( u1l_lin_data_ind == U1L_LIN_FLG_OFF ) {
        u2l_lin_tmr_data += U2G_LIN_NM_TIME_BASE;
        if( u2l_lin_tmr_data >= U2G_LIN_TM_DATA ) {
            u1l_lin_data_ind = U1L_LIN_FLG_ON;
        }
    }

    /* LINライブラリのNM情報書換え処理 */
    u1a_lin_tmp_nm_dat = U1G_LIN_BYTE_CLR;
    if( u1a_lin_slp_req == U1G_LIN_SLP_REQ_ON ) {
        /* Sleep.indビットのセット */
        u1a_lin_tmp_nm_dat |= U1L_LIN_SLPIND_SET;
    }
    if( u1l_lin_wup_ind == U1L_LIN_FLG_ON ) {
        /* Wakeup.indビットのセット */
        u1a_lin_tmp_nm_dat |= U1L_LIN_WUPIND_SET;
    }
    if( u1l_lin_data_ind == U1L_LIN_FLG_ON ) {
        /* Data.indビットのセット */
        u1a_lin_tmp_nm_dat |= U1L_LIN_DATIND_SET;
    }
    /* NM情報書換え関数のコール */
    l_vog_lin_set_nm_info(u1a_lin_tmp_nm_dat);
}

/****************************************************************************/
/*  NM用初期化処理API                                                       */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：なし                                                              */
/****************************************************************************/
void l_nm_init_ch1(void)
{
/* スレーブタスク用変数 */
    u1l_lin_mod_slvstat = U1G_LIN_SLVSTAT_PON;
    u2l_lin_tmr_slvst = U2G_LIN_WORD_CLR;
    u2l_lin_tmr_wurty = U2G_LIN_WORD_CLR;
    u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;
    u2l_lin_tmr_timeout = U2G_LIN_WORD_CLR;
    u2l_lin_tmr_data = U2G_LIN_WORD_CLR;
    u2l_lin_cnt_retry = U2G_LIN_WORD_CLR;
    u1l_lin_wup_ind = U1L_LIN_FLG_OFF;
    u1l_lin_data_ind = U1L_LIN_FLG_OFF;
    u1l_lin_cnt_msterr = U1G_LIN_BYTE_CLR;
    u1l_lin_flg_msterr = U1L_LIN_FLG_OFF;
}

/****************************************************************************/
/*  NMスレーブステータスリードAPI                                           */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：l_u8  NMスレーブステータス                                        */
/****************************************************************************/
l_u8 l_nm_rd_slv_stat_ch1(void)
{
    return (u1l_lin_mod_slvstat);
}

/****************************************************************************/
/*  マスタ異常フラグのリードAPI                                             */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：l_u8  0：マスタ異常なし, 1:マスタ異常あり                         */
/****************************************************************************/
l_u8 l_nm_rd_mst_err_ch1(void)
{
    return (u1l_lin_flg_msterr);
}

/****************************************************************************/
/*  マスタ異常フラグのクリアAPI                                             */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：なし                                                              */
/****************************************************************************/
void l_nm_clr_mst_err_ch1(void)
{
    u1l_lin_flg_msterr = U1L_LIN_FLG_OFF;
}

/***** End of File *****/



/*""FILE COMMENT""*******************************************/
/* System Name : NM Module for LSLib3687T                   */
/* File Name   : l_slin_nmc.h                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_NMC_H_INCLUDE__
#define __L_SLIN_NMC_H_INCLUDE__

/* ユーザ編集可能な定数定義 */
/* スレーブタスク用定数 */
#define U2G_LIN_TM_SLVST            ((l_u16)550)    /* ウェイクアップ信号送信許可時間 - 初期化完了時間 */
#define U2G_LIN_TM_WURTY            ((l_u16)50)     /* ウェイクアップ信号リトライ時間 */
#define U2G_LIN_TM_3BRKS            ((l_u16)1500)   /* TIME-OUT AFTER THREE BREAKS */
#define U2G_LIN_CNT_RETRY           ((l_u16)2)      /* ウェイクアップリトライ回数 */
#define U2G_LIN_TM_DATA             ((l_u16)500)    /* Data.indビット設定時間 */
#define U2G_LIN_NM_TIME_BASE        ((l_u16)6)      /* NM用タイムベース時間 */
#define U1G_LIN_CNT_MSTERR          ((l_u8)3)       /* マスタ異常検出までのウェイクアップ失敗回数 */

/* ライブラリ参照用定数定義(ユーザ編集不可) */
/* スレーブタスク用定数 */
#define U1G_LIN_SLVSTAT_PON         ((l_u8)0)       /* ON/PASSIVE/WAKE-WAIT(起動後)状態 */
#define U1G_LIN_SLVSTAT_WAKE_WAIT   ((l_u8)1)       /* ON/PASSOVE/WAKE-WAIT状態 */
#define U1G_LIN_SLVSTAT_SLEEP       ((l_u8)2)       /* ON/PASSIVE/SLEEP状態 */
#define U1G_LIN_SLVSTAT_WAKE        ((l_u8)3)       /* ON/PASSIVE/WAKE状態 */
#define U1G_LIN_SLVSTAT_OTHER_WAKE  ((l_u8)4)       /* ON/PASSIVE/他WAKE状態 */
#define U1G_LIN_SLVSTAT_ACTIVE      ((l_u8)5)       /* ON/ACTIVE状態 */

#if U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_2400
 #define  U2G_LIN_TM_TIMEOUT        ((l_u16)10400)  /* NM用Bus Idle Time-out(25000bit長) ms値 */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_9600
 #define  U2G_LIN_TM_TIMEOUT        ((l_u16)2600)   /* NM用Bus Idle Time-out(25000bit長) ms値 */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_19200
 #define  U2G_LIN_TM_TIMEOUT        ((l_u16)1300)   /* NM用Bus Idle Time-out(25000bit長) ms値 */
#endif

#define U1G_LIN_SLP_REQ_OFF         ((l_u8)0)       /* スリープ要求無し,又はウェイクアップ要因有り */
#define U1G_LIN_SLP_REQ_ON          ((l_u8)1)       /* スリープ要求有り,又はウェイクアップ要因無し */
#define U1G_LIN_SLP_REQ_FORCE       ((l_u8)2)       /* 強制スリープ要因有り */

/* 外部参照定義 */
extern void l_nm_init_ch1(void);
extern void l_nm_tick_ch1(l_u8 u1a_lin_slp_req);
extern l_u8 l_nm_rd_slv_stat_ch1(void);
extern l_u8 l_nm_rd_mst_err_ch1(void);
extern void l_nm_clr_mst_err_ch1(void);

#endif

/***** End of File *****/



/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_sfr_h83687.h                        */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         : H8/3687                                    */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_SFR_H83687__
#define __L_SLIN_SFR_H83687__

/*** 定数定義 ***/
/* デバイス依存部分の定数定義 */
#define  U1G_LIN_SCI1               (0)
#define  U1G_LIN_SCI2               (1)

#define  U1G_LIN_BRGSRC_F1          (0)
#define  U1G_LIN_BRGSRC_F4          (1)

#define  U1G_LIN_TIMERZ0            (0)
#define  U1G_LIN_TIMERZ1            (1)

#define  U1G_LIN_WP_INT0            (0)
#define  U1G_LIN_WP_INT1            (1)
#define  U1G_LIN_WP_INT2            (2)
#define  U1G_LIN_WP_INT3            (3)

/*** 構造体、共用体定義 ***/
/* デバイス依存部分のSFR定義 */
typedef union {
    l_u8    u1l_lin_byte;
    struct {
        l_u8    u1l_lin_b7:1;
        l_u8    u1l_lin_b6:1;
        l_u8    u1l_lin_b5:1;
        l_u8    u1l_lin_b4:1;
        l_u8    u1l_lin_b3:1;
        l_u8    u1l_lin_b2:1;
        l_u8    u1l_lin_b1:1;
        l_u8    u1l_lin_b0:1;
    } st_bit;
} un_lin_byte_def_type;

typedef union {
    l_u16   u2l_lin_word;
    struct {
        l_u16   u2l_lin_b15:1;
        l_u16   u2l_lin_b14:1;
        l_u16   u2l_lin_b13:1;
        l_u16   u2l_lin_b12:1;
        l_u16   u2l_lin_b11:1;
        l_u16   u2l_lin_b10:1;
        l_u16   u2l_lin_b9:1;
        l_u16   u2l_lin_b8:1;
        l_u16   u2l_lin_b7:1;
        l_u16   u2l_lin_b6:1;
        l_u16   u2l_lin_b5:1;
        l_u16   u2l_lin_b4:1;
        l_u16   u2l_lin_b3:1;
        l_u16   u2l_lin_b2:1;
        l_u16   u2l_lin_b1:1;
        l_u16   u2l_lin_b0:1;
    } st_bit;
} un_lin_word_def_type;

/***** I/Oポート *****/
/* ポートモードレジスタ1 端子機能の切替えに必要 */
extern   un_lin_byte_def_type           U1G_LIN_REG_PMR1;

/***** SCI *****/
/* SCI1使用 */
#if U1G_LIN_UART == U1G_LIN_SCI1
    /* レシーブデータレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_RDR_1;
    #define  U1G_LIN_REG_RDR        U1G_LIN_REG_RDR_1
    /* トランスミットデータレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TDR_1;
    #define  U1G_LIN_REG_TDR        U1G_LIN_REG_TDR_1
    /* シリアルモードレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_SMR_1;
    #define U1G_LIN_REG_SMR         U1G_LIN_REG_SMR_1
    /* シリアルコントロールレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_SCR3_1;
    #define  U1G_LIN_REG_SCR3       U1G_LIN_REG_SCR3_1
    #define  U1G_LIN_FLG_STIC       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b7
    #define  U1G_LIN_FLG_SRIC       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b6
    #define  U1G_LIN_FLG_STEN       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b5
    #define  U1G_LIN_FLG_SREN       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b4
    /* シリアルステータスレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_SSR_1;
    #define  U1G_LIN_REG_SSR        U1G_LIN_REG_SSR_1
    #define  U1G_LIN_FLG_SRF        U1G_LIN_REG_SSR.st_bit.u1l_lin_b6
    #define  U1G_LIN_FLG_SOER       U1G_LIN_REG_SSR.st_bit.u1l_lin_b5
    #define  U1G_LIN_FLG_SFER       U1G_LIN_REG_SSR.st_bit.u1l_lin_b4
    #define  U1G_LIN_FLG_SPER       U1G_LIN_REG_SSR.st_bit.u1l_lin_b3
    /* ビットレートレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_BRR_1;
    #define  U1G_LIN_REG_BRR        U1G_LIN_REG_BRR_1
    /* ポートモードレジスタ1 */
    #define  U1G_LIN_FLG_PMTXD      U1G_LIN_REG_PMR1.st_bit.u1l_lin_b1
/* SCI2使用 */
#elif U1G_LIN_UART == U1G_LIN_SCI2
    /* レシーブデータレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_RDR_2;
    #define  U1G_LIN_REG_RDR        U1G_LIN_REG_RDR_2
    /* トランスミットデータレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TDR_2;
    #define  U1G_LIN_REG_TDR        U1G_LIN_REG_TDR_2
    /* シリアルモードレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_SMR_2;
    #define  U1G_LIN_REG_SMR        U1G_LIN_REG_SMR_2
    /* シリアルコントロールレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_SCR3_2;
    #define  U1G_LIN_REG_SCR3       U1G_LIN_REG_SCR3_2
    #define  U1G_LIN_FLG_STIC       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b7
    #define  U1G_LIN_FLG_SRIC       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b6
    #define  U1G_LIN_FLG_STEN       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b5
    #define  U1G_LIN_FLG_SREN       U1G_LIN_REG_SCR3.st_bit.u1l_lin_b4
    /* シリアルステータスレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_SSR_2;
    #define  U1G_LIN_REG_SSR        U1G_LIN_REG_SSR_2
    #define  U1G_LIN_FLG_SRF        U1G_LIN_REG_SSR.st_bit.u1l_lin_b6
    #define  U1G_LIN_FLG_SOER       U1G_LIN_REG_SSR.st_bit.u1l_lin_b5
    #define  U1G_LIN_FLG_SFER       U1G_LIN_REG_SSR.st_bit.u1l_lin_b4
    #define  U1G_LIN_FLG_SPER       U1G_LIN_REG_SSR.st_bit.u1l_lin_b3
    /* ビットレートレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_BRR_2;
    #define U1G_LIN_REG_BRR         U1G_LIN_REG_BRR_2
    /* ポートモードレジスタ1 */
    #define U1G_LIN_FLG_PMTXD       U1G_LIN_REG_PMR1.st_bit.u1l_lin_b3
#endif

/***** Timer *****/
/* TimerZ0使用 */
#if U1G_LIN_TM == U1G_LIN_TIMERZ0
    /* タイマスタートレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TSTR_Z0;
    #define  U1G_LIN_REG_TSTR       U1G_LIN_REG_TSTR_Z0
    #define  U1G_LIN_FLG_TMST       U1G_LIN_REG_TSTR.st_bit.u1l_lin_b0
    /* タイマカウンタ */
    extern   un_lin_word_def_type   U2G_LIN_REG_TCNT_Z0;
    #define  U2G_LIN_REG_TCNT       U2G_LIN_REG_TCNT_Z0
    /* ジェネラルレジスタ */
    extern   un_lin_word_def_type   U2G_LIN_REG_GRA_Z0;
    #define  U2G_LIN_REG_GRA        U2G_LIN_REG_GRA_Z0
    /* タイマコントロールレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TCR_Z0;
    #define  U1G_LIN_REG_TCR        U1G_LIN_REG_TCR_Z0
    /* タイマI/Oコントロールレジスタ(TIORA) */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TIORA_Z0;
    #define  U1G_LIN_REG_TIORA      U1G_LIN_REG_TIORA_Z0
    /* タイマステータスレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TSR_Z0;
    #define  U1G_LIN_REG_TSR        U1G_LIN_REG_TSR_Z0
    #define  U1G_LIN_FLG_TMIR       U1G_LIN_REG_TSR.st_bit.u1l_lin_b0
    /* タイマインタラプトイネーブルレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TIER_Z0;
    #define  U1G_LIN_REG_TIER       U1G_LIN_REG_TIER_Z0
    #define  U1G_LIN_FLG_TMIC       U1G_LIN_REG_TIER.st_bit.u1l_lin_b0
/* TimerZ1使用 */
#elif U1G_LIN_TM == U1G_LIN_TIMERZ1
    /* タイマスタートレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TSTR_Z1;
    #define  U1G_LIN_REG_TSTR       U1G_LIN_REG_TSTR_Z1
    #define  U1G_LIN_FLG_TMST       U1G_LIN_REG_TSTR.st_bit.u1l_lin_b1
    /* タイマカウンタ */
    extern   un_lin_word_def_type   U2G_LIN_REG_TCNT_Z1;
    #define  U2G_LIN_REG_TCNT       U2G_LIN_REG_TCNT_Z1
    /* ジェネラルレジスタ */
    extern   un_lin_word_def_type   U2G_LIN_REG_GRA_Z1;
    #define  U2G_LIN_REG_GRA        U2G_LIN_REG_GRA_Z1
    /* タイマコントロールレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TCR_Z1;
    #define  U1G_LIN_REG_TCR        U1G_LIN_REG_TCR_Z1
    /* タイマI/Oコントロールレジスタ(TIORA) */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TIORA_Z1;
    #define  U1G_LIN_REG_TIORA      U1G_LIN_REG_TIORA_Z1
    /* タイマステータスレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TSR_Z1;
    #define  U1G_LIN_REG_TSR        U1G_LIN_REG_TSR_Z1
    #define  U1G_LIN_FLG_TMIR       U1G_LIN_REG_TSR.st_bit.u1l_lin_b0
    /* タイマインタラプトイネーブルレジスタ */
    extern   un_lin_byte_def_type   U1G_LIN_REG_TIER_Z1;
    #define  U1G_LIN_REG_TIER       U1G_LIN_REG_TIER_Z1
    #define  U1G_LIN_FLG_TMIC       U1G_LIN_REG_TIER.st_bit.u1l_lin_b0
#endif

/***** INT *****/
    extern   un_lin_byte_def_type   U1G_LIN_REG_IEGR1;
    extern   un_lin_byte_def_type   U1G_LIN_REG_IENR1;
    extern   un_lin_byte_def_type   U1G_LIN_REG_IRR1;
/* IRQ0使用 */
#if U1G_LIN_WP_INT == U1G_LIN_WP_INT0
    /* 割り込みエッジセレクトレジスタ1 */
    #define  U1G_LIN_FLG_INTEG      U1G_LIN_REG_IEGR1.st_bit.u1l_lin_b0
    /* 割り込みイネーブルレジスタ1 */
    #define  U1G_LIN_FLG_INTIC      U1G_LIN_REG_IENR1.st_bit.u1l_lin_b0
    /* 割り込みフラグレジスタ1 */
    #define  U1G_LIN_FLG_INTIR      U1G_LIN_REG_IRR1.st_bit.u1l_lin_b0
    /* ポートモードレジスタ1 */
    #define U1G_LIN_FLG_PMIRQ       U1G_LIN_REG_PMR1.st_bit.u1l_lin_b4
/* IRQ1使用 */
#elif U1G_LIN_WP_INT == U1G_LIN_WP_INT1
    /* 割り込みエッジセレクトレジスタ1 */
    #define  U1G_LIN_FLG_INTEG      U1G_LIN_REG_IEGR1.st_bit.u1l_lin_b1
    /* 割り込みイネーブルレジスタ1 */
    #define  U1G_LIN_FLG_INTIC      U1G_LIN_REG_IENR1.st_bit.u1l_lin_b1
    /* 割り込みフラグレジスタ1 */
    #define  U1G_LIN_FLG_INTIR      U1G_LIN_REG_IRR1.st_bit.u1l_lin_b1
    /* ポートモードレジスタ1 */
    #define  U1G_LIN_FLG_PMIRQ      U1G_LIN_REG_PMR1.st_bit.u1l_lin_b5
/* IRQ2使用 */
#elif U1G_LIN_WP_INT == U1G_LIN_WP_INT2
    /* 割り込みエッジセレクトレジスタ1 */
    #define  U1G_LIN_FLG_INTEG      U1G_LIN_REG_IEGR1.st_bit.u1l_lin_b2
    /* 割り込みイネーブルレジスタ1 */
    #define  U1G_LIN_FLG_INTIC      U1G_LIN_REG_IENR1.st_bit.u1l_lin_b2
    /* 割り込みフラグレジスタ1 */
    #define  U1G_LIN_FLG_INTIR      U1G_LIN_REG_IRR1.st_bit.u1l_lin_b2
    /* ポートモードレジスタ1 */
    #define  U1G_LIN_FLG_PMIRQ      U1G_LIN_REG_PMR1.st_bit.u1l_lin_b6
/* IRQ3使用 */
#elif U1G_LIN_WP_INT == U1G_LIN_WP_INT3
    /* 割り込みエッジセレクトレジスタ1 */
    #define  U1G_LIN_FLG_INTEG      U1G_LIN_REG_IEGR1.st_bit.u1l_lin_b3
    /* 割り込みイネーブルレジスタ1 */
    #define  U1G_LIN_FLG_INTIC      U1G_LIN_REG_IENR1.st_bit.u1l_lin_b3
    /* 割り込みフラグレジスタ1 */
    #define  U1G_LIN_FLG_INTIR      U1G_LIN_REG_IRR1.st_bit.u1l_lin_b3
    /* ポートモードレジスタ1 */
    #define  U1G_LIN_FLG_PMIRQ      U1G_LIN_REG_PMR1.st_bit.u1l_lin_b7
#endif

#endif

/***** End of File *****/





/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_tbl.c                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*           ･ライブラリリリース用のデフォルト設定に変更    */
/*""FILE COMMENT END""***************************************/

#pragma	section	lin

#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"


/********************************
スレーブタスク用テーブル設定
********************************/
/* ID情報テーブル 実体 (LDF: Frames) */
const l_u8  u1g_lin_id_tbl[ U1G_LIN_MAX_SLOT_NUM ] = {
    (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x00 - 0x07 */
   ,(l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x08 - 0x0F */
   ,(l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x10 - 0x17 */
   ,(l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x18 - 0x1F */
   ,(l_u8)0xFF, (l_u8)0xFF, (l_u8)0x03, (l_u8)0x05, (l_u8)0x06, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x20 - 0x27 */
   ,(l_u8)0x00, (l_u8)0x01, (l_u8)0x02, (l_u8)0x04, (l_u8)0x09, (l_u8)0x0A, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x28 - 0x2F */
   ,(l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x30 - 0x37 */
   ,(l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0xFF, (l_u8)0x07, (l_u8)0x08, (l_u8)0xFF, (l_u8)0xFF  /* Identifier : 0x38 - 0x3F */
};


/* スロット情報テーブル 実体 */
const st_lin_slot_info_type  xng_lin_slot_tbl[ U1G_LIN_MAX_SLOT ] = {
    { (l_u8)0x28, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x29, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x2a, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x22, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
	}
   ,{ (l_u8)0x2b, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_USE
       ,{ (l_u8)0x01, (l_u8)0x02, (l_u8)0x03, (l_u8)0x04, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x23, U1G_LIN_DL_4, U1G_LIN_CMD_SND, U1G_LIN_NM_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x24, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_USE
       ,{ (l_u8)0x01, (l_u8)0x02, (l_u8)0x03, (l_u8)0x04, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x3c, U1G_LIN_DL_8, U1G_LIN_CMD_RCV, U1G_LIN_NM_NO_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x3d, U1G_LIN_DL_8, U1G_LIN_CMD_SND, U1G_LIN_NM_NO_USE
       ,{ (l_u8)0xad, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x2c, U1G_LIN_DL_8, U1G_LIN_CMD_RCV, U1G_LIN_NM_NO_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
   ,{ (l_u8)0x2d, U1G_LIN_DL_8, U1G_LIN_CMD_SND, U1G_LIN_NM_NO_USE
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
       ,{ (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00, (l_u8)0x00 }
    }
};


/***************************************************************************/
/***************************************************************************/
/*           !!!以降は絶対に 変更、削除をおこなわないで下さい!!!           */
/***************************************************************************/
/***************************************************************************/

/* 保護IDテーブル 実体 */
const l_u8  u1g_lin_protid_tbl[ U1G_LIN_MAX_SLOT_NUM ] = {
     (l_u8)0x80, (l_u8)0xC1, (l_u8)0x42, (l_u8)0x03, (l_u8)0xC4, (l_u8)0x85, (l_u8)0x06, (l_u8)0x47  /* 0x00 - 0x07 */
    ,(l_u8)0x08, (l_u8)0x49, (l_u8)0xCA, (l_u8)0x8B, (l_u8)0x4C, (l_u8)0x0D, (l_u8)0x8E, (l_u8)0xCF  /* 0x08 - 0x0F */
    ,(l_u8)0x50, (l_u8)0x11, (l_u8)0x92, (l_u8)0xD3, (l_u8)0x14, (l_u8)0x55, (l_u8)0xD6, (l_u8)0x97  /* 0x10 - 0x17 */
    ,(l_u8)0xD8, (l_u8)0x99, (l_u8)0x1A, (l_u8)0x5B, (l_u8)0x9C, (l_u8)0xDD, (l_u8)0x5E, (l_u8)0x1F  /* 0x18 - 0x1F */
    ,(l_u8)0x20, (l_u8)0x61, (l_u8)0xE2, (l_u8)0xA3, (l_u8)0x64, (l_u8)0x25, (l_u8)0xA6, (l_u8)0xE7  /* 0x20 - 0x27 */
    ,(l_u8)0xA8, (l_u8)0xE9, (l_u8)0x6A, (l_u8)0x2B, (l_u8)0xEC, (l_u8)0xAD, (l_u8)0x2E, (l_u8)0x6F  /* 0x28 - 0x2F */
    ,(l_u8)0xF0, (l_u8)0xB1, (l_u8)0x32, (l_u8)0x73, (l_u8)0xB4, (l_u8)0xF5, (l_u8)0x76, (l_u8)0x37  /* 0x30 - 0x37 */
    ,(l_u8)0x78, (l_u8)0x39, (l_u8)0xBA, (l_u8)0xFB, (l_u8)0x3C, (l_u8)0x7D, (l_u8)0xFE, (l_u8)0xBF  /* 0x38 - 0x3F */
};


/* フラグセットテーブル(16bit) 実体 */
const l_u16  u2g_lin_flg_set_tbl[ U1G_LIN_WORD_BIT ] = {
     (l_u16)0x0001, (l_u16)0x0002, (l_u16)0x0004, (l_u16)0x0008
    ,(l_u16)0x0010, (l_u16)0x0020, (l_u16)0x0040, (l_u16)0x0080
    ,(l_u16)0x0100, (l_u16)0x0200, (l_u16)0x0400, (l_u16)0x0800
    ,(l_u16)0x1000, (l_u16)0x2000, (l_u16)0x4000, (l_u16)0x8000
};


/* フラグクリアテーブル(16bit) 実体 */
const l_u16  u2g_lin_flg_clr_tbl[ U1G_LIN_WORD_BIT ] = {
     (l_u16)0xFFFE, (l_u16)0xFFFD, (l_u16)0xFFFB, (l_u16)0xFFF7
    ,(l_u16)0xFFEF, (l_u16)0xFFDF, (l_u16)0xFFBF, (l_u16)0xFF7F
    ,(l_u16)0xFEFF, (l_u16)0xFDFF, (l_u16)0xFBFF, (l_u16)0xF7FF
    ,(l_u16)0xEFFF, (l_u16)0xDFFF, (l_u16)0xBFFF, (l_u16)0x7FFF
};


/* LIN STATUS BUF 実体 */
st_lin_state_type  xng_lin_sts_buf;

/* LIN FRAME BUF 実体 */
st_lin_buf_type  xng_lin_frm_buf[ U1G_LIN_MAX_SLOT ];

/* LIN Bus ステータステーブル */
un_lin_bus_status_type  xng_lin_bus_sts;

/* NM 情報テーブル */
l_u8  u1g_lin_nm_info;

/* システム異常フラグ */
l_u8  u1g_lin_syserr;

/***** End of File *****/



/*""FILE COMMENT""*******************************************/
/* System Name : LSLib3687T                                 */
/* File Name   : l_slin_tbl.h                               */
/* Version     : 2.00                                       */
/* Contents    :                                            */
/* Customer    : SUNNY GIKEN INC.                           */
/* Model       :                                            */
/* Order       :                                            */
/* CPU         :                                            */
/* Compiler    :                                            */
/* OS          : Not used                                   */
/* LIN         : トヨタ自動車殿標準LIN仕様                  */
/* Programmer  :                                            */
/* Note        :                                            */
/************************************************************/
/* Copyright 2004 - 2005 SUNNY GIKEN INC.                   */
/************************************************************/
/* History : 2004.08.03 Ver 1.00                            */
/*         : 2004.11.04 Ver 1.01                            */
/*         : 2005.02.10 Ver 2.00                            */
/*""FILE COMMENT END""***************************************/

#ifndef __L_SLIN_TBL_H_INCLUDE__
#define __L_SLIN_TBL_H_INCLUDE__


/*** 構造体、共用体定義 ***/

/*=============== エンディアンタイプによるコンパイルスイッチの開始 ===============*/

/*=============== リトルエンディアンタイプ ===============*/
#if  U1G_LIN_ENDIAN_TYPE == U1G_LIN_ENDIAN_LITTLE

/* LIN ステータスバッファの定義 */
typedef struct {
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_nad:8;
            l_u16   u2g_lin_sts:2;
            l_u16   reserve:1;
            l_u16   u2g_lin_phy_bus_err:1;
            l_u16   u2g_lin_e_time:1;
            l_u16   u2g_lin_e_uart:1;
            l_u16   u2g_lin_e_synch:1;
            l_u16   u2g_lin_e_pari:1;
        } st_bit;
        struct {
            l_u16   reserve:12;
            l_u16   u2g_lin_e_head:4;
        } st_err;
    } un_state;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_node1:1;
            l_u16   u2g_lin_node2:1;
            l_u16   u2g_lin_node3:1;
            l_u16   u2g_lin_node4:1;
            l_u16   u2g_lin_node5:1;
            l_u16   u2g_lin_node6:1;
            l_u16   u2g_lin_node7:1;
            l_u16   u2g_lin_node8:1;
            l_u16   u2g_lin_node9:1;
            l_u16   u2g_lin_node10:1;
            l_u16   u2g_lin_node11:1;
            l_u16   u2g_lin_node12:1;
            l_u16   u2g_lin_node13:1;
            l_u16   u2g_lin_node14:1;
            l_u16   u2g_lin_node15:1;
            l_u16   u2g_lin_node16:1;
        } st_bit;
    } un_node_flg;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot1:1;
            l_u16   u2g_lin_slot2:1;
            l_u16   u2g_lin_slot3:1;
            l_u16   u2g_lin_slot4:1;
            l_u16   u2g_lin_slot5:1;
            l_u16   u2g_lin_slot6:1;
            l_u16   u2g_lin_slot7:1;
            l_u16   u2g_lin_slot8:1;
            l_u16   u2g_lin_slot9:1;
            l_u16   u2g_lin_slot10:1;
            l_u16   u2g_lin_slot11:1;
            l_u16   u2g_lin_slot12:1;
            l_u16   u2g_lin_slot13:1;
            l_u16   u2g_lin_slot14:1;
            l_u16   u2g_lin_slot15:1;
            l_u16   u2g_lin_slot16:1;
        } st_bit;
    } un_rs_flg1;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot17:1;
            l_u16   u2g_lin_slot18:1;
            l_u16   u2g_lin_slot19:1;
            l_u16   u2g_lin_slot20:1;
            l_u16   u2g_lin_slot21:1;
            l_u16   u2g_lin_slot22:1;
            l_u16   u2g_lin_slot23:1;
            l_u16   u2g_lin_slot24:1;
            l_u16   u2g_lin_slot25:1;
            l_u16   u2g_lin_slot26:1;
            l_u16   u2g_lin_slot27:1;
            l_u16   u2g_lin_slot28:1;
            l_u16   u2g_lin_slot29:1;
            l_u16   u2g_lin_slot30:1;
            l_u16   u2g_lin_slot31:1;
            l_u16   u2g_lin_slot32:1;
        } st_bit;
    } un_rs_flg2;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot33:1;
            l_u16   u2g_lin_slot34:1;
            l_u16   u2g_lin_slot35:1;
            l_u16   u2g_lin_slot36:1;
            l_u16   u2g_lin_slot37:1;
            l_u16   u2g_lin_slot38:1;
            l_u16   u2g_lin_slot39:1;
            l_u16   u2g_lin_slot40:1;
            l_u16   u2g_lin_slot41:1;
            l_u16   u2g_lin_slot42:1;
            l_u16   u2g_lin_slot43:1;
            l_u16   u2g_lin_slot44:1;
            l_u16   u2g_lin_slot45:1;
            l_u16   u2g_lin_slot46:1;
            l_u16   u2g_lin_slot47:1;
            l_u16   u2g_lin_slot48:1;
        } st_bit;
    } un_rs_flg3;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot49:1;
            l_u16   u2g_lin_slot50:1;
            l_u16   u2g_lin_slot51:1;
            l_u16   u2g_lin_slot52:1;
            l_u16   u2g_lin_slot53:1;
            l_u16   u2g_lin_slot54:1;
            l_u16   u2g_lin_slot55:1;
            l_u16   u2g_lin_slot56:1;
            l_u16   u2g_lin_slot57:1;
            l_u16   u2g_lin_slot58:1;
            l_u16   u2g_lin_slot59:1;
            l_u16   u2g_lin_slot60:1;
            l_u16   u2g_lin_slot61:1;
            l_u16   u2g_lin_slot62:1;
            l_u16   u2g_lin_slot63:1;
            l_u16   u2g_lin_slot64:1;
        } st_bit;
    } un_rs_flg4;
} st_lin_state_type;


/* LINフレームバッファの定義 */
typedef struct {
    un_lin_data_type  xng_lin_data;
    union {
       l_u16    u2g_lin_word;
        struct {
            l_u16   reserve1:8;
            l_u16   u2g_lin_err:4;
            l_u16   reserve2:4;
        } st_err;
        struct {
            l_u16   u2g_lin_chksum:8;
            l_u16   u2g_lin_e_nores:1;
            l_u16   u2g_lin_e_uart:1;
            l_u16   u2g_lin_e_bit:1;
            l_u16   u2g_lin_e_sum:1;
            l_u16   reserve:3;
            l_u16   u2g_lin_no_use:1;
        } st_bit;
    } un_state;
} st_lin_buf_type;


/* LIN Busステータス */
typedef union {
    l_u16  u2g_lin_word;
    struct {
        l_u16  u2g_lin_err_resp:1;
        l_u16  u2g_lin_ok_resp:1;
        l_u16  u2g_lin_ovr_run:1;
        l_u16  u2g_lin_goto_sleep:1;
        l_u16  reserve:2;
        l_u16  u2g_lin_bus_err:1;
        l_u16  u2g_lin_head_err:1;
        l_u16  u2g_lin_last_id:8;
    } st_bit;
} un_lin_bus_status_type;


/*=============== ビッグエンディアンタイプ ===============*/
#elif  U1G_LIN_ENDIAN_TYPE == U1G_LIN_ENDIAN_BIG
/* LIN ステータスバッファの定義 */
typedef struct {
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_e_pari:1;
            l_u16   u2g_lin_e_synch:1;
            l_u16   u2g_lin_e_uart:1;
            l_u16   u2g_lin_e_time:1;
            l_u16   u2g_lin_phy_bus_err:1;
            l_u16   reserve:1;
            l_u16   u2g_lin_sts:2;
            l_u16   u2g_lin_nad:8;
        } st_bit;
        struct {
            l_u16   u2g_lin_e_head:4;
            l_u16   reserve:12;
        } st_err;
    } un_state;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_node16:1;
            l_u16   u2g_lin_node15:1;
            l_u16   u2g_lin_node14:1;
            l_u16   u2g_lin_node13:1;
            l_u16   u2g_lin_node12:1;
            l_u16   u2g_lin_node11:1;
            l_u16   u2g_lin_node10:1;
            l_u16   u2g_lin_node9:1;
            l_u16   u2g_lin_node8:1;
            l_u16   u2g_lin_node7:1;
            l_u16   u2g_lin_node6:1;
            l_u16   u2g_lin_node5:1;
            l_u16   u2g_lin_node4:1;
            l_u16   u2g_lin_node3:1;
            l_u16   u2g_lin_node2:1;
            l_u16   u2g_lin_node1:1;
        } st_bit;
    } un_node_flg;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot16:1;
            l_u16   u2g_lin_slot15:1;
            l_u16   u2g_lin_slot14:1;
            l_u16   u2g_lin_slot13:1;
            l_u16   u2g_lin_slot12:1;
            l_u16   u2g_lin_slot11:1;
            l_u16   u2g_lin_slot10:1;
            l_u16   u2g_lin_slot9:1;
            l_u16   u2g_lin_slot8:1;
            l_u16   u2g_lin_slot7:1;
            l_u16   u2g_lin_slot6:1;
            l_u16   u2g_lin_slot5:1;
            l_u16   u2g_lin_slot4:1;
            l_u16   u2g_lin_slot3:1;
            l_u16   u2g_lin_slot2:1;
            l_u16   u2g_lin_slot1:1;
        } st_bit;
    } un_rs_flg1;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot32:1;
            l_u16   u2g_lin_slot31:1;
            l_u16   u2g_lin_slot30:1;
            l_u16   u2g_lin_slot29:1;
            l_u16   u2g_lin_slot28:1;
            l_u16   u2g_lin_slot27:1;
            l_u16   u2g_lin_slot26:1;
            l_u16   u2g_lin_slot25:1;
            l_u16   u2g_lin_slot24:1;
            l_u16   u2g_lin_slot23:1;
            l_u16   u2g_lin_slot22:1;
            l_u16   u2g_lin_slot21:1;
            l_u16   u2g_lin_slot20:1;
            l_u16   u2g_lin_slot19:1;
            l_u16   u2g_lin_slot18:1;
            l_u16   u2g_lin_slot17:1;
        } st_bit;
    } un_rs_flg2;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot48:1;
            l_u16   u2g_lin_slot47:1;
            l_u16   u2g_lin_slot46:1;
            l_u16   u2g_lin_slot45:1;
            l_u16   u2g_lin_slot44:1;
            l_u16   u2g_lin_slot43:1;
            l_u16   u2g_lin_slot42:1;
            l_u16   u2g_lin_slot41:1;
            l_u16   u2g_lin_slot40:1;
            l_u16   u2g_lin_slot39:1;
            l_u16   u2g_lin_slot38:1;
            l_u16   u2g_lin_slot37:1;
            l_u16   u2g_lin_slot36:1;
            l_u16   u2g_lin_slot35:1;
            l_u16   u2g_lin_slot34:1;
            l_u16   u2g_lin_slot33:1;
        } st_bit;
    } un_rs_flg3;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot64:1;
            l_u16   u2g_lin_slot63:1;
            l_u16   u2g_lin_slot62:1;
            l_u16   u2g_lin_slot61:1;
            l_u16   u2g_lin_slot60:1;
            l_u16   u2g_lin_slot59:1;
            l_u16   u2g_lin_slot58:1;
            l_u16   u2g_lin_slot57:1;
            l_u16   u2g_lin_slot56:1;
            l_u16   u2g_lin_slot55:1;
            l_u16   u2g_lin_slot54:1;
            l_u16   u2g_lin_slot53:1;
            l_u16   u2g_lin_slot52:1;
            l_u16   u2g_lin_slot51:1;
            l_u16   u2g_lin_slot50:1;
            l_u16   u2g_lin_slot49:1;
        } st_bit;
    } un_rs_flg4;
} st_lin_state_type;


/* LINフレームバッファの定義 */
typedef struct {
    un_lin_data_type  xng_lin_data;
    union {
       l_u16    u2g_lin_word;
        struct {
            l_u16   reserve2:4;
            l_u16   u2g_lin_err:4;
            l_u16   reserve1:8;
        } st_err;
        struct {
            l_u16   u2g_lin_no_use:1;
            l_u16   reserve:3;
            l_u16   u2g_lin_e_sum:1;
            l_u16   u2g_lin_e_bit:1;
            l_u16   u2g_lin_e_uart:1;
            l_u16   u2g_lin_e_nores:1;
            l_u16   u2g_lin_chksum:8;
        } st_bit;
    } un_state;
} st_lin_buf_type;


/* LIN Busステータス */
typedef union {
    l_u16  u2g_lin_word;
    struct {
        l_u16  u2g_lin_last_id:8;
        l_u16  u2g_lin_head_err:1;
        l_u16  u2g_lin_bus_err:1;
        l_u16  reserve:2;
        l_u16  u2g_lin_goto_sleep:1;
        l_u16  u2g_lin_ovr_run:1;
        l_u16  u2g_lin_ok_resp:1;
        l_u16  u2g_lin_err_resp:1;
    } st_bit;
} un_lin_bus_status_type;

#endif
/*=============== エンディアンタイプによるコンパイルスイッチの終了 ===============*/

/* LIN スロット情報テーブルの定義 */
typedef struct {
    l_u8    u1g_lin_id;                 /* ID(00h～3Fh) */
    l_u8    u1g_lin_frm_sz;             /* DL(1～8) */
    l_u8    u1g_lin_sndrcv;             /* 0b:Snd, 1b:Rcv */
    l_u8    u1g_lin_nm_use;             /* NM有効 (0:no use 1:use) */
/* Ver 2.00 変更:意味のあるデファイン名に変更 ↓↓↓ */
/* Ver 1.01 変更:トヨタコーディングルール対応 -> start */
#if 0  /********** ↓↓↓ 削除コード ↓↓↓ **********/
    /* l_u8    u1g_lin_def[8];              デフォルト値 */
    /* l_u8    u1g_lin_fail[8];             フェールセーフ値 */
    l_u8    u1g_lin_def[U1G_LIN_8];     /* デフォルト値 */
    l_u8    u1g_lin_fail[U1G_LIN_8];    /* フェールセーフ値 */
#endif /********** ↑↑↑ 削除コード ↑↑↑ **********/
/* Ver 1.01 変更:トヨタコーディングルール対応 <- end */
    l_u8    u1g_lin_def[U1G_LIN_MAX_DL];     /* デフォルト値 */
    l_u8    u1g_lin_fail[U1G_LIN_MAX_DL];    /* フェールセーフ値 */
/* Ver 2.00 変更:意味のあるデファイン名に変更 ↑↑↑ */
} st_lin_slot_info_type;


/***** 外部参照定義 *****/
extern st_lin_state_type  xng_lin_sts_buf;
extern st_lin_buf_type  xng_lin_frm_buf[U1G_LIN_MAX_SLOT];
extern un_lin_bus_status_type  xng_lin_bus_sts;
extern l_u8  u1g_lin_nm_info;
extern l_u8  u1g_lin_syserr;                        /* システム異常フラグ */

extern const l_u8   u1g_lin_id_tbl[ U1G_LIN_MAX_SLOT_NUM ];
extern const l_u8   u1g_lin_protid_tbl[ U1G_LIN_MAX_SLOT_NUM ];
extern const l_u16  u2g_lin_flg_set_tbl[ U1G_LIN_WORD_BIT ];
extern const l_u16  u2g_lin_flg_clr_tbl[ U1G_LIN_WORD_BIT ];
extern const st_lin_slot_info_type  xng_lin_slot_tbl[ U1G_LIN_MAX_SLOT ];

#endif

/***** End of File *****/



/*""FILE COMMENT""*************************************************************
 * System Name  : S/R System
 * File Name    : p_comdwn_tmr.c
 * Contests     : LIN通信途絶検出タイマ
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2004.07.15
 *""FILE COMMENT END""*********************************************************/

#pragma	section	lin

/******************************************************************************/
/* Header File Include 														  */
/******************************************************************************/

#include "f_tmr.h"
#include "p_comdwn_tmr.h"

/******************************************************************************/
/* Definition 																  */
/******************************************************************************/

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報①通信途絶タイマクリア
 *-----------------------------------------------------------------------------
 * 宣言            : void p_vog_start_id28_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報①通信途絶タイマのクリア処理
 *-----------------------------------------------------------------------------
 * 引数            : U1G_TMR_HDR_COMDWN_ID28
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_vog_tmr_clr(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
void p_vog_tmr_start_id28_cmdwn( void )
{
	f_vog_tmr_clr(U1G_TMR_HDR_COMDWN_ID28);
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報②通信途絶タイマクリア
 *-----------------------------------------------------------------------------
 * 宣言            : void p_vog_start_id29_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報②通信途絶タイマのクリア処理
 *-----------------------------------------------------------------------------
 * 引数            : U1G_TMR_HDR_COMDWN_ID29
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_vog_tmr_clr(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : - 
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
void p_vog_tmr_start_id29_cmdwn( void )
{
	f_vog_tmr_clr(U1G_TMR_HDR_COMDWN_ID29);
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報③通信途絶タイマクリア
 *-----------------------------------------------------------------------------
 * 宣言            : void p_vog_start_id2a_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報③通信途絶タイマのクリア処理
 *-----------------------------------------------------------------------------
 * 引数            : U1G_TMR_HDR_COMDWN_ID2A
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_vog_tmr_clr(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
void p_vog_tmr_start_id2a_cmdwn( void )
{
	f_vog_tmr_clr(U1G_TMR_HDR_COMDWN_ID2A);
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報④通信途絶タイマクリア
 *-----------------------------------------------------------------------------
 * 宣言            : void p_vog_start_id22_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報④通信途絶タイマのクリア処理
 *-----------------------------------------------------------------------------
 * 引数            : U1G_TMR_HDR_COMDWN_ID22
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_vog_tmr_clr(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
void p_vog_tmr_start_id22_cmdwn( void )
{
	f_vog_tmr_clr(U1G_TMR_HDR_COMDWN_ID22);
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Ｐ／ＷマスタＳＷ①通信途絶タイマクリア
 *-----------------------------------------------------------------------------
 * 宣言            : void p_vog_start_id2b_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : Ｐ／ＷマスタＳＷ①通信途絶タイマのクリア処理
 *-----------------------------------------------------------------------------
 * 引数            : U1G_TMR_HDR_COMDWN_ID2B
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_vog_tmr_clr(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
void p_vog_tmr_start_id2b_cmdwn( void )
{
	f_vog_tmr_clr(U1G_TMR_HDR_COMDWN_ID2B);
}

#if 0
/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Ｄ席Ｐ／Ｗ情報①通信途絶タイマクリア
 *-----------------------------------------------------------------------------
 * 宣言            : void p_vog_start_id24_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : Ｄ席Ｐ／Ｗ情報①通信途絶タイマのクリア処理
 *-----------------------------------------------------------------------------
 * 引数            : U1G_TMR_HDR_COMDWN_ID24
 *-----------------------------------------------------------------------------
 * 戻り値          : -
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_vog_tmr_clr(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
void p_vog_tmr_start_id24_cmdwn( void )
{
	f_vog_tmr_clr(U1G_TMR_HDR_COMDWN_ID24);
}
#endif

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報①通信途絶タイマ経過判定
 *-----------------------------------------------------------------------------
 * 宣言            : u1 p_u1g_jdg_id28_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報①通信途絶タイマ経過を判定する処理
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : U1G_FLB_TRUE ：途絶判定時間経過
 * 				   : U1G_FLB_FALSE：途絶判定時間未経過
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_u2g_tmr_get(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
u1 p_u1g_tmr_jdg_id28_cmdwn( void )
{
	u1	u1a_tim_over;
	u2	u2a_comdwn_tim_now;

	u2a_comdwn_tim_now = f_u2g_tmr_get(U1G_TMR_HDR_COMDWN_ID28);
	if ( U2L_TIM_COMDWN_ID28 < u2a_comdwn_tim_now ) {
		u1a_tim_over = U1G_FLB_TRUE;
	}
	else{
		u1a_tim_over = U1G_FLB_FALSE;
	}
	return ( u1a_tim_over );
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報②通信途絶タイマ経過判定
 *-----------------------------------------------------------------------------
 * 宣言            : u1 p_u1g_jdg_id29_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報②通信途絶タイマ経過を判定する処理
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : U1G_FLB_TRUE ：途絶判定時間経過
 * 				   : U1G_FLB_FALSE：途絶判定時間未経過
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_u2g_tmr_get(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
u1 p_u1g_tmr_jdg_id29_cmdwn( void )
{
	u1	u1a_tim_over;
	u2	u2a_comdwn_tim_now;

	u2a_comdwn_tim_now = f_u2g_tmr_get(U1G_TMR_HDR_COMDWN_ID29);
	if ( U2L_TIM_COMDWN_ID29 < u2a_comdwn_tim_now ) {
		u1a_tim_over = U1G_FLB_TRUE;
	}
	else{
		u1a_tim_over = U1G_FLB_FALSE;
	}
	return ( u1a_tim_over );
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報③通信途絶タイマ経過判定
 *-----------------------------------------------------------------------------
 * 宣言            : u1 p_u1g_jdg_id2a_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報③通信途絶タイマ経過を判定する処理
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : U1G_FLB_TRUE ：途絶判定時間経過
 * 				   : U1G_FLB_FALSE：途絶判定時間未経過
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_u2g_tmr_get(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
u1 p_u1g_tmr_jdg_id2a_cmdwn( void )
{
	u1	u1a_tim_over;
	u2	u2a_comdwn_tim_now;

	u2a_comdwn_tim_now = f_u2g_tmr_get(U1G_TMR_HDR_COMDWN_ID2A);
	if ( U2L_TIM_COMDWN_ID2A < u2a_comdwn_tim_now ) {
		u1a_tim_over = U1G_FLB_TRUE;
	}
	else{
		u1a_tim_over = U1G_FLB_FALSE;
	}
	return ( u1a_tim_over );
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : ボディーＥＣＵ情報④通信途絶タイマ経過判定
 *-----------------------------------------------------------------------------
 * 宣言            : u1 p_u1g_jdg_id22_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : ボディーＥＣＵ情報④通信途絶タイマ経過を判定する処理
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : U1G_FLB_TRUE ：途絶判定時間経過
 * 				   : U1G_FLB_FALSE：途絶判定時間未経過
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_u2g_tmr_get(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
u1 p_u1g_tmr_jdg_id22_cmdwn( void )
{
	u1	u1a_tim_over;
	u2	u2a_comdwn_tim_now;

	u2a_comdwn_tim_now = f_u2g_tmr_get(U1G_TMR_HDR_COMDWN_ID22);
	if ( U2L_TIM_COMDWN_ID22 < u2a_comdwn_tim_now ) {
		u1a_tim_over = U1G_FLB_TRUE;
	}
	else{
		u1a_tim_over = U1G_FLB_FALSE;
	}
	return ( u1a_tim_over );
}

/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Ｐ／ＷマスタＳＷ①通信途絶タイマ経過判定経
 *-----------------------------------------------------------------------------
 * 宣言            : u1 p_u1g_jdg_id2b_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : Ｐ／ＷマスタＳＷ①通信途絶タイマ経過を判定する処理
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : U1G_FLB_TRUE ：途絶判定時間経過
 * 				   : U1G_FLB_FALSE：途絶判定時間未経過
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_u2g_tmr_get(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
u1 p_u1g_tmr_jdg_id2b_cmdwn( void )
{
	u1	u1a_tim_over;
	u2	u2a_comdwn_tim_now;

	u2a_comdwn_tim_now = f_u2g_tmr_get(U1G_TMR_HDR_COMDWN_ID2B);
	if ( U2L_TIM_COMDWN_ID2B < u2a_comdwn_tim_now ) {
		u1a_tim_over = U1G_FLB_TRUE;
	}
	else{
		u1a_tim_over = U1G_FLB_FALSE;
	}
	return ( u1a_tim_over );
}

#if 0
/*""FUNC COMMENT""*************************************************************
 * ID              :
 * モジュール概要  : Ｄ席Ｐ／Ｗ情報①通信途絶タイマ経過判定
 *-----------------------------------------------------------------------------
 * 宣言            : u1 p_u1g_jdg_id24_cmdwn_tmr( void )
 *-----------------------------------------------------------------------------
 * 機能            : Ｄ席Ｐ／Ｗ情報①通信途絶タイマ経過を判定する処理
 *-----------------------------------------------------------------------------
 * 引数            : -
 *-----------------------------------------------------------------------------
 * 戻り値          : U1G_FLB_TRUE ：途絶判定時間経過
 * 				   : U1G_FLB_FALSE：途絶判定時間未経過
 *-----------------------------------------------------------------------------
 * 入力            : -
 * 出力            : -
 *-----------------------------------------------------------------------------
 * 使用関数        : f_u2g_tmr_get(タイマハンドラＮｏ)
 *-----------------------------------------------------------------------------
 * 注意事項        : -
 *-----------------------------------------------------------------------------
 * History         : 2004.09.18
 *""FUNC COMMENT END""*********************************************************/
u1 p_u1g_tmr_jdg_id24_cmdwn( void )
{
	u1	u1a_tim_over;
	u2	u2a_comdwn_tim_now;

	u2a_comdwn_tim_now = f_u2g_tmr_get(U1G_TMR_HDR_COMDWN_ID24);
	if ( U2L_TIM_COMDWN_ID24 < u2a_comdwn_tim_now ) {
		u1a_tim_over = U1G_FLB_TRUE;
	}
	else{
		u1a_tim_over = U1G_FLB_FALSE;
	}
	return ( u1a_tim_over );
}
#endif

/*--- end of file --- */


/*""FILE COMMENT""*************************************************************
 * System Name  : S/R system
 * File Name    : p_comdwn_tmr.h
 * Contests     : LIN通信途絶検出タイマ
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2004.07.15
 *""FILE COMMENT END""*********************************************************/

#ifndef P_COMDWN_TIM_H
#define P_COMDWN_TIM_H

/******************************************************************************
 * Header File Include
 ******************************************************************************/
#include "l_stddef.h"

/******************************************************************************
 * Definition section
 ******************************************************************************/
#define	U2L_TIM_COMDWN_ID28		( (u2)(120u) )
#define	U2L_TIM_COMDWN_ID29		( (u2)(1200u) )
#define	U2L_TIM_COMDWN_ID2A		( (u2)(1200u) )
#define	U2L_TIM_COMDWN_ID22		( (u2)(1200u) )
#define	U2L_TIM_COMDWN_ID2B		( (u2)(1200u) )
#define	U2L_TIM_COMDWN_ID24		( (u2)(1200u) )


/******************************************************************************
 * declaretion section
 ******************************************************************************/
void p_vog_tmr_start_id28_cmdwn( void );
void p_vog_tmr_start_id29_cmdwn( void );
void p_vog_tmr_start_id2a_cmdwn( void );
void p_vog_tmr_start_id22_cmdwn( void );
void p_vog_tmr_start_id2b_cmdwn( void );
void p_vog_tmr_start_id24_cmdwn( void );

u1 p_u1g_tmr_jdg_id28_cmdwn( void );
u1 p_u1g_tmr_jdg_id29_cmdwn( void );
u1 p_u1g_tmr_jdg_id2a_cmdwn( void );
u1 p_u1g_tmr_jdg_id22_cmdwn( void );
u1 p_u1g_tmr_jdg_id2b_cmdwn( void );
u1 p_u1g_tmr_jdg_id24_cmdwn( void );

#endif /* P_COMDWN_TIM_H */

/*--- end of file ---*/



/*""FILE COMMENT""*************************************************************
 * System Name  : S/R System
 * File Name    : p_get_msg_lin.c
 * Contests     : 
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2003.11.28
 *""FILE COMMENT END""*********************************************************/

#pragma	section	lin

/******************************************************************************/
/* Header File Include 														  */
/******************************************************************************/
#include "f_main.h"
#include "p_lin_apl.h"
#include "f_lin_if.h"
#include "p_get_msg_lin.h"

/******************************************************************************
 * declaretion section
 ******************************************************************************/
xn_lin_rx_com_sts_t 	xng_lin_rx_com_sts;
xn_lin_rx_com_fst_t		xng_lin_rx_com_fst;
xn_lin_info_sig_t		xng_lin_info_sig;
xn_lin_info_rmt_t	 	xng_lin_info_rmt;
xn_lin_info_cmt_t 		xng_lin_info_cmt;
xn_lin_info_mst_t 		xng_lin_info_mst;
xn_lin_info_spd_t 		xng_lin_info_spd;

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ信号情報データ取得								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_info_get_msg( xn_lin_info_sig_t * )		  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮから必要な信号情報データを取得する				  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_info_sig_t * 									  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_info_get_msg( xn_lin_info_sig_t * xna_lin_info_sig )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_info_sig->xn_lin_sig = xng_lin_info_sig.xn_lin_sig;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮリモート信号データ取得							  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_rmt_get_msg( xn_lin_rx_com_fst_t * ）	  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮのリモート信号データを取得する					  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_rx_rmt_t *										  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_rmt_get_msg( xn_lin_info_rmt_t * xna_lin_info_rmt )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_info_rmt->xn_lin_rmt = xng_lin_info_rmt.xn_lin_rmt;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ通信状態データ取得１								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_sts_get_msg( xn_lin_rx_com_sts_t * )	  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮの通信状態を取得する(途絶状態）					  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_rx_com_sts_t * 						  			  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_sts_get_msg( xn_lin_rx_com_sts_t * xna_lin_rx_com_sts )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_rx_com_sts->xn_rx_com_sts = xng_lin_rx_com_sts.xn_rx_com_sts;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ通信状態データ取得２								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_fst_get_msg( xn_lin_rx_com_fst_t * ）	  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮの通信状態を取得する(データ受信状態）			  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_rx_com_fst_t *									  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_fst_get_msg( xn_lin_rx_com_fst_t * xna_lin_rx_com_fst )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_rx_com_fst->xn_rx_com_fst = xng_lin_rx_com_fst.xn_rx_com_fst;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ通信状態データ取得３								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_cmt_get_msg( xn_lin_info_cmt_t * ）		  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮの仕向け情報を取得する					  		  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_info_cmt_t *									  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_cmt_get_msg( xn_lin_info_cmt_t * xna_lin_info_cmt )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_info_cmt->u1_lin_cmt = xng_lin_info_cmt.u1_lin_cmt;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ通信状態データ取得４								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_spd_get_msg( xn_lin_info_spd_t * ）		  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮの速度情報を取得する						  		  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_info_spd_t *									  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_spd_get_msg( xn_lin_info_spd_t * xna_lin_info_spd )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_info_spd->u1_lin_spd = xng_lin_info_spd.u1_lin_spd;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}

/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ通信状態データ取得６								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_mst_get_msg( xn_lin_info_cstm_t * ）	  */
/*----------------------------------------------------------------------------*/
/* 機能            : マスタＳＷの信号情報を取得する					  		  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_lin_info_mst_t *									  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_mst_get_msg( xn_lin_info_mst_t * xna_lin_info_mst )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_lin_info_mst->xn_lin_mst = xng_lin_info_mst.xn_lin_mst;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}
#if 0
/*""FUNC COMMENT""*************************************************************/
/* id              :														  */
/* モジュール概要  : ＬＩＮ ＤＩＡＧデータ取得								  */
/*----------------------------------------------------------------------------*/
/* 宣言            : void p_vog_lin_diag_get_msg( xn_diag_rx_dat_t * )		  */
/*----------------------------------------------------------------------------*/
/* 機能            : ＬＩＮからＤＩＡＧデータを取得する				  		  */
/*                 : 														  */
/*----------------------------------------------------------------------------*/
/* 引数            : xn_diag_rx_dat_t *										  */
/*----------------------------------------------------------------------------*/
/* 戻り値          : non													  */
/*----------------------------------------------------------------------------*/
/* 入力            : -														  */
/* 出力            : -														  */
/*----------------------------------------------------------------------------*/
/* 使用関数        : f_vog_dis_dsp(),f_vog_ena_dsp()						  */
/*----------------------------------------------------------------------------*/
/* 注意事項        : 														  */
/*----------------------------------------------------------------------------*/
/* history         : 2004.09.13												  */
/*""FUNC COMMENT END""*********************************************************/
void p_vog_lin_diag_get_msg( xn_diag_rx_dat_t * xna_diag_dat )
{
	/*--- 前処理 ---*/
	f_vog_dis_dsp();
	/*--- データ取得 ---*/
	xna_diag_dat->u1_rx_byte[0] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_0;
	xna_diag_dat->u1_rx_byte[1] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_1;
	xna_diag_dat->u1_rx_byte[2] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_2;
	xna_diag_dat->u1_rx_byte[3] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_3;
	xna_diag_dat->u1_rx_byte[4] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_4;
	xna_diag_dat->u1_rx_byte[5] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_5;
	xna_diag_dat->u1_rx_byte[6] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_6;
	xna_diag_dat->u1_rx_byte[7] = xng_diag_rx_dat.xn_dat_diag.u1_rx_data_7;
	/*--- 後処理 ---*/
	f_vog_ena_dsp();
}
#endif

//***** End of File *****/



/*""FILE COMMENT""*************************************************************
 * System Name  : S/R system
 * File Name    : p_get_msg_lin.h
 * Contests     : LIN通信データ取得
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 5.0.1
 * OS           : no used
 * Note         :
 ******************************************************************************
 *                                      Copyright(c) AISIN SEIKI CO.,LTD.
 ******************************************************************************
 * History      : 2004.09.20
 *""FILE COMMENT END""*********************************************************/

#ifndef P_GET_MSG_LIN_H
#define P_GET_MSG_LIN_H

/******************************************************************************
 * Header File Include
 ******************************************************************************/
#include "l_stddef.h"
#include "p_lin_apl.h"

/******************************************************************************
 * Definition section
 ******************************************************************************/


/******************************************************************************
 * declaretion section
 ******************************************************************************/


/****************************************************************************/
/* Prototype declaration section										 	*/
/****************************************************************************/
void p_vog_lin_info_get_msg( xn_lin_info_sig_t * );
void p_vog_lin_rmt_get_msg( xn_lin_info_rmt_t * );
void p_vog_lin_sts_get_msg( xn_lin_rx_com_sts_t * );
void p_vog_lin_fst_get_msg( xn_lin_rx_com_fst_t * );
void p_vog_lin_cmt_get_msg( xn_lin_info_cmt_t * );
void p_vog_lin_mst_get_msg( xn_lin_info_mst_t * );
void p_vog_lin_spd_get_msg( xn_lin_info_spd_t * );

#endif /* P_GET_MSG_LIN_H */

/*--- end of file ---*/




/*""FILE COMMENT""**********************************************
 * System Name  : S/R System
 * File Name    : p_lin_apl.h
 * Contests     : LIN通信処理
 * Model        : SRF汎用
 * Order        : Project No 
 * CPU          : Renesas H8/300H Tiny Series
 * Compiler     : Renesas H8S,H8/300 Series C/C++ Compiler Ver 4.0.03
 * OS           : no used
 * Note         : LIN通信のアプリケーション部
 ***************************************************************
 *                          Copyright(c) AISIN SEIKI CO.,LTD.
 ***************************************************************
 * History      : 2004.09.16
 *""FILE COMMENT END""*****************************************/
 
#ifndef P_LIN_APL_H
#define P_LIN_APL_H

#include	"l_stddef.h"

#define U1G_ARY_0	( (u1)(0u) )
#define U1G_ARY_1	( (u1)(1u) )
#define U1G_ARY_2	( (u1)(2u) )
#define U1G_ARY_3	( (u1)(3u) )
#define U1G_ARY_4	( (u1)(4u) )
#define U1G_ARY_5	( (u1)(5u) )
#define U1G_ARY_6	( (u1)(6u) )
#define U1G_ARY_7	( (u1)(7u) )
#define U1G_ARY_8	( (u1)(8u) )

#define	U1G_DIAG_MAX_21	( (u1)(3u) )

/*------ 仕向分類 --------------------------------*/
#define U1G_DEST_USA		( (u1)(0u) )	/* 北米仕向	*/
#define U1G_DEST_JPN		( (u1)(1u) )	/* 国内仕向	*/
#define U1G_DEST_EUR		( (u1)(2u) )	/* 欧州仕向	*/
#define U1G_DEST_AUS		( (u1)(3u) )	/* 豪州仕向	*/

/*------ 車両型式ハンドル ------------------------*/
#define U1G_HANDLE_MSK		( (u1)(0xc0u) )	/* ﾊﾝﾄﾞﾙ情報ﾏｽｸﾃﾞｰﾀ	*/
#define U1G_HANDLE_LEFT		( (u1)(0x40u) )	/* 左ﾊﾝﾄﾞﾙ($01)		*/
#define U1G_HANDLE_RIGHT	( (u1)(0x80u) )	/* 右ﾊﾝﾄﾞﾙ($10)		*/

/*------ 仕向けコード ----------------------------*/
/*------ 日本/欧州 -------*/
#define U1G_CMT_JPN	( (u1)(0x00u) )	/* 市販	*/
#define U1G_CMT_EUR	( (u1)(0x57u) ) /* 欧州 */
#define U1G_CMT_MNE	( (u1)(0x56u) ) /* 中近東 */
#define U1G_CMT_CHN	( (u1)(0x43u) ) /* 中国 */
#define U1G_CMT_GEN	( (u1)(0xF0u) ) /* 一般輸 */
#define U1G_CMT_AUS	( (u1)(0x51u) ) /* 豪州 */
/*------ 北米 ------------*/
#define U1G_CMT_USA	( (u1)(0x41u) ) /* 北米 */
#define U1G_CMT_NON	( (u1)(0xFFu) ) /* 不定 */

/*------  ノードコード(ダイアグ用) ----------------*/
#define U1G_CODE_N_TA	( (u1)(0xadu) )

/* TAG		: xn_lin_rx_com_sts_t		*/
/* ABSTRACT	: 通信途絶状態共用体	*/
/* NOTE		: 各フレームの受信途絶状態を設定する			*/
typedef union {
	u1	u1_lin_com_sts;			/* バイトアクセスタグ	*/
	struct	{
       u1 u1_flb_comdwn_bod1s01	:1;		/* ボディーECU情報①通信途絶	*/
       u1 u1_flb_comdwn_bod1s02	:1;		/* ボディーECU情報②通信途絶	*/
       u1 u1_flb_comdwn_bod1s03 :1;		/* ボディーECU情報③通信途絶	*/
       u1 u1_flb_comdwn_bod1s04	:1;		/* ボディーECU情報④通信途絶	*/

       u1 u1_flb_comdwn_msw1s01	:1;		/* Ｐ／ＷマスタＳＷ①通信途絶	*/
       u1 u1_flb_comdwn_dpw1s01 :1;    	/* Ｄ席Ｐ／Ｗ情報①通信途絶  	*/
       u1 reserve1  			:1;    	/* リザーブ     				*/
       u1 u1_flb_comdwn_diag  	:1;    	/* ダイアグ要求通信途絶			*/
    }xn_rx_com_sts;					/* ビットアクセスタグ */
}xn_lin_rx_com_sts_t;


/* TAG		: xn_lin_rx_com_fst_t		*/
/* ABSTRACT	: フレーム受信状態共用体	*/
/* NOTE		: 各フレームの受信状態を設定する			*/
typedef union {
	u1	u1_lin_com_fst;			/* バイトアクセスタグ	*/
	struct	{
       u1 u1_flb_id28_first_rx 	:1;    	/* ID28初回受信	*/
       u1 u1_flb_id29_first_rx 	:1;    	/* ID29初回受信	*/
       u1 u1_flb_id2a_first_rx 	:1;    	/* ID2a初回受信	*/
       u1 u1_flb_id22_first_rx 	:1;    	/* ID22初回受信	*/

       u1 u1_flb_id2b_first_rx 	:1;    	/* ID2b初回受信	*/
       u1 u1_flb_id24_first_rx 	:1;    	/* ID24初回受信	*/
       u1 reserve1  			:1;    	/* リザーブ     */
       u1 reserve2  			:1;    	/* リザーブ     */
    }xn_rx_com_fst;					/* ビットアクセスタグ */
}xn_lin_rx_com_fst_t;


/* TAG		: xn_lin_info_rmt_t		*/
/* ABSTRACT	: リモート信号情報共用体	*/
/* NOTE		: 各リモート信号の状態を設定する			*/
typedef union {
	u1	u1_lin_info_rmt;		/* バイトアクセスタグ	*/
	struct	{
	   u1 reserved1	 		:1;			/* リザーブ						*/
	   u1 reserved2	 		:1;			/* リザーブ						*/
	   u1 u1_flb_kpwu		:1;    		/* キー連動Ｐ／Ｗ ＵＰ信号 		*/
	   u1 u1_flb_kpwd		:1;   		/* キー連動Ｐ／Ｗ ＤＯＷＮＵＰ信号 */

	   u1 u1_flb_wpwu		:1;    		/* ワイアレス連動Ｐ／Ｗ ＵＰ信号 */
	   u1 u1_flb_wpwd		:1;    		/* ワイアレス連動Ｐ／Ｗ ＤＯＷＮ信号 */
	   u1 u1_flb_spwu		:1;    		/* スマート連動Ｐ／Ｗ ＵＰ信号	*/
	   u1 reserved3	 		:1;			/* リザーブ						*/
	} xn_lin_rmt;					/* ビットアクセスタグ */
}xn_lin_info_rmt_t;


/* TAG		: xn_lin_info_sig_t		*/
/* ABSTRACT	: ＳＷ信号情報共用体	*/
/* NOTE		: 各ＳＷ信号の状態を設定する			*/
typedef union {
	u1	u1_lin_sig_info;		/* バイトアクセスタグ	*/
	struct	{
	   u1 u1_flb_pws  	 	:1;			/* Ｐ／Ｗ作動許可信号 			*/
	   u1 u1_flb_ig   	 	:1;			/* ボディーＥＣＵ ＩＧ ＳＷ信号 */
	   u1 u1_flb_dcty     	:1;			/* Ｄ席カーテシＳＷ信号			*/
	   u1 reserved1	 		:1;			/* リザーブ						*/

	   u1 reserved2	 		:1;			/* リザーブ						*/
	   u1 reserved3	 		:1;			/* リザーブ						*/
	   u1 reserved4	 		:1;			/* リザーブ						*/
	   u1 reserved5			:1;			/* リザーブ						*/
	} xn_lin_sig;					/* ビットアクセスタグ */
}xn_lin_info_sig_t;


/* TAG		: xn_lin_info_cmt_t		*/
/* ABSTRACT	: 仕向け情報構造体		*/
/* NOTE		: 						*/
typedef struct
{
	u1	u1_lin_cmt;
}xn_lin_info_cmt_t;


/* TAG		: xn_lin_info_spd_t		*/
/* ABSTRACT	: 車速情報構造体		*/
/* NOTE		: 						*/
typedef struct
{
	u1	u1_lin_spd;
}xn_lin_info_spd_t;

#if 0
/* TAG		: xn_lin_info_ctm_t			*/
/* ABSTRACT	: カスタマイズ情報共用体	*/
/* NOTE		: 各カスタマイズ信号の状態を設定する		*/
typedef union {
	u1	u1_lin_info_cstm;		/* バイトアクセスタグ	*/
	struct	{
       u1 u1_flb_kupc 	 	:1;			/* カスタマイズ情報(キー連動Ｐ／Ｗ ＵＰ有無)	*/
       u1 u1_flb_kdnc 	 	:1;			/* カスタマイズ情報(キー連動Ｐ／Ｗ ＤＮ有無)	*/
	   u1 u1_flb_jpc	 	:1;			/* カスタマイズ情報(挟み込み防止ロジック)		*/
	   u1 u1_flb_wupc	 	:1;			/* カスタマイズ情報(ワイアレス連動Ｐ／Ｗ ＵＰ有無)	*/

	   u1 u1_flb_wdnc	 	:1;			/* カスタマイズ情報(ワイアレス連動Ｐ／Ｗ ＤＮ有無)	*/
	   u1 u1_flb_supc	 	:1;			/* カスタマイズ情報(スマート連動Ｐ／Ｗ ＵＰ有無)*/
	   u1 reserved1	 		:1;			/* リザーブ			*/
	   u1 reserved2	 		:1;			/* リザーブ			*/
	} xn_lin_cstm;					/* ビットアクセスタグ */
}xn_lin_info_cstm_t;
#endif

/* TAG		: xn_lin_info_mst_t		*/
/* ABSTRACT	: マスタＳＷ情報共用体	*/
/* NOTE		: マスタＳＷ信号の状態を設定する		*/
typedef union {
	u1	u1_lin_info_mst;	/* バイトアクセスタグ	*/
	struct	{
       u1 u1_flb_wl	 	 	:1;		/* マスタＳＷ情報	*/
	   u1 reserved1			:1;		/* リザーブ			*/
	   u1 reserved2			:1;		/* リザーブ			*/
	   u1 reserved3	 		:1;		/* リザーブ			*/

	   u1 reserved4			:4;		/* リザーブ			*/
	} xn_lin_mst;				/* ビットアクセスタグ */
}xn_lin_info_mst_t;

/*------ 受信情報 ------------------------*/
extern	xn_lin_rx_com_sts_t 	xng_lin_rx_com_sts;
extern	xn_lin_rx_com_fst_t		xng_lin_rx_com_fst;
extern	xn_lin_info_sig_t		xng_lin_info_sig;
extern  xn_lin_info_rmt_t 		xng_lin_info_rmt;
extern  xn_lin_info_cmt_t 		xng_lin_info_cmt;
extern  xn_lin_info_mst_t 		xng_lin_info_mst;
extern  xn_lin_info_spd_t 		xng_lin_info_spd;
#if 0
extern  xn_lin_info_cstm_t 		xng_lin_info_cstm;
#endif

#define	F_comdwn_01		xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_bod1s01
#define	F_comdwn_02		xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_bod1s02
#define	F_comdwn_03		xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_bod1s03
#define	F_comdwn_04		xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_bod1s04
#define	F_comdwn_05		xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_msw1s01
#define	F_comdwn_06		xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_dpw1s01

#define	F_comdwn_diag	xng_lin_rx_com_sts.xn_rx_com_sts.u1_flb_comdwn_diag

#define	F_id28_first	xng_lin_rx_com_fst.xn_rx_com_fst.u1_flb_id28_first_rx
#define	F_id29_first	xng_lin_rx_com_fst.xn_rx_com_fst.u1_flb_id29_first_rx
#define	F_id2a_first	xng_lin_rx_com_fst.xn_rx_com_fst.u1_flb_id2a_first_rx
#define	F_id22_first	xng_lin_rx_com_fst.xn_rx_com_fst.u1_flb_id22_first_rx
#define	F_id2b_first	xng_lin_rx_com_fst.xn_rx_com_fst.u1_flb_id2b_first_rx
#define	F_id24_first	xng_lin_rx_com_fst.xn_rx_com_fst.u1_flb_id24_first_rx

#define F_lin_ig		xng_lin_info_sig.xn_lin_sig.u1_flb_ig
#define F_lin_pws		xng_lin_info_sig.xn_lin_sig.u1_flb_pws
#define F_lin_dcty		xng_lin_info_sig.xn_lin_sig.u1_flb_dcty

#define F_lin_kpwu		xng_lin_info_rmt.xn_lin_rmt.u1_flb_kpwu
#define F_lin_kpwd		xng_lin_info_rmt.xn_lin_rmt.u1_flb_kpwd
#define F_lin_wpwu		xng_lin_info_rmt.xn_lin_rmt.u1_flb_wpwu
#define F_lin_wpwd		xng_lin_info_rmt.xn_lin_rmt.u1_flb_wpwd
#define F_lin_spwu		xng_lin_info_rmt.xn_lin_rmt.u1_flb_spwu

#define F_lin_kupc		xng_lin_info_cstm.xn_lin_cstm.u1_flb_kupc
#define F_lin_kdnc		xng_lin_info_cstm.xn_lin_cstm.u1_flb_kdnc
#define F_lin_jpc		xng_lin_info_cstm.xn_lin_cstm.u1_flb_jpc
#define F_lin_wupc		xng_lin_info_cstm.xn_lin_cstm.u1_flb_wupc
#define F_lin_wdnc		xng_lin_info_cstm.xn_lin_cstm.u1_flb_wdnc
#define F_lin_supc		xng_lin_info_cstm.xn_lin_cstm.u1_flb_supc

#define F_lin_wl		xng_lin_info_mst.xn_lin_mst.u1_flb_wl

#define U1g_lin_cmt		xng_lin_info_cmt.u1_lin_cmt
#define U1g_lin_spd		xng_lin_info_spd.u1_lin_spd

#endif /* P_LIN_APL_H */

/* End of p_lin_apl.h ***************************************/



