<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>CC23x0R5DriverLibrary: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CC23x0R5DriverLibrary
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro_intro">Introduction</a></li>
<li class="level1"><a href="#intro_source_code">Source Code Overview</a></li>
<li class="level1"><a href="#intro_precompile">Pre-compiled Driver Library</a></li>
<li class="level1"><a href="#prog_model_intro">Programming Model</a><ul><li class="level2"><a href="#prog_model_direct">Direct Register Access Model</a></li>
<li class="level2"><a href="#prog_model_software">Software Driver Model</a></li>
<li class="level2"><a href="#prog_model_combine">Combining the Models</a></li>
</ul>
</li>
<li class="level1"><a href="#hapi">HAPI Functions</a></li>
<li class="level1"><a href="#error">Error Checking</a></li>
<li class="level1"><a href="#setup">Device Setup</a></li>
<li class="level1"><a href="#ccfg">Customer Configuration (CCFG)</a></li>
<li class="level1"><a href="#rtos">RTOS (Real-Time Operating System)</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro_intro"></a>
Introduction</h1>
<p>The CC23x0R5 Driver Library from Texas Instruments&reg;&#160; (also referred to as "DriverLib") is a set of low-level drivers for accessing the registers found on the CC23x0R5 family of ARM&reg;&#160;Cortex&trade;-M based devices. The DriverLib functions are grouped in APIs based on either specific on-chip peripheral module (e.g. SPI, UART, etc ) or more general functionality (e.g. system control, oscillator settings, etc). Each API uses a unique pre-fix for all the DriverLib functions in that API to indicate which module or type of functionality being accessed (with a few exceptions).</p>
<p>A few things to note about DriverLib:</p><ul>
<li>The functions are written entirely in C language except where absolutely not possible.</li>
<li>The functions are not necessarily the most efficient way to perform a given task from a code size and/or execution speed point of view. Some functions, typically used for configuration/initialization, prioritize usability and might perform a few run-time checks which are not essential for a given application. However, DriverLib functions are relatively small thus optimization potential of individual functions is limited.</li>
<li>The functions do not always support the full capabilities of the hardware. Some of the peripherals provide complex capabilities which cannot be used by the DriverLib.</li>
<li>The APIs have a means of removing all error-checking code. Because the error checking is usually useful only during initial program development, it can be removed to significantly reduce code size and increase speed.</li>
</ul>
<p>For most applications the drivers can be used as is. But in some cases the drivers must be enhanced or rewritten to meet the functionality, memory, or processing requirements of the application. If so, the existing driver can be used as a reference on how to operate the peripheral.</p>
<h1><a class="anchor" id="intro_source_code"></a>
Source Code Overview</h1>
<p>A brief overview of the organization of the driver library source code follows:</p>
<p>driverlib/</p><ul>
<li>This directory contains the source code for the drivers. The API of each module consists of a .c file and a .h file.</li>
</ul>
<p>inc/</p><ul>
<li>This directory contains the header files used for the direct register access programming model. The hw_*.h header files, one per peripheral, describe all the registers and the bit fields within those registers for each peripheral. These header files are used by the drivers to directly access a peripheral, and can be used by application code to bypass the driver library API if necessary.</li>
</ul>
<p>Currently, DriverLib source code supports the following toolchains:</p><ul>
<li>TICLANG</li>
<li>IAR</li>
<li>GCC</li>
</ul>
<h1><a class="anchor" id="intro_precompile"></a>
Pre-compiled Driver Library</h1>
<p>Besides the source code for the driver library, Texas Instruments also provides pre-compiled libraries of the driver library. These libraries are found in driverlib/lib/.</p>
<p>Currently, pre-compiled libraries are provided for the following toolchains:</p><ul>
<li>TICLANG</li>
<li>IAR</li>
<li>GCC</li>
</ul>
<h1><a class="anchor" id="prog_model_intro"></a>
Programming Model</h1>
<p>DriverLib provides support for two programming models:</p><ul>
<li>Direct register access model: Access registers and bit fields directly.</li>
<li>Software driver model: Use the provided APIs to indirectly access registers and bit fields.</li>
</ul>
<p>Each model can be used independently or combined, based on the needs of the application or the programming environment desired by the developer.</p>
<p>Each programming model has advantages and disadvantages. Use of the direct register access model generally results in smaller and more efficient code than using the software driver model. However, the direct register access model requires detailed knowledge of the operation of each register and bit field, as well as their interactions and any sequencing required for proper operation of the peripheral; the software driver model insulates the developer from these details, thus generally requiring less time to develop applications.</p>
<h2><a class="anchor" id="prog_model_direct"></a>
Direct Register Access Model</h2>
<p>In the direct register access model, the peripherals are programmed by the application by writing values directly into the registers in the peripheral. A set of defines, that simplify this process, is provided.</p>
<p>These defines are located in the <code>inc/</code> directory and there is a single <code>hw_&lt;module&gt;.h</code> header file for each peripheral type. For example, the defines for UART are located in the <code>hw_uart.h</code> header file.</p>
<p>The defines used by the direct register access model follow a naming convention that makes it easier to know how to use a particular macro. The rules are as follows:</p>
<ul>
<li>All register name macros start with the module name (for example, <code>UART</code> for the UART module) and are followed by the name of the register as it appears in the data sheet.</li>
<li>The register defines are offset values relative to the base address of a peripheral instance. If an offset is used, this will be identified in the register name using <code>_O_</code> (for example, the UART <code>CTL</code> register in the data sheet results in <code>UART_O_CTL</code>). The base address of each peripheral is defined in the memory map header file, <code>hw_memmap.h</code>, located in the <code>inc/</code> directory.</li>
<li>All register defines for a given peripheral are listed in the first section of the corresponding header file (for example, in the first section of the <code>hw_uart.h</code> file for the UART registers).</li>
<li>All register bit fields start with the module name, followed by the register name, and then followed by the bit field name as it appears in the data sheet. For example, the <code>UARTEN</code> bit field in the <code>CTL</code> register in the <code>UART</code> module is identified by <code>UART_CTL_UARTEN</code>.</li>
<li>Defines that end in <code>_M</code> represent the mask for a bit field in a register.</li>
<li>Defines that end in <code>_S</code> represent the number of bits to shift a value in order to align it with a bit field.</li>
<li>Defines that end in <code>_W</code> represent the width of the bit field.</li>
<li>If a bit field has enumerated values the enumeration names are appended to the name of the bit field define. For example, the <code>UART_LCRH_WLEN</code> bit field has a set of enumerations that specify the UART word length. E.g. the enumeration "BITL7" can be set using the define <code>UART_LCRH_WLEN_BITL7</code>. This improves readability and also helps the programmer select valid values for specific bit fields.</li>
</ul>
<p>A set of macros is provided in <code>hw_types.h</code> to use together with the register defines to read and write the corresponding addresses:</p>
<ul>
<li>HWREG(x) : Access (read or write) a full word (32 bits) at address x in the memory map.</li>
<li>HWREGH(x) : Access a halfword (16 bits) at address x in the memory map.</li>
<li>HWREGB(x) : Access a byte (8 bits) at address x in the memory map.</li>
</ul>
<p>Given these defines and macros, the <code>CTL</code> register, in the first instance of the UART peripheral (UART0), can be programmed as follows:</p>
<div class="fragment"><div class="line">HWREG(UART0_BASE + UART_O_CTL) &amp;= ~(UART_CTL_UARTEN | UART_CTL_TXE | UART_CTL_RXE);</div></div><!-- fragment --><p>Alternatively, the following has the same effect (although it is not as easy to understand):</p>
<div class="fragment"><div class="line">HWREG(UART0_BASE + UART_O_CTL) &amp;= ~(0x00000301);</div></div><!-- fragment --><p>The value of the <code>BUSY</code> field from the <code>UART_O_FR</code> register can be extracted as follows:</p>
<div class="fragment"><div class="line">isBusy = (HWREG(UART0_BASE + UART_O_FR) &amp; UART_FR_BUSY_M) &gt;&gt; UART_FR_BUSY_S;</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>These examples all use constants (defines) as argument for the macro which means that the macro can be resolved at <b>compile-time</b> for very efficient memory accesses. If using variables (e.g. a count value for accessing continuous addresses) the macro can only be resolved at <b>run-time</b> thus resulting in more code and less efficient execution.</dd></dl>
<h2><a class="anchor" id="prog_model_software"></a>
Software Driver Model</h2>
<p>In the software driver model, the APIs provided in DriverLib are used by applications to control the peripherals. Because these drivers provide complete control of the peripherals in their normal mode of operation, it is possible to write an entire application without direct access to the registers. This method provides for rapid development of the application without requiring knowledge of how to program the peripheral registers.</p>
<p>Corresponding to the direct register access model example, the following call also programs the <code>CTL</code> register in the UART module (though the register name is hidden by the API):</p>
<div class="fragment"><div class="line"><a class="code" href="group__uart__api.html#ga5b554f1d6649321f933af4d527abe069">UARTDisable</a>(UART0_BASE);</div></div><!-- fragment --><h2><a class="anchor" id="prog_model_combine"></a>
Combining the Models</h2>
<p>The direct register access model and software driver model can be used together in a single application, thus applying the most appropriate model as needed to any particular situation within the application. For example, the software driver model can be used to configure the peripherals (because this is not performance critical) and the direct register access model can be used to operate the peripheral (which may be more performance critical). Or, the software driver model can be used for peripherals that are not performance critical (such as a UART used for data logging) and the direct register access model can be used for performance critical peripherals.</p>
<h1><a class="anchor" id="hapi"></a>
HAPI Functions</h1>
<p>A number of functions are available in a ROM-only version. These functions are called HAPI functions (Hard API) and are generally used by various tools. Source code is not available for the HAPI functions but the functions are available for users to call. The list of HAPI functions available can be found in <code><a class="el" href="hapi_8h.html">hapi.h</a></code>.</p>
<h1><a class="anchor" id="error"></a>
Error Checking</h1>
<p>Invalid arguments and error conditions are handled in a non-traditional manner in DriverLib. Typically, a function would check its arguments to make sure that they are valid (if required; some may be unconditionally valid such as a 32-bit value used as the load value for a 32-bit timer). If an invalid argument is provided, an error code would be returned. The caller then has to check the return code from each invocation of the function to make sure that it succeeded.</p>
<p>This method results in a significant amount of argument-checking code in each function and return-code-checking code at each call site. For a self-contained application, this extra code becomes an unneeded overhead once the application is debugged. Having a means of removing it allows the final code to be smaller and therefore run faster and consume less power.</p>
<p>In this driver library, most functions do not return error status. Argument checking is done via a call to the <code>ASSERT</code> macro (provided in <code><a class="el" href="debug_8h.html">debug.h</a></code>). This macro has the usual definition of an assert macro; it takes an expression that <b>must</b> be true. By making this macro empty, the argument checking is completely removed from the code thus avoiding the error checking overhead.</p>
<p>There are two definitions of the <code>ASSERT</code> macro provided in <code><a class="el" href="debug_8h.html">debug.h</a></code>; one that is empty (used for normal/release builds) and one that evaluates the expression (used when the library is built for debugging). The debug version calls the <code>__error__</code> function whenever the expression is not true, passing the file name and line number of the <code>ASSERT</code> macro invocation. The <code>__error__</code> function is prototyped in <code><a class="el" href="debug_8h.html">debug.h</a></code> and must be provided by the application because it is the application's responsibility to deal with error conditions.</p>
<p>To enable the <code>ASSERT</code> macro define the symbol <code>DRIVERLIB_DEBUG</code> within your project and/or compiler setup.</p>
<dl class="section note"><dt>Note</dt><dd>Defining <code>DRIVERLIB_DEBUG</code> for the entire project might result in a significant increase in code size depending on the number of modules used in the project. Defining <code>DRIVERLIB_DEBUG</code> for specific files is possible if a project-wide define results in an unacceptable code size increase.</dd></dl>
<p>By setting a breakpoint on the <code>__error__</code> function, the debugger immediately stops whenever an error occurs anywhere in the application (something that would be very difficult to do with other error checking methods). When the debugger stops, the arguments to the <code>__error__</code> function and the backtrace of the stack pinpoint the function that found an error, what it found to be a problem, and where it was called from. As an example:</p>
<div class="fragment"><div class="line"><a class="code" href="group__gpio__api.html#ga33f4f6acc499e781048f0d900ef61ffa">GPIOWriteDio</a>( uint32_t dioNumber, uint32_t value )</div><div class="line">{</div><div class="line">    <span class="comment">// Check the arguments.</span></div><div class="line">    <a class="code" href="group__debug__api.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>( dioNumberLegal( dioNumber ));</div><div class="line">    <a class="code" href="group__debug__api.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(( value == 0 ) || ( value == 1 ));</div></div><!-- fragment --><p>Each argument is individually checked, so the line number of the failing <code>ASSERT</code> indicates the argument that is invalid. The debugger is able to display the values of the arguments (from the stack trace) as well as the caller of the function that had the argument error. This method allows the problem to be quickly identified at the cost of a small amount of code.</p>
<h1><a class="anchor" id="setup"></a>
Device Setup</h1>
<p>DriverLib includes a special function called <a class="el" href="group__setup__api.html#ga3ca82b82ffa386543c8d3da2f06eda3b" title="Performs the necessary trim of the device which is not done in ROM boot code. ">SetupTrimDevice()</a> which must always be called right after the ROM boot sequence in order to apply trim settings and certain customer configurations (from CCFG) to the device.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__setup__api.html#ga3ca82b82ffa386543c8d3da2f06eda3b" title="Performs the necessary trim of the device which is not done in ROM boot code. ">SetupTrimDevice()</a> is called by the startup file provided as part of the CC23x0R5 DriverLib package.</dd></dl>
<h1><a class="anchor" id="ccfg"></a>
Customer Configuration (CCFG)</h1>
<p>The CC23x0R5 DriverLib package includes a customer configuration file (ccfg.c) which contains settings that are being applied mainly by ROM boot sequence, <a class="el" href="group__setup__api.html#ga3ca82b82ffa386543c8d3da2f06eda3b">SetupTrimDevice()</a> during startup, and radio SW. The configuration settings are stored in a specially allocated address range in flash referred to as "CCFG area". The user must edit the CCFG to fit the needs of the specific design and application.</p>
<p>Typically, a user application does not need to read the settings in CCFG; however, a few settings might be interesting for a user to read. These can be read by accessing the <code>ccfg</code> variable defined in ccfg.c using dot notation.</p>
<h1><a class="anchor" id="rtos"></a>
RTOS (Real-Time Operating System)</h1>
<p>Higher-level software for CC23x0R5, for example FreeRTOS, uses DriverLib as the main interface to access the hardware registers thus minimizing the need for direct register accesses from the RTOS itself. The CC23x0R5 Product SDK package provides its own set of RTOS drivers that call DriverLib functions.</p>
<p>When using e.g. FreeRTOS and the included RTOS drivers it is important that a user application does not "bypass" RTOS drivers by calling DriverLib functions directly to configure any hardware that is controlled by the RTOS. Doing so can cause a conflict that may result in unexpected behavior by the RTOS. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
