/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_api.h                                */
/* Note        : 一部、ユーザ編集可                          */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_API_H_INCLUDE
#define L_SLIN_API_H_INCLUDE


/* ↓↓↓ ユーザ編集許可ここから ↓↓↓ */
/* フレーム名の定義 */
#define  U1G_LIN_FRAME_ID06H            ((l_u8)0x00)
#define  U1G_LIN_FRAME_ID01H            ((l_u8)0x01)
#define  U1G_LIN_FRAME_ID17H            ((l_u8)0x02)
#define  U1G_LIN_FRAME_ID21H            ((l_u8)0x03)
#define  U1G_LIN_FRAME_ID19H            ((l_u8)0x04)
#define  U1G_LIN_FRAME_ID31H            ((l_u8)0x05)
#define  U1G_LIN_FRAME_ID3CH            ((l_u8)0x06)
#define  U1G_LIN_FRAME_ID3DH            ((l_u8)0x07)

/* シグナルの名前(Table Type) */
/* ビットシンボルテーブル構造(LDF: Frames, Signals) */
typedef union {
    l_u8    u1g_lin_byte[U1G_LIN_MAX_DL];    /******    !!!この行は変更削除を行わないでください!!!    ******/
} un_lin_data_type;

/* 3DHフレームの設定 */
#define  U1G_LIN_FRAME_3DH_BRG          xng_lin_frm_buf[U1G_LIN_FRAME_ID3DH].xng_lin_data.u1g_lin_byte[2U]

/* 同期フラグ : フレーム送信完了フラグ */
#define  F1g_lin_txframe_id06h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot2

/* 同期フラグ : フレーム受信完了フラグ */
#define  F1g_lin_rxframe_id01h          xng_lin_sts_buf.un_rs_flg1.st_bit.u2g_lin_slot1

/* 同期フラグ : フレームエラーの発生状況フラグ */
#define  F4g_lin_errframe_e_nores_id01h        xng_lin_frm_buf[ U1G_LIN_FRAME_ID01H ].u1g_lin_e_nores
#define  F4g_lin_errframe_e_uart_id01h         xng_lin_frm_buf[ U1G_LIN_FRAME_ID01H ].u1g_lin_e_uart
#define  F4g_lin_errframe_e_bit_id01h          xng_lin_frm_buf[ U1G_LIN_FRAME_ID01H ].u1g_lin_e_bit
#define  F4g_lin_errframe_e_sum_id01h          xng_lin_frm_buf[ U1G_LIN_FRAME_ID01H ].u1g_lin_e_sum
#define  F4g_lin_errframe_e_res_sht_id01h      xng_lin_frm_buf[ U1G_LIN_FRAME_ID01H ].u1g_lin_e_res_sht

#define  F4g_lin_errframe_e_nores_id06h        xng_lin_frm_buf[ U1G_LIN_FRAME_ID06H ].u1g_lin_e_nores
#define  F4g_lin_errframe_e_uart_id06h         xng_lin_frm_buf[ U1G_LIN_FRAME_ID06H ].u1g_lin_e_uart
#define  F4g_lin_errframe_e_bit_id06h          xng_lin_frm_buf[ U1G_LIN_FRAME_ID06H ].u1g_lin_e_bit
#define  F4g_lin_errframe_e_sum_id06h          xng_lin_frm_buf[ U1G_LIN_FRAME_ID06H ].u1g_lin_e_sum
#define  F4g_lin_errframe_e_res_sht_id06h      xng_lin_frm_buf[ U1G_LIN_FRAME_ID06H ].u1g_lin_e_res_sht

/* 同期フラグ : フレームのbusy状態フラグ */
#define  F1g_lin_busyflag_id3Ch         xng_lin_frm_buf[U1G_LIN_FRAME_ID3CH].un_state.st_bit.u2g_lin_status

/* ↑↑↑ ユーザ編集許可ここまで ↑↑↑ */

/***************************************************************************/
/*              !!!以降は 変更、削除をおこなわないで下さい!!!              */
/***************************************************************************/
/***************************************************************************/

/* 同期フラグ: Bus inactive発生状況フラグ */
#define  F1g_lin_bus_inactive           xng_lin_sts_buf.u1g_lin_bus_inactive

/* 同期フラグ：ヘッダエラーの発生状況フラグ（エラー個別） */
#define  F1g_lin_header_err_uart        xng_lin_sts_buf.u1g_lin_e_uart
#define  F1g_lin_header_err_sync        xng_lin_sts_buf.u1g_lin_e_sync
#define  F1g_lin_header_err_parity      xng_lin_sts_buf.u1g_lin_e_pari

/********************************/
/* LIN API EXTERN               */
/********************************/
/***** API関数 外部参照宣言 *****/
void     l_ifc_init(void);
void     l_ifc_init_com(void);
void     l_ifc_init_drv(void);
void     l_ifc_bus_err_tick(void);
void     l_ifc_connect(void);
l_bool   l_ifc_disconnect(void);
void     l_ifc_wake_up(void);
#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
l_u16    l_ifc_read_status(void);
#endif
void     l_ifc_sleep(void);

void     l_ifc_run(void);

void     l_ifc_tx(void);
void     l_ifc_rx(void);
void     l_ifc_err(void);
void     l_ifc_aux(void);
void     l_ifc_tau_timeout(void);

l_u16    l_ifc_read_lb_status(void);
#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
void     l_slot_enable(l_frame_handle  u1a_lin_frm);
void     l_slot_disable(l_frame_handle  u1a_lin_frm);
#endif
void     l_slot_rd(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, l_u8 pta_lin_data[]);
void     l_slot_wr(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, const l_u8 pta_lin_data[]);
#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
void     l_slot_set_default(l_frame_handle u1a_lin_frm);
void     l_slot_set_fail(l_frame_handle  u1a_lin_frm);
#endif

#endif

/***** End of File *****/


/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_cmn.c                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/
/* LINライブラリ ROMセクション定義 */
#pragma section  text   @@LNCD
#pragma section  text  @@LNCDL
#pragma section  const   @@LNCNS
#pragma section  const  @@LNCNSL
/* LINライブラリ RAMセクション定義 */
#pragma section  bss   @@LNDT
#pragma section  bss  @@LNDTL

/***** ヘッダ インクルード *****/
#include "l_slin_user.h"

/*===========================================================================================*/

/**************************************************/
/*  システム初期化 処理(API)                      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_bool  l_sys_init(void)
{
    l_bool u2a_lin_result;
    
    /* コンソーシアム仕様にて定義されている */
    /* 最初に実行するAPI。                  */
    /* 本製品では行うべき処理が無いため、   */
    /* 戻り値でOKを返すのみとします         */

    u2a_lin_result = U2G_LIN_OK;

    return( u2a_lin_result );
}


/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_cmn.h                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_CMN_H_INCLUDE
#define L_SLIN_CMN_H_INCLUDE

/***** 型宣言 *****/
typedef unsigned char   l_u8;
typedef unsigned short  l_u16;
typedef unsigned long   l_u32;
typedef unsigned short  l_bool;
typedef unsigned char   l_frame_handle;

/***** 定数定義 *****/

/* エンディアンタイプ */
#define  U1G_LIN_ENDIAN_LITTLE      (0U)            /* リトルエンディアンタイプ */
#define  U1G_LIN_ENDIAN_BIG         (1U)            /* ビッグエンディアンタイプ */

/* 通信ボーレート */
#define  U1G_LIN_BAUDRATE_9600      (0U)            /* 通信ボーレート9600bpsを使用  */
#define  U1G_LIN_BAUDRATE_10400     (1U)            /* 通信ボーレート10400bpsを使用 */
#define  U1G_LIN_BAUDRATE_19200     (2U)            /* 通信ボーレート19200bpsを使用 */
#define  U1G_LIN_BAUDRATE_10417     (3U)            /* 通信ボーレート10417bpsを使用 */

/* LINチャネル */
#define  U1G_LIN_LINCH_0            (0U)            /* LINチャネル0を使用 */
#define  U1G_LIN_LINCH_1            (1U)            /* LINチャネル1を使用 */

/* デバイス依存部分の定数定義 */

#define  U1G_LIN_CLKSRC_FCLK        (0U)            /* LINクロックソースにfCLKを選択 */
#define  U1G_LIN_CLKSRC_FMX         (1U)            /* LINクロックソースにfMXを選択 */

/* RUN遷移時のヘッダエラークリア実施/不実施 */
#define  U1G_LIN_ERRCLR_ON          (0U)            /* RUN遷移時のヘッダエラークリア実施   */
#define  U1G_LIN_ERRCLR_OFF         (1U)            /* RUN遷移時のヘッダエラークリア不実施 */

/* ROM削減(未使用APIの削除)実施/不実施 */
#define  U1G_LIN_ROM_SHRINK_ON      (1U)            /* ROM削減実施 */
#define  U1G_LIN_ROM_SHRINK_OFF     (0U)            /* ROM削減不実施 */

/* オートボーレート on/off */
#define  U1G_LIN_BAUD_RATE_DETECT_ON   (1U)         /* オートボーレート 有効 */
#define  U1G_LIN_BAUD_RATE_DETECT_OFF  (0U)         /* オートボーレート 無効 */

/* Breakの長さ */
#define  U1G_LIN_BREAK_LENGTH_10BITS   (10U)        /* Breakの長さ 10ビット(固定ボーレートの場合9.5)  */
#define  U1G_LIN_BREAK_LENGTH_11BITS   (11U)        /* Breakの長さ 11ビット(固定ボーレートの場合10.5) */

/* unsigned char型のOK/NG */
#define  U1G_LIN_OK                 ((l_u8)0U)      /* 処理成功 */
#define  U1G_LIN_NG                 ((l_u8)1U)      /* 処理失敗 */

/* bool型のOK/NG */
#define  U2G_LIN_OK                 ((l_bool)0U)    /* 処理成功 */
#define  U2G_LIN_NG                 ((l_bool)1U)    /* 処理失敗 */

/* LINステータス */
#define  U1G_LIN_STS_RESET          ((l_u8)0U)      /* LINステータス = RESET       */
#define  U1G_LIN_STS_SLEEP          ((l_u8)1U)      /* LINステータス = SLEEP       */
#define  U1G_LIN_STS_RUN_STANDBY    ((l_u8)2U)      /* LINステータス = RUN STANDBY */
#define  U1G_LIN_STS_RUN            ((l_u8)3U)      /* LINステータス = RUN         */

#define  U1G_LIN_MAX_SLOT_NUM       ((l_u8)64U)     /* スロット最大数 */

#define  U1G_LIN_WORD_BIT           ((l_u8)16U)     /* word型をbitで分割(16bit) */

/* ID Info Send/Recv Setting */
#define  U1G_LIN_CMD_SND            ((l_u8)0U)      /* 送信フレーム */
#define  U1G_LIN_CMD_RCV            ((l_u8)1U)      /* 受信フレーム */

/* NM使用/未使用(unsigned char型) */
#define  U1G_LIN_NM_NO_USE          ((l_u8)0U)      /* NM未使用 */
#define  U1G_LIN_NM_USE             ((l_u8)1U)      /* NM使用   */

/* Checksum type */
#define  U1G_LIN_SUM_CLASSIC        ((l_u8)0U)      /* Classicチェックサム */
#define  U1G_LIN_SUM_ENHANCED       ((l_u8)1U)      /* Enhancedチェックサム */
#define  U1G_LIN_SUM_TYPE_MAX       ((l_u8)1U)      /* 異常判定用 */

#define  U1G_LIN_NO_FRAME           ((l_u8)0xFFU)   /* 未登録フレーム(ID = 0xFF) */

/* ウェイクアップ検出 */
#define  U1G_LIN_WUP_NOT_DET        ((l_u8)0U)      /* ウェイクアップ未検出 */
#define  U1G_LIN_WUP_DET            ((l_u8)1U)      /* ウェイクアップ検出 */

/* システム異常フラグ */
#define  U1G_LIN_SYSERR_NON         ((l_u8)0U)      /* 初期値 */
#define  U1G_LIN_SYSERR_STAT        ((l_u8)1U)      /* LINステータスが規定値以外 */
#define  U1G_LIN_SYSERR_DRIVER      ((l_u8)3U)      /* MCUステータス異常 */

/* LINレスポンスバッファ */
#define  U1G_LIN_MAX_DL             ((l_u8)8U)      /* 最大データサイズ */

/* エラーフック処理通知用定数 */
#define  U1G_LIN_ID_DUMMY           ((l_u8)0xFFU)   /* ヘッダエラーでのエラーフック発生時用 */

/* タイマ・アレイ・ユニット(TAU) ユニット */
#define  U1G_LIN_TIMER_UNIT_0       (0x00U)   /* TAUユニット 0 を使用 */
#define  U1G_LIN_TIMER_UNIT_1       (0x01U)   /* TAUユニット 1 を使用 */

/* タイマ・アレイ・ユニット(TAU) チャネル */
#define  U1G_LIN_TIMER_CH_0         (0x00U)   /* TAUチャネル 0 を使用 */
#define  U1G_LIN_TIMER_CH_1         (0x01U)   /* TAUチャネル 1 を使用 */
#define  U1G_LIN_TIMER_CH_2         (0x02U)   /* TAUチャネル 2 を使用 */
#define  U1G_LIN_TIMER_CH_3         (0x03U)   /* TAUチャネル 3 を使用 */
#define  U1G_LIN_TIMER_CH_4         (0x04U)   /* TAUチャネル 4 を使用 */
#define  U1G_LIN_TIMER_CH_5         (0x05U)   /* TAUチャネル 5 を使用 */
#define  U1G_LIN_TIMER_CH_6         (0x06U)   /* TAUチャネル 6 を使用 */
#define  U1G_LIN_TIMER_CH_7         (0x07U)   /* TAUチャネル 7 を使用 */

/* タイマ・アレイ・ユニット(TAU) 動作クロック (fMCK) */
#define  U1G_LIN_TIMER_CKMK_M0      (0x00U)   /* TAU 動作クロック(fMCK) CKm0 を使用 */
#define  U1G_LIN_TIMER_CKMK_M1      (0x01U)   /* TAU 動作クロック(fMCK) CKm1 を使用 */
#define  U1G_LIN_TIMER_CKMK_M2      (0x02U)   /* TAU 動作クロック(fMCK) CKm2 を使用 */
#define  U1G_LIN_TIMER_CKMK_M3      (0x03U)   /* TAU 動作クロック(fMCK) CKm3 を使用 */

#define  U2G_LIN_ERRINFO_HDR_SYNC   ((l_u16)0x0002U)   /* ヘッダエラー Synch field error */
#define  U2G_LIN_ERRINFO_HDR_PARI   ((l_u16)0x0004U)   /* ヘッダエラー ID parity error */
#define  U2G_LIN_ERRINFO_HDR_UART   ((l_u16)0x0008U)   /* ヘッダエラー Framing error */
#define  U2G_LIN_ERRINFO_RSP_BIT    ((l_u16)0x0010U)   /* レスポンスエラー Bit error */
#define  U2G_LIN_ERRINFO_RSP_NORES  ((l_u16)0x0020U)   /* レスポンスエラー No response */
#define  U2G_LIN_ERRINFO_RSP_UART   ((l_u16)0x0040U)   /* レスポンスエラー Framing error */
#define  U2G_LIN_ERRINFO_RSP_SUM    ((l_u16)0x0080U)   /* レスポンスエラー Checksum error */
#define  U2G_LIN_ERRINFO_RSP_RESSHT ((l_u16)0x0100U)   /* レスポンスエラー Response too short */
#define  U2G_LIN_ERRINFO_RSP_READY  ((l_u16)0x0200U)   /* レスポンスエラー Response ready error */

/* ID Info DL Setting */
#define  U1G_LIN_DL_1               ((l_u8)0x01U)
#define  U1G_LIN_DL_2               ((l_u8)0x02U)
#define  U1G_LIN_DL_3               ((l_u8)0x03U)
#define  U1G_LIN_DL_4               ((l_u8)0x04U)
#define  U1G_LIN_DL_5               ((l_u8)0x05U)
#define  U1G_LIN_DL_6               ((l_u8)0x06U)
#define  U1G_LIN_DL_7               ((l_u8)0x07U)
#define  U1G_LIN_DL_8               ((l_u8)0x08U)
#define  U1G_LIN_DL_n               ((l_u8)0x0FU)


/* unsigned char型 */
#define  U1G_LIN_BIT_CLR            ((l_u8)0U)
#define  U1G_LIN_BIT_SET            ((l_u8)1U)
#define  U1G_LIN_BYTE_CLR           ((l_u8)0x00U)

#define  U1G_LIN_0                  ((l_u8)0U)
#define  U1G_LIN_1                  ((l_u8)1U)
#define  U1G_LIN_2                  ((l_u8)2U)
#define  U1G_LIN_3                  ((l_u8)3U)
#define  U1G_LIN_4                  ((l_u8)4U)
#define  U1G_LIN_5                  ((l_u8)5U)
#define  U1G_LIN_6                  ((l_u8)6U)
#define  U1G_LIN_7                  ((l_u8)7U)
#define  U1G_LIN_8                  ((l_u8)8U)
#define  U1G_LIN_16                 ((l_u8)16U)
#define  U1G_LIN_32                 ((l_u8)32U)
#define  U1G_LIN_48                 ((l_u8)48U)
#define  U1G_LIN_64                 ((l_u8)64U)

#define  U1G_LIN_BIT0               ((l_u8)0x01U)
#define  U1G_LIN_BIT1               ((l_u8)0x02U)

/* unsigned short型 */
#define  U2G_LIN_BIT_CLR            ((l_u16)0U)
#define  U2G_LIN_BIT_SET            ((l_u16)1U)
#define  U2G_LIN_BYTE_CLR           ((l_u16)0x00U)
#define  U2G_LIN_WORD_CLR           ((l_u16)0x0000U)

#define  U2G_LIN_0                  ((l_u16)0U)

/* NULL */
#define  U1G_LIN_NULL               ((void *)0U)

/*** 関数のプロトタイプ宣言(global) ***/
l_bool l_sys_init(void);

/***** その他の関数 外部参照宣言(global) *****/

/***** APIマクロ宣言 *****/
#define  l_bool_rd(x)       (x)
#define  l_u8_rd(x)         (x)
#define  l_u16_rd(x)        (x)
#define  l_bool_wr(x, v)    ( (x) = (v) )
#define  l_u8_wr(x, v)      ( (x) = (v) )
#define  l_u16_wr(x, v)     ( (x) = (v) )
#define  l_flg_tst(x)       (x)
#define  l_flg_clr(x)       ( (x) = 0U )


/***** 関数プロトタイプ宣言 *****/
void  l_hook_sleep(void);
void  l_hook_wake(void);
void  l_hook_snd_comp(l_frame_handle  u1a_lin_frm);
void  l_hook_rcv_comp(l_frame_handle  u1a_lin_frm);
void  l_hook_err(l_frame_handle  u1a_lin_frm, l_u16 u2a_lin_err);
#endif

/***** End of File *****/


/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_core_rl78f24.c                       */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/
/* LINライブラリ ROMセクション定義 */
#pragma section  text   @@LNCD
#pragma section  text  @@LNCDL
#pragma section  const   @@LNCNS
#pragma section  const  @@LNCNSL
/* LINライブラリ RAMセクション定義 */
#pragma section  bss   @@LNDT
#pragma section  bss  @@LNDTL

/***** ヘッダ インクルード *****/
#include "l_slin_user.h"
#include "l_slin_core_rl78f24.h"
#include "l_slin_drv_rl78f24.h"

/***** 関数プロトタイプ宣言 *****/
/*-- 関数定義(static) --*/
static void   l_vol_lin_set_frm_complete(l_u8  u1a_lin_err);
static void   l_vol_lin_sub_hdr_rcv(l_u8 u1a_lin_id);

/*** 変数定義(static) ***/
static st_lin_bus_status_type  xnl_lin_bus_sts;        /* LIN Bus ステータス */
static l_u8   u1l_lin_nm_info;                         /* NM 情報テーブル */
static st_lin_id_slot_type  xnl_lin_id_sl;
static l_u16  u2l_lin_bus_inactive_cnt;                /* Bus inactive検出用カウンタ */
static l_u8   u1l_lin_hdr_rcved;                       /* ヘッダ受信/未受信 */
static l_u8   u1l_lin_wup_det;                         /* ウェイクアップ検出フラグ */
static l_u8   u1l_lin_lst_d1rc_state;                  /* データ1受信フラグの状態(LIN/UART ステータス・レジスタ LSTn.D1RC ) */


/*===========================================================================================*/

/**********************************/
/* MCU非依存API関数処理           */
/**********************************/
/**************************************************/
/*  バッファ、ドライバの初期化処理(API)           */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_init(void)
{
    xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_RESET;                    /* RESET状態にする */

    u1g_lin_syserr = U1G_LIN_SYSERR_NON;                                /* システム異常フラグの初期化 */

    l_ifc_init_drv();                                                   /* LINドライバの初期化(API) */
    l_ifc_init_com();                                                   /* LINバッファの初期化(API) */

    xnl_lin_bus_sts.u1g_lin_err_resp = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_ok_resp = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_ovr_run = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_goto_sleep = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_bus_err = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_head_err = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_last_id = U1G_LIN_BYTE_CLR;

    u1l_lin_nm_info             = U1G_LIN_BYTE_CLR;                     /* NM情報の初期化 */
    xnl_lin_id_sl.u1g_lin_id    = U1G_LIN_BYTE_CLR;                     /* 処理するフレームのIDの初期化 */
    xnl_lin_id_sl.u1g_lin_slot  = U1G_LIN_BYTE_CLR;                     /* 処理するフレームのスロット番号の初期化 */
    u2l_lin_bus_inactive_cnt    = U2G_LIN_WORD_CLR;                     /* Bus inactive検出用カウンタの初期化 */

    u1l_lin_hdr_rcved           = U1G_LIN_HDR_NOT_RCVED;                /* ヘッダ未受信 */
    u1l_lin_wup_det             = U1G_LIN_WUP_NOT_DET;                  /* ウェイクアップ未検出 */
    u1l_lin_lst_d1rc_state      = U1G_LIN_LST_D1RC_INCOMPLETE;          /* データ1受信完了の状態をクリアする (LIN/UART ステータス・レジスタ LSTn.D1RC) */

}


/**************************************************/
/*  LINバッファの初期化 処理(API)                 */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_init_com(void)
{
    l_u8    u1a_lin_lp1;

  /*--- LINステータスバッファ初期化 ---*/
    /* NADのセット */
    xng_lin_sts_buf.u1g_lin_nad = U1G_LIN_NAD;

    /* Bus inactiveフラグのクリア */
    xng_lin_sts_buf.u1g_lin_bus_inactive = U1G_LIN_BIT_CLR;

    /* ヘッダーエラーフラグのクリア */
    xng_lin_sts_buf.u1g_lin_e_uart = U1G_LIN_BYTE_CLR;
    xng_lin_sts_buf.u1g_lin_e_sync = U1G_LIN_BYTE_CLR;
    xng_lin_sts_buf.u1g_lin_e_pari = U1G_LIN_BYTE_CLR;

    /* 送受信処理完了フラグのクリア */
    xng_lin_sts_buf.un_rs_flg1.u2g_lin_word = U2G_LIN_WORD_CLR;
    xng_lin_sts_buf.un_rs_flg2.u2g_lin_word = U2G_LIN_WORD_CLR;
    xng_lin_sts_buf.un_rs_flg3.u2g_lin_word = U2G_LIN_WORD_CLR;
    xng_lin_sts_buf.un_rs_flg4.u2g_lin_word = U2G_LIN_WORD_CLR;

  /*--- LINフレームバッファ初期化 ---*/
    for( u1a_lin_lp1 = U1G_LIN_0; U1G_LIN_MAX_SLOT > u1a_lin_lp1; u1a_lin_lp1++ ) {

        l_vod_lin_DI();                                                /* 割り込み禁止設定 */

        /* ステータス部分(エラーフラグ等)クリア */
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_e_nores = U1G_LIN_BYTE_CLR;
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_e_uart = U1G_LIN_BYTE_CLR;
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_e_bit = U1G_LIN_BYTE_CLR;
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_e_sum = U1G_LIN_BYTE_CLR;
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_e_res_sht = U1G_LIN_BYTE_CLR;
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_status = U1G_LIN_BYTE_CLR;
        xng_lin_frm_buf[ u1a_lin_lp1 ].u1g_lin_no_use = U1G_LIN_BYTE_CLR;

        /* LINバッファのデータ部をデフォルト値で初期化する */
        /* デフォルト値設定 */
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_0 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_1 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_2 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_3 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_4 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_5 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_6 ];
        xng_lin_frm_buf[ u1a_lin_lp1 ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ]
                                = xng_lin_slot_tbl[ u1a_lin_lp1 ].u1g_lin_def[ U1G_LIN_7 ];

        l_vod_lin_EI();                                                /* 割り込み許可     */

    }
}


/**************************************************/
/*  LINドライバの初期化 処理(API)                 */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_init_drv(void)
{
    l_u8    u1a_lin_result_tmp;

    /*** LINモジュールの初期化 ***/
    u1a_lin_result_tmp = l_u1g_lin_linmodule_init();                    /* LINモジュールの初期化 */

    /*** TAUモジュールの初期化 ***/
    l_vog_lin_timer_init();                                             /* TAUモジュールの初期化処理 */

    /*** INTの初期化 ***/
    l_vog_lin_int_init();                                               /* INT割り込み初期化 */

    if( U1G_LIN_OK != u1a_lin_result_tmp ) {
        u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                         /* システム異常(MCUステータス) */
    }
    else{
        switch( xng_lin_sts_buf.u1g_lin_sts ) {
        /* SLEEP状態 */
        case ( U1G_LIN_STS_SLEEP ):
            l_vod_lin_DI();                                             /* 割り込み禁止設定 */

            l_vog_lin_int_enb();                                        /* ウェイクアップ検出許可 */
            u1a_lin_result_tmp  = l_u1g_lin_set_reset();                /* LINモジュールRESETモード設定 */
            if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                 /* システム異常(MCUステータス) */
            }
            l_hook_sleep();                                             /* Sleep時Hook処理 */

            l_vod_lin_EI();                                             /* 割り込み許可     */
            break;
        /* RUN状態 / RUN STANDBY状態 */
        case ( U1G_LIN_STS_RUN_STANDBY ):
        case ( U1G_LIN_STS_RUN ):
            xnl_lin_bus_sts.u1g_lin_err_resp = U1G_LIN_BYTE_CLR;
            xnl_lin_bus_sts.u1g_lin_ok_resp = U1G_LIN_BYTE_CLR;
            xnl_lin_bus_sts.u1g_lin_ovr_run = U1G_LIN_BYTE_CLR;
            xnl_lin_bus_sts.u1g_lin_goto_sleep = U1G_LIN_BYTE_CLR;
            xnl_lin_bus_sts.u1g_lin_bus_err = U1G_LIN_BYTE_CLR;
            xnl_lin_bus_sts.u1g_lin_head_err = U1G_LIN_BYTE_CLR;
            xnl_lin_bus_sts.u1g_lin_last_id = U1G_LIN_BYTE_CLR;
            u1l_lin_hdr_rcved             = U1G_LIN_HDR_NOT_RCVED;      /* ヘッダ未受信に戻す */
            u2l_lin_bus_inactive_cnt      = U2G_LIN_WORD_CLR;           /* Bus inactive監視カウンタのクリア  */
            u1l_lin_lst_d1rc_state        = U1G_LIN_LST_D1RC_INCOMPLETE; /* データ1受信完了の状態をクリアする (LIN/UART ステータス・レジスタ LSTn.D1RC) */

            u1a_lin_result_tmp = l_u1g_lin_set_run();                   /* LINモジュール通信可能状態設定 */
            if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                 /* システム異常(MCUステータス) */
            }

            break;
        /* 上記の状態以外の場合 */
        default:
            /* 何もしない */
            break;
        }
    }
}


/**************************************************/
/*  バスエラー監視 処理(API)                      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_bus_err_tick(void)
{
    l_vod_lin_DI();                                                     /* 割り込み禁止設定 */

    /* RUN / RUN STANDBY状態の場合 */
    if( (U1G_LIN_STS_RUN == xng_lin_sts_buf.u1g_lin_sts)
     || (U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts) ) {
        /* Bus inactive検出フラグがセットされていない場合 */
        if( U1G_LIN_BIT_SET != xng_lin_sts_buf.u1g_lin_bus_inactive ) {
            u2l_lin_bus_inactive_cnt += U2G_LIN_TIME_BASE;              /* Bus inactive検出用カウンタをカウントアップ */

            /* カウントが超えた場合(Bus inactive) */
            if( U2G_LIN_BUS_TIMEOUT <= u2l_lin_bus_inactive_cnt ) {
                xng_lin_sts_buf.u1g_lin_bus_inactive                = U1G_LIN_BIT_SET;
                xnl_lin_bus_sts.u1g_lin_bus_err                     = U1G_LIN_BIT_SET;
                u2l_lin_bus_inactive_cnt                            = U2G_LIN_WORD_CLR; /* Bus inactive検出用カウンタ クリア */
            }
        }
        /* Bus inactive検出フラグがセットされている場合 */
        else{
            u2l_lin_bus_inactive_cnt = U2G_LIN_WORD_CLR;                /* Bus inactive検出用カウンタ クリア */
        }
    }

    l_vod_lin_EI();                                                     /* 割り込み許可     */
}


/**************************************************/
/*  LIN通信接続 処理(API)                         */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_connect(void)
{
    /*** オート変数 ***/
    l_u8    u1a_lin_result_tmp;

    l_vod_lin_DI();                                             /* 割り込み禁止設定 */

    if( U1G_LIN_STS_RESET == xng_lin_sts_buf.u1g_lin_sts ) {
        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_SLEEP;            /* SLEEP状態へ移行 */

        l_vog_lin_int_enb();                                                    /* ウェイクアップ検出許可 */
        u1a_lin_result_tmp  = l_u1g_lin_set_reset();                            /* LINモジュールRESETモード設定 */
        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                             /* システム異常(MCUステータス) */
        }
        else{
            /* 処理なし */
        }
        l_hook_sleep();                                             /* Sleep時Hook処理 */
    }
    /* RESET状態以外の場合 */
    else {
        /* 処理なし */
    }

    l_vod_lin_EI();                                             /* 割り込み許可     */
}


/**************************************************/
/*  LIN切断 処理(API)                             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_bool  l_ifc_disconnect(void)
{
    /*** オート変数 ***/
    l_u8    u1a_lin_result_tmp;
    l_bool  u2a_lin_result;

    l_vod_lin_DI();                                             /* 割り込み禁止設定 */

    /* SLEEP状態の場合 */
    if( U1G_LIN_STS_SLEEP == xng_lin_sts_buf.u1g_lin_sts ) {
        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_RESET;
        l_vog_lin_int_dis();                                    /* INT割り込み禁止 */
        u1a_lin_result_tmp = l_u1g_lin_set_reset();             /* LINモジュールリセット状態設定 */

        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;             /* システム異常(MCUステータス) */
            u2a_lin_result = U2G_LIN_NG;
        }
        else{
            u2a_lin_result = U2G_LIN_OK;
        }
    }
    /* RESET状態の場合 */
    else if( U1G_LIN_STS_RESET == xng_lin_sts_buf.u1g_lin_sts ) {
        u2a_lin_result = U2G_LIN_OK;
    }
    /* SLEEPでもRESETでもない場合 */
    else{
        u2a_lin_result = U2G_LIN_NG;
    }

    l_vod_lin_EI();                                             /* 割り込み許可     */

    return( u2a_lin_result );
}


/**************************************************/
/*  wakeupコマンド送信 処理(API)                  */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_wake_up(void)
{
    l_u8    u1a_lin_result_tmp;

    l_vod_lin_DI();                                         /* 割り込み禁止設定 */

    if( (U1G_LIN_STS_SLEEP == xng_lin_sts_buf.u1g_lin_sts)
     || (U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts) ) {
        u1a_lin_result_tmp = l_u1g_lin_set_sndwkup();       /* LINモジュールWakeup送信設定 */

        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;         /* システム異常(MCUステータス) */
        }
        else{
            l_vog_lin_int_dis();                            /* INT割り込み禁止 */

            /* wakeupパルスを送信 */
            u1a_lin_result_tmp = l_u1g_lin_snd_wakeup();

            if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;     /* システム異常(MCUステータス) */
            }
        }
    }
    /* SLEEP / RUN STANDBY状態以外の場合 なにもしない */
    l_vod_lin_EI();                                         /* 割り込み許可     */
}


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/**************************************************/
/*  LINバス状態リード 処理(API)                   */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： LINバス状態                            */
/**************************************************/
l_u16  l_ifc_read_status(void)
{
    l_u16  u2a_lin_result;

    l_vod_lin_DI();                                         /* 割り込み禁止設定 */

    u2a_lin_result = xnl_lin_bus_sts.u1g_lin_err_resp;
	u2a_lin_result |= (l_u16)xnl_lin_bus_sts.u1g_lin_ok_resp << U1G_LIN_BUS_STS_OK_RESP;
	u2a_lin_result |= (l_u16)xnl_lin_bus_sts.u1g_lin_ovr_run << U1G_LIN_BUS_STS_OVR_RUN;
    u2a_lin_result |= (l_u16)xnl_lin_bus_sts.u1g_lin_goto_sleep << U1G_LIN_BUS_STS_GOTO_SLEEP;
    u2a_lin_result |= (l_u16)xnl_lin_bus_sts.u1g_lin_bus_err << U1G_LIN_BUS_STS_BUS_ERR;
    u2a_lin_result |= (l_u16)xnl_lin_bus_sts.u1g_lin_head_err << U1G_LIN_BUS_STS_HEAD_ERR;
    u2a_lin_result |= (l_u16)xnl_lin_bus_sts.u1g_lin_last_id << U1G_LIN_BUS_STS_LAST_ID;

    xnl_lin_bus_sts.u1g_lin_head_err = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_bus_err = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_goto_sleep = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_ovr_run = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_ok_resp = U1G_LIN_BYTE_CLR;
    xnl_lin_bus_sts.u1g_lin_err_resp = U1G_LIN_BYTE_CLR;

    l_vod_lin_EI();                                         /* 割り込み許可     */

    return( u2a_lin_result );
}
#endif


/**************************************************/
/*  SLEEP状態移行 処理(API)                       */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_sleep(void)
{
    l_u8    u1a_lin_result_tmp;

    l_vod_lin_DI();                                                         /* 割り込み禁止設定 */

    /* RUN / RUN STANDBY状態の場合 */
    if( (U1G_LIN_STS_RUN == xng_lin_sts_buf.u1g_lin_sts)
     || (U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts) ) {

        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_SLEEP;                    /* SLEEP状態に移行 */
        l_vog_lin_int_enb();                                                /* ウェイクアップ検出許可 */
        u1a_lin_result_tmp  = l_u1g_lin_set_reset();                        /* LINモジュールRESETモード設定 */

        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                         /* システム異常(MCUステータス) */
        }
        l_hook_sleep();                                                     /* Sleep時Hook処理 */
    }
    /* RUN / RUN STANDBY以外の場合 なにもしない */

    l_vod_lin_EI();                                                         /* 割り込み許可     */
}


/**************************************************/
/*  LINステータスのリード 処理(API)               */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： LINステータス                          */
/**************************************************/
l_u16  l_ifc_read_lb_status(void)
{
    l_u16  u2a_lin_result;

    l_vod_lin_DI();                                                         /* 割り込み禁止設定 */

    /* 現在のLINステータスを格納 */
    u2a_lin_result = (l_u16)xng_lin_sts_buf.u1g_lin_sts;

    l_vod_lin_EI();                                                         /* 割り込み許可     */

    return( u2a_lin_result );
}


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/**************************************************/
/*  スロット無効フラグクリア処理(API)             */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm: フレーム名                */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_enable(l_frame_handle  u1a_lin_frm)
{
    /* 引数値が範囲内の場合 */
    if( U1G_LIN_MAX_SLOT > u1a_lin_frm ) {

        l_vod_lin_DI();                                                         /* 割り込み禁止設定 */

        /* LINバッファ スロット有効 */
        xng_lin_frm_buf[ u1a_lin_frm ].u1g_lin_no_use = U1G_LIN_BIT_CLR;

        l_vod_lin_EI();                                                         /* 割り込み許可     */
    }
    /* 引数値が範囲外の場合 なにもしない */
}
#endif


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/**************************************************/
/*  スロット無効フラグセット処理(API)             */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm: フレーム名                */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_disable(l_frame_handle  u1a_lin_frm)
{
    /* 引数値が範囲内の場合 */
    if( U1G_LIN_MAX_SLOT > u1a_lin_frm ) {

        l_vod_lin_DI();                                                         /* 割り込み禁止設定 */

        /* LINバッファ スロット無効 */
        xng_lin_frm_buf[ u1a_lin_frm ].u1g_lin_no_use = U1G_LIN_BIT_SET;

        l_vod_lin_EI();                                                         /* 割り込み許可     */
    }
    /* 引数値が範囲外の場合 なにもしない */
}
#endif


/**************************************************/
/*  バッファ スロット読み出し処理(API)            */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : 読み出すフレーム名      */
/*         u1a_lin_cnt  : 読み出しデータ長        */
/*         pta_lin_data : データ格納先ポインタ    */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_rd(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, l_u8 pta_lin_data[])
{
    /* ポインタ(引数値)がNULL以外の場合 */
    if( U1G_LIN_NULL != pta_lin_data ) {
        /* 引数値が範囲内の場合 */
        if( U1G_LIN_MAX_SLOT > u1a_lin_frm ) {

            l_vod_lin_DI();                                         /* 割り込み禁止設定 */

            switch( u1a_lin_cnt ) {
            case ( U1G_LIN_8 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                pta_lin_data[ U1G_LIN_5 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                pta_lin_data[ U1G_LIN_6 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ];
                pta_lin_data[ U1G_LIN_7 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ];
                break;
            case ( U1G_LIN_7 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                pta_lin_data[ U1G_LIN_5 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                pta_lin_data[ U1G_LIN_6 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ];
                break;
            case ( U1G_LIN_6 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                pta_lin_data[ U1G_LIN_5 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ];
                break;
            case ( U1G_LIN_5 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                pta_lin_data[ U1G_LIN_4 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ];
                break;
            case ( U1G_LIN_4 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                pta_lin_data[ U1G_LIN_3 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ];
                break;
            case ( U1G_LIN_3 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                pta_lin_data[ U1G_LIN_2 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ];
                break;
            case ( U1G_LIN_2 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                pta_lin_data[ U1G_LIN_1 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ];
                break;
            case ( U1G_LIN_1 ):
                pta_lin_data[ U1G_LIN_0 ] = xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ];
                break;
            default:
                /* 指定サイズ異常の為、何もしない */
                break;
            }

            l_vod_lin_EI();                                         /* 割り込み許可     */

        }
        /* 引数が範囲外の場合 何もしない */
    }
    /* ポインタ(引数値)がNULLの場合 何もしない */
}


/**************************************************/
/*  バッファ スロット書き込み処理(API)            */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : 書き込むフレーム名      */
/*         u1a_lin_cnt  : 書き込みデータ長        */
/*         pta_lin_data : 書き込み格納元ポインタ  */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_wr(l_frame_handle u1a_lin_frm, l_u8 u1a_lin_cnt, const l_u8 pta_lin_data[])
{
    /* ポインタ(引数値)がNULL以外の場合 */
    if( U1G_LIN_NULL != pta_lin_data ) {
        /* 引数値が範囲内の場合 */
        if( U1G_LIN_MAX_SLOT > u1a_lin_frm ) {

            l_vod_lin_DI();                                         /* 割り込み禁止設定 */

            switch( u1a_lin_cnt ) {
            case ( U1G_LIN_8 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] = pta_lin_data[ U1G_LIN_5 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ] = pta_lin_data[ U1G_LIN_6 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ] = pta_lin_data[ U1G_LIN_7 ];
                break;
            case ( U1G_LIN_7 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] = pta_lin_data[ U1G_LIN_5 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ] = pta_lin_data[ U1G_LIN_6 ];
                break;
            case ( U1G_LIN_6 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ] = pta_lin_data[ U1G_LIN_5 ];
                break;
            case ( U1G_LIN_5 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ] = pta_lin_data[ U1G_LIN_4 ];
                break;
            case ( U1G_LIN_4 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ] = pta_lin_data[ U1G_LIN_3 ];
                break;
            case ( U1G_LIN_3 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ] = pta_lin_data[ U1G_LIN_2 ];
                break;
            case ( U1G_LIN_2 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ] = pta_lin_data[ U1G_LIN_1 ];
                break;
            case ( U1G_LIN_1 ):
                xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] = pta_lin_data[ U1G_LIN_0 ];
                break;
            default:
                /* 指定サイズ異常の為、何もしない */
            break;
            }

            l_vod_lin_EI();                                         /* 割り込み許可     */

        }
        /* 引数値が範囲外の場合 何もしない */
    }
    /* ポインタ(引数値)がNULLの場合 何もしない */
}


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/**************************************************/
/*  バッファスロット初期値設定処理(API)           */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm: フレーム名                */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_set_default(l_frame_handle  u1a_lin_frm)
{
    /* 引数値が範囲内の場合 */
    if( U1G_LIN_MAX_SLOT > u1a_lin_frm ) {

    	l_vod_lin_DI();                                         /* 割り込み禁止設定 */

        /* デフォルト値設定 */
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] 
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_0 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_1 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_2 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_3 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_4 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_5 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_6 ];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ]
                                = xng_lin_slot_tbl[ u1a_lin_frm ].u1g_lin_def[ U1G_LIN_7 ];

    	l_vod_lin_EI();                                         /* 割り込み許可     */

    }
    /* 引数値が範囲外の場合 なにもしない */
}
#endif


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/**************************************************/
/*  バッファスロットFAIL値設定処理(API)           */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm: フレーム名                */
/*  戻値： なし                                   */
/**************************************************/
void  l_slot_set_fail(l_frame_handle  u1a_lin_frm)
{
    /* 引数値が範囲内の場合 */
    if( U1G_LIN_MAX_SLOT > u1a_lin_frm ) {

        l_vod_lin_DI();                                         /* 割り込み禁止設定 */

        /* フェイル値設定 */
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_0];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_1 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_1];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_2 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_2];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_3 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_3];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_4 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_4];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_5 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_5];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_6 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_6];
        xng_lin_frm_buf[ u1a_lin_frm ].xng_lin_data.u1g_lin_byte[ U1G_LIN_7 ]
                                = xng_lin_slot_tbl[u1a_lin_frm].u1g_lin_fail[U1G_LIN_7];

        l_vod_lin_EI();                                         /* 割り込み許可     */

    }
    /* 引数値が範囲外の場合 なにもしない */
}
#endif


/**************************************************/
/*  RUN状態移行 処理(API)                         */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_run(void)
{
    l_vod_lin_DI();                                                             /* 割り込み禁止設定 */

    /* SLEEP状態の場合 */
    if( U1G_LIN_STS_SLEEP == xng_lin_sts_buf.u1g_lin_sts ) {
        /* RUN STANDBY状態へ移行 */
        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_RUN_STANDBY;
        l_ifc_init_drv();                                                       /* ドライバ部の初期化 */
        l_vog_lin_int_dis();                                                    /* INT割り込み禁止 */
    }
    /* SLEEP以外の場合 なにもしない */

    l_vod_lin_EI();                                                             /* 割り込み許可     */
}


/**************************************************/
/*  受信割り込み発生                              */
/*------------------------------------------------*/
/*  引数： u1a_lin_data : LINステータス情報       */
/*         u1a_lin_id   : 受信したID              */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_rx_int(l_u8 u1a_lin_data, l_u8 u1a_lin_id)
{
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
    l_u8    u1a_lin_is_valid;
#endif
    l_u8    u1a_lin_result_tmp;
    l_u8    u1a_lin_rs_tmp[U1G_LIN_DL_8];
    
    /** RUN_STANDBY状態 **/
    if( U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts ) {
        if( U1G_LIN_BYTE_CLR != (u1a_lin_data & U1G_LIN_HDR_RCVED_MASK) ) {
            /* エラーを確定する */
            l_vog_lin_determine_ResTooShort_or_NoRes(u1l_lin_lst_d1rc_state);       /* Response too short / No response を確定する */
            u1l_lin_lst_d1rc_state = U1G_LIN_LST_D1RC_INCOMPLETE;                   /* データ1受信完了の内部状態をクリアする */

#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
            u1a_lin_is_valid = l_u1g_lin_is_valid_baud_rate();                      /* ヘッダ受信時のボー・レート妥当性判断処理 */
            /* 検出されたボー・レートが指定されたボー・レートの範囲に収まっているか */
            if( U1G_LIN_OK == u1a_lin_is_valid ) {
#endif
                /* ヘッダの受信完了 */
                xng_lin_sts_buf.u1g_lin_sts    = U1G_LIN_STS_RUN;                   /* RUN状態へ移行 */
#if U1G_LIN_ERRCLR_PRE_RUN == U1G_LIN_ERRCLR_ON
                xnl_lin_bus_sts.u1g_lin_head_err               = U1G_LIN_BIT_CLR;   /* LINバスステータス Headerエラークリア */
                xng_lin_sts_buf.u1g_lin_e_uart = U1G_LIN_BYTE_CLR;
                xng_lin_sts_buf.u1g_lin_e_sync = U1G_LIN_BYTE_CLR;
                xng_lin_sts_buf.u1g_lin_e_pari = U1G_LIN_BYTE_CLR;
#endif
                l_vog_lin_int_dis();                                                /* INT割り込み禁止 */
                l_vol_lin_sub_hdr_rcv( u1a_lin_id );                                /* ヘッダ受信時処理 */
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
            }
            /* 検出されたボー・レートが指定されたボー・レートの範囲に収まっているない場合 */
            else {
                u1a_lin_result_tmp = l_u1g_lin_resp_noreq();                        /* レスポンスなし要求 */
                if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                    u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                         /* システム異常(MCUステータス) */
                }
                xnl_lin_bus_sts.u1g_lin_head_err                = U1G_LIN_BIT_SET;  /* Headerエラー */
                xng_lin_sts_buf.u1g_lin_e_sync                  = U1G_LIN_BIT_SET;  /* Synch Fieldエラー */
                l_hook_err(U1G_LIN_ID_DUMMY, U2G_LIN_ERRINFO_HDR_SYNC);             /* エラー時フック処理 */
            }
#endif
        }
    }
    /** RUN状態 **/
    else if( U1G_LIN_STS_RUN == xng_lin_sts_buf.u1g_lin_sts ) {
        if( U1G_LIN_BYTE_CLR != (u1a_lin_data & U1G_LIN_RESP_RCVED_MASK) ) {
            /* 受信完了 */
            /* SLEEPコマンドID(=3Ch)の場合 */
            if( U1G_LIN_SLEEP_ID == xnl_lin_id_sl.u1g_lin_id ) {
                /* フレーム[定義あり]の場合 */
                if( U1G_LIN_NO_FRAME != xnl_lin_id_sl.u1g_lin_slot ) {
                    /* LINバッファにデータを格納(取得は8byte固定) */
                    l_vog_lin_get_rcvdata( xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte );

                    /* 1バイト目のデータが00hの場合 */
                    if( U1G_LIN_SLEEP_DATA == xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ] ) {
                        /* SLEEPコマンドとして受信 */
                        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_SLEEP;                    /* SLEEP状態に移行 */
                        xnl_lin_bus_sts.u1g_lin_goto_sleep = U1G_LIN_BIT_SET;               /*GoToSleepコマンドフラグセット*/
                        l_vog_lin_int_enb();                                                /* ウェイクアップ検出許可 */

                        /* 送受信ステータスをreadyに設定する（フレーム定義ありの場合） */
                        xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_status =  U1G_LIN_BIT_CLR;

                        u1a_lin_result_tmp = l_u1g_lin_set_reset();                         /* LINモジュールRESETモード設定 */
                        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                         /* システム異常(MCUステータス) */
                        }
                        l_hook_sleep();                                                     /* Sleep時Hook処理 */
                    }
                    /* 1バイト目のデータが00h以外の場合 */
                    else{
                        /* 通常フレームとして受信 */
                        l_vol_lin_set_frm_complete( U1G_LIN_ERR_OFF );              /* 転送成功 */
                        l_hook_rcv_comp(xnl_lin_id_sl.u1g_lin_slot);                /* 受信完了時フック処理 */
                    }
                }
                /* フレーム[未定義]の場合 */
                else{
                    /* テンポラリバッファにデータを格納(取得は8byte固定) */
                    l_vog_lin_get_rcvdata( u1a_lin_rs_tmp );

                    /* 1バイト目のデータが00hの場合 */
                    if( U1G_LIN_SLEEP_DATA == u1a_lin_rs_tmp[ U1G_LIN_0 ] ) {
                        /* SLEEPコマンドとして受信 */
                        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_SLEEP;                    /* SLEEP状態に移行 */
                        xnl_lin_bus_sts.u1g_lin_goto_sleep = U1G_LIN_BIT_SET;               /*GoToSleepコマンドフラグセット*/
                        l_vog_lin_int_enb();                                                /* ウェイクアップ検出許可 */

                        u1a_lin_result_tmp = l_u1g_lin_set_reset();                         /* LINモジュールRESETモード設定 */
                        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                         /* システム異常(MCUステータス) */
                        }
                        l_hook_sleep();                                                     /* Sleep時Hook処理 */
                    }
                    /* 1バイト目のデータが00h以外の場合 */
                    else{
                        /* 何もせずに Break Field受信待ち状態にする */
                    }
                }
                u1l_lin_hdr_rcved = U1G_LIN_HDR_NOT_RCVED;                  /* ヘッダ未受信に戻す */
            }
             /* SLEEPコマンド以外のID の場合 */
            else{
                /* フレーム定義ありの場合 */
                if( U1G_LIN_NO_FRAME != xnl_lin_id_sl.u1g_lin_slot ) {
                    /* 通常フレームとして受信 */
                    /* LINバッファにデータを格納(取得は8byte固定) */
                    l_vog_lin_get_rcvdata( xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte );
                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_OFF );              /* 転送成功 */
                    l_hook_rcv_comp(xnl_lin_id_sl.u1g_lin_slot);                /* 受信完了時フック処理 */
                }
                /* フレーム未定義の場合 */
                else{
                    /* 何もせずに Break Field受信待ち状態にする */
                }
            }
        }
        else if( U1G_LIN_BYTE_CLR != (u1a_lin_data & U1G_LIN_HDR_RCVED_MASK) ) {
            /* エラーを確定する */
            l_vog_lin_determine_ResTooShort_or_NoRes(u1l_lin_lst_d1rc_state);       /* Response too short / No response を確定する */
            u1l_lin_lst_d1rc_state = U1G_LIN_LST_D1RC_INCOMPLETE;                   /* データ1受信完了の内部状態をクリアする */

#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
            u1a_lin_is_valid = l_u1g_lin_is_valid_baud_rate();                      /* ヘッダ受信時のボー・レート妥当性判断処理 */
            /* 検出されたボー・レートが指定されたボー・レートの範囲に収まっているか */
            if( U1G_LIN_OK == u1a_lin_is_valid ) {
#endif
                /* ヘッダの受信完了 */
                l_vol_lin_sub_hdr_rcv( u1a_lin_id );                                /* ヘッダ受信時処理 */
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
            }
            /* 検出されたボー・レートが指定されたボー・レートの範囲に収まっているない場合 */
            else {
                u1a_lin_result_tmp = l_u1g_lin_resp_noreq();                        /* レスポンスなし要求 */
                if( U1G_LIN_OK != u1a_lin_result_tmp ) {
                    u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                         /* システム異常(MCUステータス) */
                }
                xnl_lin_bus_sts.u1g_lin_head_err                = U1G_LIN_BIT_SET;  /* Headerエラー */
                xng_lin_sts_buf.u1g_lin_e_sync                  = U1G_LIN_BIT_SET;  /* Synch Fieldエラー */
                l_hook_err(U1G_LIN_ID_DUMMY, U2G_LIN_ERRINFO_HDR_SYNC);             /* エラー時フック処理 */
            }
#endif
        }
        else{
            /* 通常は発生しない処理 */
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                             /* システム異常(ドライバ) */
        }
    }
    /** RESET状態、異常値 **/
    else{
        /* 通常は発生しない処理 */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;                                   /* システム異常(ステータス) */
    }

}

/**************************************************/
/*  Response too short時確定処理                  */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void l_vog_lin_ResTooShort_error(void)
{
    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_res_sht = U1G_LIN_BIT_SET;
    l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                           /* エラーありレスポンス完了 */
    l_hook_err(xnl_lin_id_sl.u1g_lin_slot, U2G_LIN_ERRINFO_RSP_RESSHT);     /* エラー時フック処理 */
}

/**************************************************/
/*  No response時確定処理                         */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void l_vog_lin_NoRes_error(void)
{
    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_nores = U1G_LIN_BIT_SET;
    l_vol_lin_set_frm_complete( U1G_LIN_ERR_NORES );                       /* No response完了 */
    l_hook_err(xnl_lin_id_sl.u1g_lin_slot, U2G_LIN_ERRINFO_RSP_NORES);     /* エラー時フック処理 */
}

/**************************************************/
/*  LINヘッダ受信完了時処理                       */
/*------------------------------------------------*/
/*  引数： u1a_lin_id   : 受信したID              */
/*  戻値： なし                                   */
/**************************************************/
static void  l_vol_lin_sub_hdr_rcv(l_u8 u1a_lin_id)
{
    l_u8    u1a_lin_result;

    u2l_lin_bus_inactive_cnt                             = U2G_LIN_WORD_CLR;    /* Bus inactive検出用カウンタ クリア */
    xng_lin_sts_buf.u1g_lin_bus_inactive                 = U1G_LIN_BIT_CLR;     /* Bus inactive検出フラグクリア */
    xnl_lin_bus_sts.u1g_lin_bus_err                      = U1G_LIN_BIT_CLR;     /* Bus異常フラグクリア */

    xnl_lin_id_sl.u1g_lin_id   = (l_u8)( u1a_lin_id & U1G_LIN_ID_PARITY_MASK ); /* ID取得 */
    xnl_lin_id_sl.u1g_lin_slot = u1g_lin_id_tbl[ xnl_lin_id_sl.u1g_lin_id ];

    /* SLEEPコマンドIDを受信した場合(必ずレスポンス受信動作となる) */
    if( U1G_LIN_SLEEP_ID == xnl_lin_id_sl.u1g_lin_id ) {
        /* フレームが[定義] かつ LINバッファのスロットが[未使用設定]の場合 */
        if( (U1G_LIN_NO_FRAME != xnl_lin_id_sl.u1g_lin_slot)
         && (U1G_LIN_BIT_SET == xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_no_use) ) {
            xnl_lin_id_sl.u1g_lin_slot = U1G_LIN_NO_FRAME;              /* フレーム[未定義]に変更 */
        }

        u1a_lin_result = l_u1g_lin_resp_rcv_start( U1G_LIN_DL_8, U1G_LIN_SUM_CLASSIC ); /* レスポンス受信開始 */
        if( U1G_LIN_OK != u1a_lin_result ) {
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                     /* システム異常(MCUステータス) */
        }
        else{
            /* フレームが[定義]の場合のみ */
            /* 送受信ステータスをbusyに設定する */
            if( U1G_LIN_NO_FRAME != xnl_lin_id_sl.u1g_lin_slot ) {
                xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_status =  U1G_LIN_BIT_SET;
            }
            else{
                /* 何もしない（未定義/未使用のため、エラー検出対象としない） */
            }
            u1l_lin_hdr_rcved = U1G_LIN_HDR_RCVED;                      /* 有効ヘッダ受信済み */
        }
    }
    /* SLEEPコマンド以外の場合 */
    else{
        /* フレームが[未定義] もしくは LINバッファのスロットが[未使用設定]の場合 */
        if( (U1G_LIN_NO_FRAME == xnl_lin_id_sl.u1g_lin_slot)
         || (U1G_LIN_BIT_SET == xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_no_use) ) {

            u1a_lin_result = l_u1g_lin_resp_noreq();                    /* レスポンスなし要求 */

            if( U1G_LIN_OK != u1a_lin_result ) {
                u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;                 /* システム異常(MCUステータス) */
            }
        }
        /* 処理対象フレームの場合 */
        else{
            /*-- [受信フレーム時] --*/
            if( U1G_LIN_CMD_RCV == xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_sndrcv ) {
                u1a_lin_result = l_u1g_lin_resp_rcv_start( xng_lin_slot_tbl[xnl_lin_id_sl.u1g_lin_slot].u1g_lin_frm_sz,
                                            xng_lin_slot_tbl[xnl_lin_id_sl.u1g_lin_slot].u1g_lin_sum_type );    /* レスポンス受信開始 */
                if( U1G_LIN_OK != u1a_lin_result ) {
                    u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;             /* システム異常(MCUステータス) */
                }
                else{
                    /* 送受信ステータスをbusyに設定する */
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_status =  U1G_LIN_BIT_SET;
                    u1l_lin_hdr_rcved = U1G_LIN_HDR_RCVED;              /* 有効ヘッダ受信済み */
                }
            }
            /*-- [送信フレーム時] --*/
            else if( U1G_LIN_CMD_SND == xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_sndrcv ) {
            
                /* NM使用設定フレームの場合 */
                if( U1G_LIN_NM_USE == xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_nm_use ) {
                    /* LINフレームバッファのNM部分(データ1のbit4-7)をクリア */
                    /* NM部分のクリア */
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                     &= U1G_LIN_BUF_NM_CLR_MASK;
                    /* LINフレームに レスポンス送信ステータスをセット */
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte[ U1G_LIN_0 ]
                     |= (l_u8)( u1l_lin_nm_info & U1G_LIN_NM_INFO_MASK );
                }

                u1a_lin_result = l_u1g_lin_resp_snd_start( xng_lin_slot_tbl[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_frm_sz,
                                            xng_lin_slot_tbl[xnl_lin_id_sl.u1g_lin_slot].u1g_lin_sum_type,
                                            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].xng_lin_data.u1g_lin_byte );  /* レスポンス送信開始 */

                if( U1G_LIN_OK != u1a_lin_result ) {
                    u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;             /* システム異常(MCUステータス) */
                }
                else{
                    /* 送受信ステータスをbusyに設定する */
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_status =  U1G_LIN_BIT_SET;
                    u1l_lin_hdr_rcved = U1G_LIN_HDR_RCVED;              /* 有効ヘッダ受信済み */
                }
            }
            /*-- [送信でも受信でもない] --*/
            else{
                /* 登録エラー */
                u1a_lin_result = l_u1g_lin_resp_noreq();                /* レスポンスなし要求 */

                if( U1G_LIN_OK != u1a_lin_result ) {
                    u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;             /* システム異常(ドライバ */
                }
            }
        }
    }
}


/**************************************************/
/*  LIN送信完了割り込み発生                       */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void l_vog_lin_tx_int(void)
{
    l_u8 u1a_lin_result_tmp;

    /** RUN状態 **/
    if( U1G_LIN_STS_RUN == xng_lin_sts_buf.u1g_lin_sts ) {
        /* レスポンス送信完了 */
        l_vol_lin_set_frm_complete( U1G_LIN_ERR_OFF );          /* 転送成功 */
        l_hook_snd_comp(xnl_lin_id_sl.u1g_lin_slot);            /* 送信完了時フック処理 */
    }
    /** SLEEP状態 **/
    else if( U1G_LIN_STS_SLEEP == xng_lin_sts_buf.u1g_lin_sts ) {
        /* ウェイクアップ送信完了 */
        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_RUN_STANDBY;
        l_ifc_init_drv();                                       /* LINドライバ部の初期化 */
        /* ※ウェイクアップ送信開始時にl_vog_lin_int_dis()実行済みであるため、ここでは不要  */
    }
    /** RUN_STANDBY状態 **/
    else if( U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts ) {
        /* ウェイクアップ送信完了 */
        u1a_lin_result_tmp = l_u1g_lin_set_run();               /* LINモジュール通信可能状態設定 */
        if( U1G_LIN_OK != u1a_lin_result_tmp ) {
            u1g_lin_syserr = U1G_LIN_SYSERR_DRIVER;             /* システム異常(MCUステータス) */
        }
    }
    /** RESET状態、異常値 **/
    else{
        /* 通常は発生しない処理 */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;                   /* システム異常(ステータス) */
    }
}


/**************************************************/
/*  LINエラー割り込み発生                         */
/*------------------------------------------------*/
/*  引数： u1a_lin_err       : エラー情報         */
/*         u1a_lin_lst_data  : LINステータス情報  */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_err_int(l_u8 u1a_lin_err, l_u8 u1a_lin_lst_data )
{
    /** RUN状態 または RUN_STANDBY状態 **/
    if(   (U1G_LIN_STS_RUN == xng_lin_sts_buf.u1g_lin_sts)
       || (U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts) ) {

        l_vog_lin_determine_ResTooShort_or_NoRes(u1l_lin_lst_d1rc_state);               /* Response too short / No response を確定する */
        u1l_lin_lst_d1rc_state = U1G_LIN_LST_D1RC_INCOMPLETE;                           /* データ1受信完了の内部状態をクリアする */

        if( U1G_LIN_HDR_NOT_RCVED == u1l_lin_hdr_rcved ) {
            /* Synch Field Error */
            if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_SF_ERR_MASK) ) {
                xnl_lin_bus_sts.u1g_lin_head_err                = U1G_LIN_BIT_SET;      /* Headerエラー */
                xng_lin_sts_buf.u1g_lin_e_sync                  = U1G_LIN_BIT_SET;      /* Synch Fieldエラー */
                l_hook_err(U1G_LIN_ID_DUMMY, U2G_LIN_ERRINFO_HDR_SYNC);                 /* エラー時フック処理 */
            }
            /* ID parity Error */
            else if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_ID_ERR_MASK) ) {
                xnl_lin_bus_sts.u1g_lin_head_err                = U1G_LIN_BIT_SET;      /* Headerエラー */
                xng_lin_sts_buf.u1g_lin_e_pari                  = U1G_LIN_BIT_SET;      /* PARITYエラー */
                l_hook_err(U1G_LIN_ID_DUMMY, U2G_LIN_ERRINFO_HDR_PARI);                 /* エラー時フック処理 */
            }
            /* Framing Error */
            else if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_FRA_ERR_MASK) ) {
                xnl_lin_bus_sts.u1g_lin_head_err                = U1G_LIN_BIT_SET;      /* Headerエラー */
                xng_lin_sts_buf.u1g_lin_e_uart                  = U1G_LIN_BIT_SET;      /* UARTエラー */
                l_hook_err(U1G_LIN_ID_DUMMY, U2G_LIN_ERRINFO_HDR_UART);                 /* エラー時フック処理 */
            }
            else{
                /* 何もしない  ヘッダ受信フラグ異常、エラーフラグ異常、未定義Sleepコマンド時のいずれか */
            }
        }
        else if( U1G_LIN_HDR_RCVED == u1l_lin_hdr_rcved ) {
            /* SLEEPコマンドIDで、フレーム未定義の場合 */
            if( (U1G_LIN_SLEEP_ID == xnl_lin_id_sl.u1g_lin_id) && (U1G_LIN_NO_FRAME == xnl_lin_id_sl.u1g_lin_slot) ) {
                u1l_lin_hdr_rcved = U1G_LIN_HDR_NOT_RCVED;      /* ヘッダ未受信に戻す */
            }
            /* SLEEPコマンドIDではない、もしくはフレーム定義ありの場合 */
            else{
                /* Bit Error */
                if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_BIT_ERR_MASK) ) {
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_bit = U1G_LIN_BIT_SET;
                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                       /* エラーありレスポンス完了 */
                    l_hook_err(xnl_lin_id_sl.u1g_lin_slot, U2G_LIN_ERRINFO_RSP_BIT);       /* エラー時フック処理 */
                }
                /* Framing Error */
                else if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_FRA_ERR_MASK) ) {
                    l_vog_lin_start_timer();                                                /* タイマのカウンタを開始する */
                    /* LINエラー情報からデータ1受信状態を判定し、状態変数を更新する */
                    if(U1G_LIN_BYTE_CLR != (u1a_lin_lst_data & U1G_LIN_LST_D1RC_MASK)){
                        u1l_lin_lst_d1rc_state = U1G_LIN_LST_D1RC_COMPLETE;    
                    }
                }
                /* Check sum Error */
                else if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_CKSUM_ERR_MASK) ) {
                    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_sum = U1G_LIN_BIT_SET;
                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                       /* 転送エラー */
                    l_hook_err(xnl_lin_id_sl.u1g_lin_slot, U2G_LIN_ERRINFO_RSP_SUM);       /* エラー時フック処理 */
                }
                /* レスポンス準備エラー */
                else if( U1G_LIN_BYTE_CLR != (u1a_lin_err & U1G_LIN_RESP_ERR_MASK) ) {
                    /* 通常到達しない見込み   */
                    u1g_lin_syserr = U1G_LIN_SYSERR_STAT;                               /* システム異常(ステータス) */
                    l_vol_lin_set_frm_complete( U1G_LIN_ERR_READY );                      /* レスポンス準備エラー発生 */
                    l_hook_err(xnl_lin_id_sl.u1g_lin_slot, U2G_LIN_ERRINFO_RSP_READY);       /* エラー時フック処理 */
                }
                else{
                    /* 何もしない  ヘッダ受信フラグ異常、エラーフラグ異常のどちらか */
                }
            }
        }
        else{
            /* 何もしない  ヘッダ受信状態異常 */
        }
    }
    /** RESET状態、SLEEP状態、異常値 **/
    else{
        /* 通常は発生しない処理 */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;                   /* システム異常(ステータス) */
    }
}

/**************************************************/
/*  Framing エラー確定処理                        */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_determine_FramingError(void)
{
    xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_uart = U1G_LIN_BIT_SET;
    l_vol_lin_set_frm_complete( U1G_LIN_ERR_ON );                       /* エラーありレスポンス完了 */
    l_hook_err(xnl_lin_id_sl.u1g_lin_slot, U2G_LIN_ERRINFO_RSP_UART);      /* エラー時フック処理 */
}


/**************************************************/
/*  INT割り込み発生                               */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_aux_int(void)
{
    /* SLEEP状態 */
    if( U1G_LIN_STS_SLEEP == xng_lin_sts_buf.u1g_lin_sts ) {
        /* ウェイクアップ検出   RUN STANDBY状態へ移行 */
        xng_lin_sts_buf.u1g_lin_sts = U1G_LIN_STS_RUN_STANDBY;
        l_ifc_init_drv();                           /* ドライバ部の初期化 */
        l_vog_lin_int_dis();                        /* INT割り込み禁止（wake_hook実行のため） */
    }

    /** RUN_STANDBY状態 **/
    else if( U1G_LIN_STS_RUN_STANDBY == xng_lin_sts_buf.u1g_lin_sts ) {
        u1l_lin_wup_det = U1G_LIN_WUP_DET;          /* NM通知のため保持 */
        l_vog_lin_int_dis();                        /* INT割り込み禁止 */
    }
    /** RUN状態、RUN_STANDBY状態、異常値 **/
    else{
        /* 通常起こらない */
        l_vog_lin_int_dis();                        /* INT割り込みを禁止する */
    }
}


/**************************************************/
/*  ウェイクアップ検出フラグ取得処理              */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： ウェイクアップ検出状態                 */
/**************************************************/
l_u8  l_u1g_lin_get_wupflg(void)
{
    l_u8    u1a_lin_result;

    u1a_lin_result  = u1l_lin_wup_det;              /* ウェイクアップ検出フラグ取得 */

    return u1a_lin_result;
}

/**************************************************/
/*  ウェイクアップ検出フラグクリア処理            */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_clr_wupflg(void)
{
    u1l_lin_wup_det = U1G_LIN_WUP_NOT_DET;          /* ウェイクアップ検出フラグクリア */
}

/**************************************************/
/*  ウェイクアップ検出許可処理                    */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_set_int_enb(void)
{
    l_vod_lin_DI();                                 /* 割り込み禁止設定 */

    l_vog_lin_int_enb();                            /* INT割り込み許可 */
    l_hook_sleep();                                 /* Sleep時Hook処理 */

    l_vod_lin_EI();                                 /* 割り込み許可     */
}


/**************************************************/
/*  完了フラグの設定処理                          */
/*------------------------------------------------*/
/*  引数： u1a_lin_err : 完了状態                 */
/*         (0 / 1) : 正常完了 / 異常完了          */
/*  戻値： なし                                   */
/**************************************************/
static void  l_vol_lin_set_frm_complete(l_u8  u1a_lin_err)
{
    /* 転送成功、もしくは転送エラーのフラグが立っている場合(オーバーラン) */
    if( U1G_LIN_BYTE_CLR != (xnl_lin_bus_sts.u1g_lin_err_resp | xnl_lin_bus_sts.u1g_lin_ok_resp) ) {
        xnl_lin_bus_sts.u1g_lin_ovr_run = U1G_LIN_BIT_SET;                      /* オーバーラン */
    }
    /* 異常完了の場合 */
    if( U1G_LIN_ERR_ON == u1a_lin_err ) {
        xnl_lin_bus_sts.u1g_lin_err_resp = U1G_LIN_BIT_SET;                     /* エラー有りレスポンス */
    }
    /* 正常完了の場合 */
    else if( U1G_LIN_ERR_OFF == u1a_lin_err ) {
        xnl_lin_bus_sts.u1g_lin_ok_resp = U1G_LIN_BIT_SET;                      /* 正常完了 */
        if( U1G_LIN_MAX_SLOT > xnl_lin_id_sl.u1g_lin_slot ) {
            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_nores = U1G_LIN_BYTE_CLR;
            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_uart = U1G_LIN_BYTE_CLR;
            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_bit = U1G_LIN_BYTE_CLR;
            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_sum = U1G_LIN_BYTE_CLR;
            xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_e_res_sht = U1G_LIN_BYTE_CLR;
        }
    }
    /* No Response、レスポンス準備エラー発生の場合 */
    else {
        /* Does Nothing */
    }

    /* 保護IDのセット */
    xnl_lin_bus_sts.u1g_lin_last_id = u1g_lin_protid_tbl[ xnl_lin_id_sl.u1g_lin_id ];

    if( U1G_LIN_MAX_SLOT > xnl_lin_id_sl.u1g_lin_slot ) {

        /* 正常完了の場合にのみ完了フラグをセット */
        if( U1G_LIN_ERR_OFF == u1a_lin_err ) {
            /* 送受信処理完了フラグのセット */
            if( U1G_LIN_16 > xnl_lin_id_sl.u1g_lin_slot ) {
                xng_lin_sts_buf.un_rs_flg1.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot ];
            }
            else if( U1G_LIN_32 > xnl_lin_id_sl.u1g_lin_slot ) {
                xng_lin_sts_buf.un_rs_flg2.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot - U1G_LIN_16 ];
            }
            else if( U1G_LIN_48 > xnl_lin_id_sl.u1g_lin_slot ) {
                xng_lin_sts_buf.un_rs_flg3.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot - U1G_LIN_32 ];
            }
            else if( U1G_LIN_64 > xnl_lin_id_sl.u1g_lin_slot ) {
                xng_lin_sts_buf.un_rs_flg4.u2g_lin_word |= u2g_lin_flg_set_tbl[ xnl_lin_id_sl.u1g_lin_slot - U1G_LIN_48 ];
            }
            else {
                /* 通常発生しないので処理なし */
            }
        }
        /* 送受信ステータスをreadyに設定する */
        xng_lin_frm_buf[ xnl_lin_id_sl.u1g_lin_slot ].u1g_lin_status =  U1G_LIN_BIT_CLR;
    }

    u1l_lin_hdr_rcved = U1G_LIN_HDR_NOT_RCVED;                                  /* ヘッダ未受信に戻す */
}


/**************************************************/
/*  NM情報データのセット 処理                     */
/*------------------------------------------------*/
/*  引数： u1a_lin_nm_info : NM情報データ         */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_set_nm_info( l_u8  u1a_lin_nm_info )
{
    u1l_lin_nm_info = u1a_lin_nm_info;
}


/***** End of File *****/


/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_core_rl78f24.h                       */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_CORE_RL78F24_H_INCLUDE
#define L_SLIN_CORE_RL78F24_H_INCLUDE

/*** 定数定義 ***/

#define  U1G_LIN_SLEEP_ID               ((l_u8)0x3CU)   /* SLEEPコマンドID = 3Ch  */
#define  U1G_LIN_SLEEP_DATA             ((l_u8)0x00U)   /* SLEEPコマンドのData0 = 0x00 */

#define  U2G_LIN_STSBUF_CLR             ((l_u16)0xFF00U)/* リード用ステータスバッファのクリア値 */

#define  U1G_LIN_ID_PARITY_MASK         ((l_u8)0x3FU)   /* 保護IDパリティビットマスク(3Fh) */

#define  U2G_LIN_BUS_STS_CMP_SET        ((l_u16)0x0003U)/* 転送完了かエラー応答完了がセットされている */

#define  U1G_LIN_BUF_NM_CLR_MASK        ((l_u8)0x2FU)   /* LINフレームバッファのNM部分(Data1 bit4-7)クリアマスク  ※data.ind(b5)は触らない */
#define  U1G_LIN_NM_INFO_MASK           ((l_u8)0xD0U)   /* NM情報テーブルのreserve部 クリア用マスク */

#define  U1G_LIN_ERR_OFF                ((l_u8)0U)      /* 正常に転送完了 */
#define  U1G_LIN_ERR_ON                 ((l_u8)1U)      /* エラーありレスポンス完了 */
#define  U1G_LIN_ERR_NORES              ((l_u8)2U)      /* No response完了 */
#define  U1G_LIN_ERR_READY              ((l_u8)3U)      /* レスポンス準備エラー発生 */

#define  U1G_LIN_HDR_NOT_RCVED          ((l_u8)0U)      /* ヘッダ未受信 */
#define  U1G_LIN_HDR_RCVED              ((l_u8)1U)      /* ヘッダ受信後（有効なID） */

#define  U1G_LIN_BIT_ERR_MASK           ((l_u8)0x01U)   /* Bitエラーマスク */
#define  U1G_LIN_FRA_ERR_MASK           ((l_u8)0x08U)   /* Framingエラーマスク */
#define  U1G_LIN_SF_ERR_MASK            ((l_u8)0x10U)   /* SyncFieldエラーマスク */
#define  U1G_LIN_CKSUM_ERR_MASK         ((l_u8)0x20U)   /* Checksumエラーマスク */
#define  U1G_LIN_ID_ERR_MASK            ((l_u8)0x40U)   /* ID parityエラーマスク */
#define  U1G_LIN_RESP_ERR_MASK          ((l_u8)0x80U)   /* レスポンス準備エラーマスク */

#define  U1G_LIN_HDR_RCVED_MASK         ((l_u8)0x80U)   /* ヘッダ受信完了値マスク */
#define  U1G_LIN_RESP_RCVED_MASK        ((l_u8)0x02U)   /* レスポンス受信完了値マスク */

#define  U1G_LIN_BUS_STS_OK_RESP        ((l_u8)0x01U)   /* 正常終了データのビットシフト数 */
#define  U1G_LIN_BUS_STS_OVR_RUN        ((l_u8)0x02U)   /* オーバーランのビットシフト数 */
#define  U1G_LIN_BUS_STS_GOTO_SLEEP     ((l_u8)0x03U)   /* GoTo Sleepのビットシフト数 */
#define  U1G_LIN_BUS_STS_BUS_ERR        ((l_u8)0x06U)   /* バスエラーのビットシフト数 */
#define  U1G_LIN_BUS_STS_HEAD_ERR       ((l_u8)0x07U)   /* ヘッダエラーのビットシフト数 */
#define  U1G_LIN_BUS_STS_LAST_ID        ((l_u8)0x08U)   /* LastIDのビットシフト数 */

#define  U1G_LIN_LST_D1RC_INCOMPLETE    ((l_u8)0x00U)   /* データ1受信 未完了 */
#define  U1G_LIN_LST_D1RC_COMPLETE      ((l_u8)0x01U)   /* データ1受信 完了 */

/*** テーブル構造定義 ***/
/* 現在処理しているフレームのIDとスロット番号を管理 */
typedef struct {
    l_u8  u1g_lin_id;                       /* ID (00h-3Fh)            */
    l_u8  u1g_lin_slot;                     /* SLOT No. (00h-3Fh、FFh) */
} st_lin_id_slot_type;


/*** 関数のプロトタイプ宣言(global) ***/
void  l_vog_lin_rx_int(l_u8 u1a_lin_data, l_u8 u1a_lin_id);
void  l_vog_lin_tx_int(void);
void  l_vog_lin_err_int(l_u8 u1a_lin_err,l_u8 u1a_lin_lst_data);
void  l_vog_lin_aux_int(void);
l_u8  l_u1g_lin_get_wupflg(void);
void  l_vog_lin_clr_wupflg(void);
void  l_vog_lin_set_int_enb(void);
void  l_vog_lin_set_nm_info( l_u8  u1a_lin_nm_info );
void  l_vog_lin_determine_FramingError(void);
void  l_vog_lin_ResTooShort_error(void);
void  l_vog_lin_NoRes_error(void);

#endif

/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_def.h                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_DEF_H_INCLUDE
#define L_SLIN_DEF_H_INCLUDE

/*** 定数定義 ***/
#define  U1G_LIN_NAD                ((l_u8)0x01U)                 /* ノードアドレス */

#define  U1G_LIN_MAX_SLOT           ((l_u8)8U)                    /* 最大LINバッファスロット数 */
#define  U1G_LIN_CLK_SRC            (U1G_LIN_CLKSRC_FCLK)         /*  LINモジュールへ供給するクロックソースの選択 */
#define  U1G_LIN_CLK                (40U)                         /*  LINモジュールへ供給するクロック周波数  MHz単位  */
#define  U1G_LIN_BAUDRATE           (U1G_LIN_BAUDRATE_19200)      /* 設定ボーレートの選択 */
#define  U1G_LIN_CH                 (U1G_LIN_LINCH_0)             /* 使用するLINチャネルの選択 */
#define  U1G_LIN_RSSP               ((l_u8)1U)                    /* Response space */
#define  U1G_LIN_BTSP               ((l_u8)1U)                    /* Inter-byte space */
#define  U1G_LIN_WUP                ((l_u8)7U)                    /* ウェイクアップ信号送出幅(Tbits) */
#define  U1G_LIN_TRM_INTLEVEL       ((l_u8)2U)                    /* LIN送信完了割り込みレベル設定値 */
#define  U1G_LIN_RVC_INTLEVEL       ((l_u8)2U)                    /* LIN受信完了割り込みレベル設定値 */
#define  U1G_LIN_STA_INTLEVEL       ((l_u8)2U)                    /* LINステータスエラー割り込みレベル設定値 */
#define  U1G_LIN_WUP_INTLEVEL       ((l_u8)2U)                    /* LIN受信端子入力割り込みレベル設定値 */
#define  U2G_LIN_TIME_BASE          ((l_u16)5U)                   /* タイムベース時間の設定(ms) */
#define  U2G_LIN_BUS_TIMEOUT        ((l_u16)4100U)                /* Bus inactive時間の設定（ms）*/
#define  U1G_LIN_ENDIAN_TYPE        (U1G_LIN_ENDIAN_LITTLE)       /* エンディアンタイプの選択 */
#define  U1G_LIN_ERRCLR_PRE_RUN     (U1G_LIN_ERRCLR_ON)           /* RUN状態遷移時のヘッダエラークリア実施/不実施 */
#define  U1G_LIN_ROM_SHRINK         (U1G_LIN_ROM_SHRINK_OFF)      /* ROM削減(未使用APIの削除)実施/不実施 */
#define  U1G_LIN_BAUD_RATE_DETECT   (U1G_LIN_BAUD_RATE_DETECT_ON) /* オートボーレート機能の有効/無効 */
#define  U2G_LIN_MINIMUM_LBRP       ((l_u16)56U)                  /* オートボーレート時における許容されるLBRPの最小値 */
#define  U2G_LIN_MAXIMUM_LBRP       ((l_u16)75U)                  /* オートボーレート時における許容されるLBRPの最大値 */
/* TLIN仕様では、狙いのボーレート±14%以内のボーレートを許容することが求められるため19200の±14%以内の値をdefault値とする、 */
/* (40[MHz](U1G_LIN_CLK) ÷ 4(LPRS) ÷ 19200[bps](ボーレート) ÷ 8(NSPB) ) ±14% (小数点は範囲が広がる方向へ切り上げ・切り捨て) -1(LBRPは設定値+1されるため) */
/* ※LPRS値はU1G_LIN_CLKの設定値に依存することに注意する */
#define  U1G_LIN_BREAK_LENGTH       (U1G_LIN_BREAK_LENGTH_11BITS) /* Break検出幅 */
#define  U1G_LIN_TIMER_CLK          ((l_u8)40U)                   /* TAUモジュールへ供給するクロック周波数(fCLK)  MHz単位  */
#define  U1G_LIN_TIMER_UNIT         (U1G_LIN_TIMER_UNIT_1)        /* TAUユニット設定, 0~1 から選択する */
#define  U1G_LIN_TIMER_CH           (U1G_LIN_TIMER_CH_7)          /* TAUチャネル設定, 0~7 から選択する */
#define  U1G_LIN_TIMER_CKMK         (U1G_LIN_TIMER_CKMK_M3)       /* TAU動作クロック(fMCK)設定, CKm0~CKm3 から選択する */
#define  U1G_LIN_TIMER_INTLEVEL     ((l_u8)2U)                    /* TAUカウント完了割り込みレベル設定値 */

#endif

/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_drv_rl78f24.c                        */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/
/* LINライブラリ ROMセクション定義 */
#pragma section  text   @@LNCD
#pragma section  text  @@LNCDL
#pragma section  const   @@LNCNS
#pragma section  const  @@LNCNSL
/* LINライブラリ RAMセクション定義 */
#pragma section  bss   @@LNDT
#pragma section  bss  @@LNDTL


/***** ヘッダ インクルード *****/
#include "l_slin_user.h"
#include "l_slin_sfr.h"
#include "l_slin_core_rl78f24.h"
#include "l_slin_drv_rl78f24.h"
#include "aipf_cpu.h"


/***** 関数プロトタイプ宣言 *****/
/*-- その他 MCU依存関数(static) --*/
static l_u8  l_u1l_lin_linmodule_set_reset(void);

/*** 変数(static) ***/


/**************************************************/

/********************************/
/* MCU依存のAPI関数処理         */
/********************************/
/**************************************************/
/*  LINモジュールの初期化 処理                    */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_u8  l_u1g_lin_linmodule_init(void)
{
    l_u16   u2a_lin_lp_cnt;
    l_u8    u1a_lin_result;
    l_u8    u1a_lin_tmp_lmst;

    u1a_lin_result = U1G_LIN_OK;

    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_CSC & AIPF_CPU_SFRGRD_ID_INT );/* SFRガード機能 無効化(GCSC、GINT) */

    /* クロックを供給 */
    U1G_LIN_SFR_BIT_LINEN   = U1G_LIN_BIT_SET;                      /* LINnモジュールへのクロック供給 */
    U1G_LIN_SFR_BIT_LINMCK  = U1G_LIN_LINMCK_SET;                   /* LINnモジュールへ供給するクロック選択 */
    U1G_LIN_SFR_BIT_LINMCKE = U1G_LIN_BIT_SET;                      /* LINnエンジンへのクロック供給 */

    U1G_LIN_SFR_LCHSEL = U1G_LIN_LCHSEL;                            /* LINチャネル選択設定 */

    u1a_lin_tmp_lmst = U1G_LIN_SFR_LMST;
    if( U1G_LIN_LMST_RESET != (u1a_lin_tmp_lmst & U1G_LIN_LMST_RESET_MASK) ) {
        /* リセットモードでなければ、リセットモードへ遷移 */
        U1G_LIN_SFR_LCUC    = U1G_LIN_LCUC_RESET;
        u2a_lin_lp_cnt      = U2G_LIN_0;

        /* リセットモード遷移待ち */
        while( (U2G_LIN_MODE_WAIT2_CNT > u2a_lin_lp_cnt)
            && ( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) ) {
            u2a_lin_lp_cnt++;
        }
        if( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) {
            /* モード遷移失敗 */
            u1a_lin_result = U1G_LIN_NG;
        }
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
        /* オート・ボー・レート時は処理なし */
#else
        else{
            if( U1G_LIN_LMST_RUN == (u1a_lin_tmp_lmst & U1G_LIN_LMST_MASK) ) {
                U1G_LIN_SFR_BIT_LINEN = U1G_LIN_BIT_CLR;            /* LINnモジュールクロック停止 */
                U1G_LIN_SFR_BIT_LINEN = U1G_LIN_BIT_SET;            /* LINnモジュールクロック供給 */
            }
        }
#endif /* U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON */
    }

    if( U1G_LIN_OK == u1a_lin_result ) {
        U1G_LIN_SFR_LWBR = U1G_LIN_LWBR_INIT;                       /* ウェイクアップ、ボーレート設定  2byteのLBRPレジスタの分周で対応可能なため、分周しない */
        U2G_LIN_SFR_LBRP = U2G_LIN_LBRP_INIT;                       /* ボーレートプリスケーラ（リセットモード時に設定） */
        U1G_LIN_SFR_LMD  = U1G_LIN_LMD_INIT;                        /* LINモード スレーブ（固定ボーレート） */
        U1G_LIN_SFR_LBFC = U1G_LIN_LBFC_INIT;                       /* Break検出幅選択 9.5Tbits */
        U1G_LIN_SFR_LSC  = U1G_LIN_LSC_INIT;                        /* LINスペース設定（RS、BS） */
        U1G_LIN_SFR_LWUP = U1G_LIN_SFR_LWUP_INIT;                   /* ウェイクアップ送信幅設定 */
        U1G_LIN_SFR_LIE  = U1G_LIN_LIE_INIT;                        /* 割り込み禁止（リセットモード時に設定） */
        U1G_LIN_SFR_LEDE = U1G_LIN_LEDE_INIT;                       /* エラー検出許可設定（リセットモード時に設定） */
    }

    U1G_LIN_SFR_BIT_LINTRMIF   = U1G_LIN_BIT_CLR;                   /* LINn送信割り込み要求フラグクリア */
    U1G_LIN_SFR_BIT_LINTRMMK   = U1G_LIN_BIT_SET;                   /* LINn送信割り込み禁止(マスク) */
    U1G_LIN_SFR_BIT_LINRVCIF   = U1G_LIN_BIT_CLR;                   /* LINn受信割り込み要求フラグクリア */
    U1G_LIN_SFR_BIT_LINRVCMK   = U1G_LIN_BIT_SET;                   /* LINn受信割り込み割り込み禁止(マスク) */
    U1G_LIN_SFR_BIT_LINSTAIF   = U1G_LIN_BIT_CLR;                   /* LINnステータスエラー割り込み要求フラグクリア */
    U1G_LIN_SFR_BIT_LINSTAMK   = U1G_LIN_BIT_SET;                   /* LINnステータスエラー 割り込み禁止(マスク) */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */
    
    l_vod_lin_EI();                                                 /* 割り込み許可 */

    return( u1a_lin_result );
}

/**************************************************/
/*  TAUモジュールの初期化 処理                    */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_timer_init(void)
{
    l_u16   u2a_lin_tau_tps;

    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_CSC & AIPF_CPU_SFRGRD_ID_INT );/* SFRガード機能 無効化(GCSC、GINT) */

    U1G_LIN_SFR_BIT_TAUEN   = U1G_LIN_BIT_SET;                      /* TAUnモジュールへのクロック供給し、TAUmENを有効化する */

    U1G_LIN_TAU_TT          = U1G_LIN_TT_STOP;                      /* カウント動作を停止する */

    u2a_lin_tau_tps         = U2G_LIN_TAU_TPS;                      /* 自動変数にTPSレジスタの値をコピーする */
    u2a_lin_tau_tps         &= (~U2G_LIN_TPS_CLR);                  /* 使用チャネル用設定ビット 明示クリア */
    u2a_lin_tau_tps         |= U2G_LIN_TPS_INIT;                    /* チャネル n の設定値を書き込む */
    U2G_LIN_TAU_TPS         = u2a_lin_tau_tps;                      /* クロック周波数を設定する */

    U2G_LIN_TAU_TMR = U2G_LIN_TMR_INIT;                             /* タイマ・モードを設定する */

    /* カウンタ値設定 */
    U2G_LIN_TAU_TDR = U2G_LIN_TDR_COUNT_VAL;                        /* TDR レジスタへの格納 */

    U1G_LIN_TAU_TO  &= (l_u8)(~U1G_LIN_TO_INIT);                    /* タイマ出力値を 0 にする */
    U1G_LIN_TAU_TOE &= (l_u8)(~U1G_LIN_TOE_INIT);                   /* タイマの出力を禁止する */

    U1G_LIN_TAU_BIT_TMPR0 =  U1G_LIN_TMPR_PR0;                      /* PR01L.TMPR000 bit, 割り込み優先順位指定フラグ XXPR0X */
    U1G_LIN_TAU_BIT_TMPR1 =  U1G_LIN_TMPR_PR1;                      /* PR11L.TMPR100 bit, 割り込み優先順位指定フラグ XXPR1X */
    U1G_LIN_TAU_BIT_TMIF    = U1G_LIN_BIT_CLR;                      /* 割り込み要求フラグをクリアする */
    U1G_LIN_TAU_BIT_TMMK    = U1G_LIN_BIT_SET;                      /* 割り込み処理を禁止する */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */

    l_vod_lin_EI();                                                 /* 割り込み許可 */

}

/**************************************************/
/*  TAUモジュールのタイマ開始 処理                */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_start_timer(void)
{
    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    U2G_LIN_TAU_TDR         = U2G_LIN_TDR_COUNT_VAL;                /* TDR レジスタへの格納 */

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );              /* SFRガード機能 無効化(GINT) */

    U1G_LIN_TAU_BIT_TMIF    = U1G_LIN_BIT_CLR;                      /* 割り込み要求フラグをクリアする */
    U1G_LIN_TAU_BIT_TMMK    = U1G_LIN_BIT_CLR;                      /* 割り込み処理を許可する */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */

    U1G_LIN_TAU_TS          = U1G_LIN_TS_START;                     /* タイマを開始する */

    l_vod_lin_EI();                                                 /* 割り込み許可 */

}

/**************************************************/
/*  TAUモジュールのタイマ終了 処理                */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_stop_timer(void)
{
    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    /* タイマ開始処理関数(l_vog_lin_start_timer())と対称的な処理順番になるよう設計 */
    U1G_LIN_TAU_TT          = U1G_LIN_TT_STOP;                      /* タイマを停止する */

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );              /* SFRガード機能 無効化(GINT) */

    U1G_LIN_TAU_BIT_TMMK    = U1G_LIN_BIT_SET;                      /* 割り込み処理を禁止する */
    U1G_LIN_TAU_BIT_TMIF    = U1G_LIN_BIT_CLR;                      /* 割り込み要求フラグをクリアする */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */

    l_vod_lin_EI();                                                 /* 割り込み許可 */

}

/***********************************/
/* MCU固有のSFR設定用関数処理      */
/***********************************/

/**************************************************/
/*  INTレジスタの初期化 処理                      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_init(void)
{
    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );              /* SFRガード機能 無効化(GINT) */

    /* INT割り込み初期化 */
    U1G_LIN_SFR_BIT_ISC      = U1G_LIN_BIT_SET;                     /* LRxDnの入力を選択 */
    U1G_LIN_SFR_BIT_EGP      = U1G_LIN_BIT_CLR;                     /* 立ち上がりエッジ検出禁止 */
    U1G_LIN_SFR_BIT_EGN      = U1G_LIN_BIT_SET;                     /* 立ち下がりエッジ検出許可 */
    U1G_LIN_SFR_BIT_LINWUPMK = U1G_LIN_BIT_SET;                     /* INT割り込み禁止 */
    U1G_LIN_SFR_BIT_LINWUPIF = U1G_LIN_BIT_CLR;                     /* 割り込み要求フラグクリア */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */

    l_vod_lin_EI();                                                 /* 割り込み許可 */

}


/**************************************************/
/*  INT割り込み許可 処理                          */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_enb(void)
{
    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );              /* SFRガード機能 無効化(GINT) */
    
    U1G_LIN_SFR_BIT_ISC         = U1G_LIN_BIT_SET;                  /* LRxDnの入力を選択 */
    U1G_LIN_SFR_BIT_EGP         = U1G_LIN_BIT_CLR;                  /* 立ち上がりエッジ検出禁止 */
    U1G_LIN_SFR_BIT_EGN         = U1G_LIN_BIT_SET;                  /* 立ち下がりエッジ検出許可 */
    U1G_LIN_SFR_BIT_LINWUPPR0   = U1G_LIN_WUP_PR0;                  /* 割り込み優先度設定(2bit,下位) */
    U1G_LIN_SFR_BIT_LINWUPPR1   = U1G_LIN_WUP_PR1;                  /* 割り込み優先度設定(2bit,上位) */
    U1G_LIN_SFR_BIT_LINWUPIF    = U1G_LIN_BIT_CLR;                  /* 割り込み要求フラグクリア */
    U1G_LIN_SFR_BIT_LINWUPMK    = U1G_LIN_BIT_CLR;                  /* INT割り込み許可 */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */

    l_vod_lin_EI();                                                 /* 割り込み許可 */
}


/**************************************************/
/*  INT割り込み禁止 処理                          */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_vog_lin_int_dis(void)
{
    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    l_hook_wake();

    aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );              /* SFRガード機能 無効化(GINT) */

    U1G_LIN_SFR_BIT_LINWUPMK = U1G_LIN_BIT_SET;                     /* INT割り込み禁止 */
    U1G_LIN_SFR_BIT_LINWUPIF = U1G_LIN_BIT_CLR;                     /* 割り込み要求フラグクリア（明示） */

    aipf_cpu_Enable_SFRGrd();                                       /* SFRガード機能 有効化 */
    
    l_vod_lin_EI();                                                 /* 割り込み許可 */
}


/**************************************************/
/*  LINモジュールリセット状態設定処理             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_u8  l_u1g_lin_set_reset(void)
{
    l_u8    u1a_lin_result;

    /* 割り込み禁止設定 */
    l_vod_lin_DI();

    u1a_lin_result = l_u1l_lin_linmodule_set_reset();       /* リセットモード遷移 */

    if( U1G_LIN_OK == u1a_lin_result ) {
        /* LIN割り込み/エラー検出禁止 */
        aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_CSC & AIPF_CPU_SFRGRD_ID_INT );/* SFRガード機能 無効化(GCSC、GINT) */
        
        U1G_LIN_SFR_LIE             = U1G_LIN_LIE_RESET;    /* 送信完了・受信完了・エラー検出割り込み禁止   */
        U1G_LIN_SFR_LEDE            = U1G_LIN_LEDE_RESET;   /* 全てのエラー検出禁止                         */
        /* LIN割り込み禁止 */
        U1G_LIN_SFR_BIT_LINTRMIF   = U1G_LIN_BIT_CLR;       /* LINn送信割り込み要求フラグクリア */
        U1G_LIN_SFR_BIT_LINTRMMK   = U1G_LIN_BIT_SET;       /* LINn送信割り込み禁止(マスク) */
        U1G_LIN_SFR_BIT_LINRVCIF   = U1G_LIN_BIT_CLR;       /* LINn受信割り込み要求フラグクリア */
        U1G_LIN_SFR_BIT_LINRVCMK   = U1G_LIN_BIT_SET;       /* LINn受信割り込み割り込み禁止(マスク) */
        U1G_LIN_SFR_BIT_LINSTAIF   = U1G_LIN_BIT_CLR;       /* LINnステータスエラー割り込み要求フラグクリア */
        U1G_LIN_SFR_BIT_LINSTAMK   = U1G_LIN_BIT_SET;       /* LINnステータスエラー 割り込み禁止(マスク) */

        /* クロックの供給を停止 */
        U1G_LIN_SFR_BIT_LINEN      = U1G_LIN_BIT_CLR;       /* LINnモジュールへのクロック供給 */
        U1G_LIN_SFR_BIT_LINMCKE    = U1G_LIN_BIT_CLR;       /* LINnエンジンへのクロック供給 */

        aipf_cpu_Enable_SFRGrd();                           /* SFRガード機能 有効化 */
    }

    /* 割り込み許可 */
    l_vod_lin_EI();

    return( u1a_lin_result );
}


/**************************************************/
/*  LINモジュールリセット状態遷移処理             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
static l_u8  l_u1l_lin_linmodule_set_reset(void)
{
    l_u16   u2a_lin_lp_cnt;
    l_u8    u1a_lin_result;
    l_u8    u1a_lin_tmp_lmst;

    u1a_lin_result = U1G_LIN_OK;

    u1a_lin_tmp_lmst = U1G_LIN_SFR_LMST;
    if( U1G_LIN_LMST_RESET != (u1a_lin_tmp_lmst & U1G_LIN_LMST_RESET_MASK) ) {
        /* リセットモードでなければ、リセットモードへ遷移 */
        U1G_LIN_SFR_LCUC    = U1G_LIN_LCUC_RESET;
        u2a_lin_lp_cnt      = U2G_LIN_0;

        /* リセットモード遷移待ち */
        while( (U2G_LIN_MODE_WAIT2_CNT > u2a_lin_lp_cnt)
            && ( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) ) {
            u2a_lin_lp_cnt++;
        }
        if( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) {
            /* モード遷移失敗 */
            u1a_lin_result = U1G_LIN_NG;
        }
        else{
            if( U1G_LIN_LMST_RUN == (u1a_lin_tmp_lmst & U1G_LIN_LMST_MASK) ) {
                aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_CSC );  /* SFRガード機能 無効化(GCSC) */
                
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
                /* オート・ボー・レート時は処理なし */
#else
                U1G_LIN_SFR_BIT_LINEN = U1G_LIN_BIT_CLR;        /* LINnモジュールクロック停止 */
                U1G_LIN_SFR_BIT_LINEN = U1G_LIN_BIT_SET;        /* LINnモジュールクロック供給 */
#endif /* U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON */
                
                aipf_cpu_Enable_SFRGrd();                       /* SFRガード機能 有効化 */
                u1a_lin_result = l_u1g_lin_linmodule_init();    /* LINn関連レジスタを再設定 */
                l_vog_lin_timer_init();                         /* TAUモジュールの初期化処理 */
            }
        }
    }
    return u1a_lin_result;
}


/**************************************************/
/*  LINモジュールWakeup送信時設定処理             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_u8  l_u1g_lin_set_sndwkup(void)
{
    l_u16   u2a_lin_lp_cnt;
    l_u8    u1a_lin_result;

    /* 割り込み禁止設定 */
    l_vod_lin_DI();

    if( (U1G_LIN_BIT_SET == U1G_LIN_SFR_BIT_LINEN)
        && (U1G_LIN_BIT_SET == U1G_LIN_SFR_BIT_LINMCKE) ) {
        u1a_lin_result = l_u1l_lin_linmodule_set_reset();       /* リセットモード遷移 */
    }
    else{
        /* クロックを供給、レジスタを再設定 */
        u1a_lin_result = l_u1g_lin_linmodule_init();            /* LINモジュールの初期化処理 */
        l_vog_lin_timer_init();                                 /* TAUモジュールの初期化処理 */
    }

    if( U1G_LIN_OK == u1a_lin_result ) {
        U1G_LIN_SFR_LIE  = U1G_LIN_LIE_SNDWUP;                  /* フレーム/ウェイクアップ送信完了割り込み 許可 */
        U1G_LIN_SFR_LEDE = U1G_LIN_LEDE_SNDWUP;                 /* エラー検出許可設定（リセットモード時に設定） */

        /* ウェイクアップモードへ遷移 */
        U1G_LIN_SFR_LCUC = U1G_LIN_LCUC_WUP;
        u2a_lin_lp_cnt   = U2G_LIN_0;
        
        /* ウェイクアップモード遷移待ち */
        while( (U2G_LIN_MODE_WAIT1_CNT > u2a_lin_lp_cnt)
            && ( U1G_LIN_LMST_WUP != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK) ) ) {
            u2a_lin_lp_cnt++;
        }
        if( U1G_LIN_LMST_WUP != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK) ) {
            /* モード遷移失敗 */
            u1a_lin_result = U1G_LIN_NG;
        }
        else{
            U1G_LIN_SFR_LST  = U1G_LIN_LST_CLR;                 /* LINステータス 明示クリア */
            U1G_LIN_SFR_LEST = U1G_LIN_LEST_CLR;                /* LINエラーレジスタ 明示クリア */

            /* FTS=1 が送信トリガとなるため、ここでは開始しない */

            aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );  /* SFRガード機能 無効化(GINT) */

            U1G_LIN_SFR_BIT_LINTRMPR0  = U1G_LIN_TRM_PR0;       /* 割り込み優先度設定(2bit,下位) */
            U1G_LIN_SFR_BIT_LINTRMPR1  = U1G_LIN_TRM_PR1;       /* 割り込み優先度設定(2bit,上位) */
            U1G_LIN_SFR_BIT_LINTRMIF   = U1G_LIN_BIT_CLR;       /* LINn送信割り込み要求フラグクリア */
            U1G_LIN_SFR_BIT_LINTRMMK   = U1G_LIN_BIT_CLR;       /* LINn送信割り込み許可 */
            U1G_LIN_SFR_BIT_LINRVCIF   = U1G_LIN_BIT_CLR;       /* LINn受信割り込み要求フラグクリア */
            U1G_LIN_SFR_BIT_LINRVCMK   = U1G_LIN_BIT_SET;       /* LINn受信割り込み禁止 */
            U1G_LIN_SFR_BIT_LINSTAIF   = U1G_LIN_BIT_CLR;       /* LINnステータスエラー割り込み要求フラグクリア */
            U1G_LIN_SFR_BIT_LINSTAMK   = U1G_LIN_BIT_SET;       /* LINnステータスエラー割り込み禁止(マスク) */

            aipf_cpu_Enable_SFRGrd();                           /* SFRガード機能 有効化 */
        }
    }

    /* 割り込み設定を復元 */
    l_vod_lin_EI();

    return( u1a_lin_result );
}


/**************************************************/
/*  LINモジュール通信可能状態設定処理             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_u8  l_u1g_lin_set_run(void)
{
    l_u16   u2a_lin_lp_cnt;
    l_u8    u1a_lin_result;

    u1a_lin_result = U1G_LIN_OK;

    l_vod_lin_DI();                                                 /* 割り込み禁止設定 */

    /* 動作モードでない場合のみ */
    if( U1G_LIN_LMST_RUN != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK) ) {
        if( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) {
            /* リセットモードでなければ、リセットモードへ遷移 */
            U1G_LIN_SFR_LCUC    = U1G_LIN_LCUC_RESET;
            u2a_lin_lp_cnt      = U2G_LIN_0;

            /* リセットモード遷移待ち */
            while( (U2G_LIN_MODE_WAIT2_CNT > u2a_lin_lp_cnt)
                && ( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) ) {
                u2a_lin_lp_cnt++;
            }
            if( U1G_LIN_LMST_RESET != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_RESET_MASK) ) {
                /* モード遷移失敗 */
                u1a_lin_result = U1G_LIN_NG;
            }
        }

        if( U1G_LIN_OK == u1a_lin_result ) {
            U1G_LIN_SFR_LIE  = U1G_LIN_LIE_RUN;                 /* 割り込み許可（リセットモード時に設定） */
            U1G_LIN_SFR_LEDE = U1G_LIN_LEDE_RUN;                /* エラー検出許可設定（リセットモード時に設定） */

            /* 動作モードへ遷移 */
            u2a_lin_lp_cnt = U2G_LIN_0;
            U1G_LIN_SFR_LCUC = U1G_LIN_LCUC_RUN;
            
            /* 動作モード遷移待ち */
            while((U2G_LIN_MODE_WAIT1_CNT > u2a_lin_lp_cnt)
                && ( U1G_LIN_LMST_RUN != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK) ) ) {
                u2a_lin_lp_cnt++;
            }
            if( U1G_LIN_LMST_RUN != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK ) ) {
                /* モード遷移失敗 */
                u1a_lin_result = U1G_LIN_NG;
            }
            else{
                U1G_LIN_SFR_LST             = U1G_LIN_LST_CLR;      /* LINステータス 明示クリア */
                U1G_LIN_SFR_LEST            = U1G_LIN_LEST_CLR;     /* LINエラーレジスタ 明示クリア */

                aipf_cpu_Disable_SFRGrd( AIPF_CPU_SFRGRD_ID_INT );  /* SFRガード機能 無効化(GINT) */

                U1G_LIN_SFR_BIT_LINTRMPR0  = U1G_LIN_TRM_PR0;       /* 割り込み優先度設定(2bit,下位) */
                U1G_LIN_SFR_BIT_LINTRMPR1  = U1G_LIN_TRM_PR1;       /* 割り込み優先度設定(2bit,上位) */
                U1G_LIN_SFR_BIT_LINTRMIF   = U1G_LIN_BIT_CLR;       /* LINn送信割り込み要求フラグクリア */
                U1G_LIN_SFR_BIT_LINTRMMK   = U1G_LIN_BIT_CLR;       /* LINn送信割り込み許可 */
                U1G_LIN_SFR_BIT_LINRVCPR0  = U1G_LIN_RVC_PR0;       /* 割り込み優先度設定(2bit,下位) */
                U1G_LIN_SFR_BIT_LINRVCPR1  = U1G_LIN_RVC_PR1;       /* 割り込み優先度設定(2bit,上位) */
                U1G_LIN_SFR_BIT_LINRVCIF   = U1G_LIN_BIT_CLR;       /* LINn受信割り込み要求フラグクリア */
                U1G_LIN_SFR_BIT_LINRVCMK   = U1G_LIN_BIT_CLR;       /* LINn受信割り込み許可 */
                U1G_LIN_SFR_BIT_LINSTAPR0  = U1G_LIN_ERR_PR0;       /* 割り込み優先度設定(2bit,下位) */
                U1G_LIN_SFR_BIT_LINSTAPR1  = U1G_LIN_ERR_PR1;       /* 割り込み優先度設定(2bit,上位) */
                U1G_LIN_SFR_BIT_LINSTAIF   = U1G_LIN_BIT_CLR;       /* LINnステータスエラー割り込み要求フラグクリア */
                U1G_LIN_SFR_BIT_LINSTAMK   = U1G_LIN_BIT_CLR;       /* LINnステータスエラー割り込み許可 */

                aipf_cpu_Enable_SFRGrd();                           /* SFRガード機能 有効化 */

                U1G_LIN_SFR_LTRC   |= U1G_LIN_LTRC_FTS;             /* LIN通信開始 */
            }
        }
    }

    l_vod_lin_EI();                                                 /* 割り込み許可 */

    return( u1a_lin_result );
}


/**************************************************/
/*  LIN送信完了割り込み 処理（API）               */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void   l_ifc_tx(void)
{
    /* 送信完了 */
    U1G_LIN_SFR_LST = U1G_LIN_LST_CLR_TX;                   /* 送信完了情報クリア */
    l_vog_lin_tx_int();                                     /* 送信完了割り込み報告 */
}


/**************************************************/
/*  LIN受信完了割り込み 処理（API）               */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void   l_ifc_rx(void)
{
    l_u8    u1a_lin_lst_data;
    l_u8    u1a_lin_id;

    u1a_lin_lst_data    = U1G_LIN_SFR_LST;                  /* LINステータス取得 */
    U1G_LIN_SFR_LST     = U1G_LIN_LST_CLR_RX;               /* 受信完了情報クリア */
    u1a_lin_id          = (l_u8)(U1G_LIN_SFR_LIDB & U1G_LIN_LIDB_ID_MASK); /* IDを取得 */
    l_vog_lin_rx_int( u1a_lin_lst_data, u1a_lin_id );       /* 受信割り込み報告 */
}


/**************************************************/
/*  LINステータスエラー割り込み 処理（API）       */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void   l_ifc_err(void)
{
    l_u8    u1a_lin_lst_data;
    l_u8    u1a_lin_err;

    u1a_lin_lst_data    = U1G_LIN_SFR_LST;                  /* LINステータス取得 */
    u1a_lin_err         = U1G_LIN_SFR_LEST;                 /* LINエラー情報取得*/
    U1G_LIN_SFR_LEST    = U1G_LIN_LEST_CLR;                 /* 全エラーフラグクリア */

    l_vog_lin_err_int( u1a_lin_err, u1a_lin_lst_data );     /* エラー割り込み報告 */
}


/**************************************************/
/*  INT割り込み制御処理(API)                      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_aux(void)
{
    l_vog_lin_aux_int();                                    /* INT割り込み報告 */
}


/**************************************************/
/*  タイマ満了時実行処理 (API)                    */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_ifc_tau_timeout(void)
{
    l_vog_lin_stop_timer();                                 /* タイマのカウンタを停止する */

    /* Framing エラー確定 */
    l_vog_lin_determine_FramingError();
}


/**********************************************************/
/*  レスポンス送信開始処理                                */
/*--------------------------------------------------------*/
/*  引数： u1a_lin_dl       : 送信するデータ長            */
/*         u1a_sum_type     : 0:classic 1:enhanced        */
/*         pta_lin_snd_data : 送信データ格納元ポインタ    */
/*  戻値： 処理結果                                       */
/*         (0 / 1) : 処理成功 / 処理失敗                  */
/**********************************************************/
l_u8  l_u1g_lin_resp_snd_start(l_u8 u1a_lin_dl, l_u8 u1a_sum_type, const l_u8 pta_lin_snd_data[])
{
    l_u8    u1a_lin_result;

    u1a_lin_result = U1G_LIN_NG;

    if( (U1G_LIN_DL_8 < u1a_lin_dl) || (U1G_LIN_NULL == pta_lin_snd_data) || (U1G_LIN_SUM_TYPE_MAX < u1a_sum_type) ) {
        /* 引数異常 */
    }
    else{
        /* LINモジュールモード確認 */
        if( U1G_LIN_LMST_RUN != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK) ) {
            /* 動作モードでなければ異常 */
        }
        else{
            /* LINフレーム/ウェイクアップ送信開始ビット確認 */
            if( U1G_LIN_BYTE_CLR == (U1G_LIN_SFR_LTRC & U1G_LIN_LTRC_FTS) ) {
                /* 送信開始ビット異常 */
            }
            else{
                /* LINレスポンスフィールド設定レジスタ設定  送信 */
                U1G_LIN_SFR_LDFC    = (l_u8)(u1a_lin_dl | U1G_LIN_LDFC_RCDS | (u1a_sum_type << U1G_LIN_BIT_SFT_5));  /* 送信、フレームサイズセット */

                /* 送信データ設定 */
                U1G_LIN_SFR_LDB1 = pta_lin_snd_data[ U1G_LIN_0 ];
                U1G_LIN_SFR_LDB2 = pta_lin_snd_data[ U1G_LIN_1 ];
                U1G_LIN_SFR_LDB3 = pta_lin_snd_data[ U1G_LIN_2 ];
                U1G_LIN_SFR_LDB4 = pta_lin_snd_data[ U1G_LIN_3 ];
                U1G_LIN_SFR_LDB5 = pta_lin_snd_data[ U1G_LIN_4 ];
                U1G_LIN_SFR_LDB6 = pta_lin_snd_data[ U1G_LIN_5 ];
                U1G_LIN_SFR_LDB7 = pta_lin_snd_data[ U1G_LIN_6 ];
                U1G_LIN_SFR_LDB8 = pta_lin_snd_data[ U1G_LIN_7 ];

                U1G_LIN_SFR_LTRC = U1G_LIN_LTRC_RTS;        /* レスポンス送信/受信開始（送信） */

                u1a_lin_result = U1G_LIN_OK;
            }
        }
    }

    return( u1a_lin_result );
}


/**********************************************************/
/*  レスポンス受信開始処理                                */
/*--------------------------------------------------------*/
/*  引数： u1a_lin_dl       : 受信するデータ長            */
/*         u1a_sum_type     : 0:classic 1:enhanced        */
/*  戻値： 処理結果                                       */
/*         (0 / 1) : 処理成功 / 処理失敗                  */
/**********************************************************/
l_u8  l_u1g_lin_resp_rcv_start(l_u8 u1a_lin_dl, l_u8 u1a_sum_type)
{
    l_u8    u1a_lin_result;

    u1a_lin_result = U1G_LIN_NG;

    if( (U1G_LIN_DL_8 < u1a_lin_dl) || (U1G_LIN_SUM_TYPE_MAX < u1a_sum_type) ) {
        /* 引数異常 */
    }
    else{
        /* LINモジュールモード確認 */
        if( U1G_LIN_LMST_RUN != (U1G_LIN_SFR_LMST &  U1G_LIN_LMST_MASK) ) {
            /* 動作モードでなければ異常 */
        }
        else{
            /* LINフレーム/ウェイクアップ送信開始ビット確認 */
            if( U1G_LIN_BYTE_CLR == (U1G_LIN_SFR_LTRC & U1G_LIN_LTRC_FTS) ) {
                /* 送信開始ビット異常 */
            }
            else{
                /* LINレスポンスフィールド設定レジスタ設定  受信 */
                U1G_LIN_SFR_LDFC    = (l_u8)(u1a_lin_dl | (u1a_sum_type << U1G_LIN_BIT_SFT_5));  /* 受信、フレームサイズセット */
                U1G_LIN_SFR_LTRC    = U1G_LIN_LTRC_RTS;     /* レスポンス送信/受信開始（受信） */
                u1a_lin_result      = U1G_LIN_OK;
            }
        }
    }

    return( u1a_lin_result );
}


/**********************************************************/
/*  レスポンス要求なし設定 処理                           */
/*--------------------------------------------------------*/
/*  引数： なし                                           */
/*  戻値： 処理結果                                       */
/*         (0 / 1) : 処理成功 / 処理失敗                  */
/**********************************************************/
l_u8  l_u1g_lin_resp_noreq(void)
{
    l_u8    u1a_lin_result;

    u1a_lin_result = U1G_LIN_NG;

    /* LINモジュールモード確認 */
    if( U1G_LIN_LMST_RUN != (U1G_LIN_SFR_LMST &  U1G_LIN_LMST_MASK) ) {
        /* 動作モードでなければ異常 */
    }
    else{
        /* LINフレーム/ウェイクアップ送信開始ビット確認 */
        if( U1G_LIN_BYTE_CLR == (U1G_LIN_SFR_LTRC & U1G_LIN_LTRC_FTS) ) {
            /* 送信開始ビット異常 */
        }
        else{
            /* フレーム通信開始 */
            U1G_LIN_SFR_LTRC = U1G_LIN_LTRC_LNRR;       /* レスポンスなし要求 */

            u1a_lin_result = U1G_LIN_OK;
        }
    }

    return( u1a_lin_result );
}



/**********************************************************/
/*  受信データ取得処理                                    */
/*--------------------------------------------------------*/
/*  引数： pta_lin_rcv_data : 受信データ格納先ポインタ    */
/*  戻値： なし                                           */
/**********************************************************/
void  l_vog_lin_get_rcvdata(l_u8 pta_lin_rcv_data[])
{
    if( U1G_LIN_NULL == pta_lin_rcv_data ) {
        /* 引数異常  ※戻り値での通知は行いません */
    }
    else{
        /* 受信データ格納 */
        pta_lin_rcv_data[ U1G_LIN_0 ] = U1G_LIN_SFR_LDB1;
        pta_lin_rcv_data[ U1G_LIN_1 ] = U1G_LIN_SFR_LDB2;
        pta_lin_rcv_data[ U1G_LIN_2 ] = U1G_LIN_SFR_LDB3;
        pta_lin_rcv_data[ U1G_LIN_3 ] = U1G_LIN_SFR_LDB4;
        pta_lin_rcv_data[ U1G_LIN_4 ] = U1G_LIN_SFR_LDB5;
        pta_lin_rcv_data[ U1G_LIN_5 ] = U1G_LIN_SFR_LDB6;
        pta_lin_rcv_data[ U1G_LIN_6 ] = U1G_LIN_SFR_LDB7;
        pta_lin_rcv_data[ U1G_LIN_7 ] = U1G_LIN_SFR_LDB8;
    }
}


/**************************************************/
/*  Wakeupパルス送信処理                          */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 処理結果                               */
/*         (0 / 1) : 処理成功 / 処理失敗          */
/**************************************************/
l_u8  l_u1g_lin_snd_wakeup(void)
{
    l_u8    u1a_lin_result;

    u1a_lin_result = U1G_LIN_NG;

    /* LINモジュールモード確認 */
    if( U1G_LIN_LMST_WUP != (U1G_LIN_SFR_LMST & U1G_LIN_LMST_MASK) ) {
            /* ウェイクアップモードでなければ異常 */
    }
    else{
        /* LINフレーム/ウェイクアップ送信開始ビット確認 */
        if( U1G_LIN_BYTE_CLR != (U1G_LIN_SFR_LTRC & U1G_LIN_LTRC_FTS) ) {
            /* 送信開始ビット異常 */
        }
        else{
            U1G_LIN_SFR_LDFC    |= U1G_LIN_LDFC_RCDS;   /* 通信方向設定(送信) */
            U1G_LIN_SFR_LTRC    |= U1G_LIN_LTRC_FTS;    /* ウェイクアップ送信開始 */

            u1a_lin_result = U1G_LIN_OK;
        }
    }

    return( u1a_lin_result );
}


/**************************************************/
/*  ボーレート妥当性確認処理                      */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： 妥当性                                 */
/*         (0 / 1) : 妥当 / 不当                  */
/**************************************************/
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
l_u8 l_u1g_lin_is_valid_baud_rate(void)
{
    l_u16 u2a_lin_lbrp;
    l_u8 u1a_lin_result;

    u2a_lin_lbrp = U2G_LIN_SFR_LBRP;
    u1a_lin_result = U1G_LIN_OK;

    if( ( U2G_LIN_MINIMUM_LBRP > u2a_lin_lbrp ) ||
        ( U2G_LIN_MAXIMUM_LBRP < u2a_lin_lbrp ) ) {
        u1a_lin_result = U1G_LIN_NG;
    }

    return u1a_lin_result;
}
#endif /* U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON */


/*************************************************************************/
/*  Response too short / No response 確定処理                            */
/*-----------------------------------------------------------------------*/
/*  引数： u1a_lst_d1rc_state : 0:データ1受信未完了 1:データ1受信完了    */
/*  戻値： なし                                                          */
/*************************************************************************/
void l_vog_lin_determine_ResTooShort_or_NoRes(l_u8 u1a_lst_d1rc_state)
{
    if( U1G_LIN_BYTE_CLR != (U1G_LIN_TAU_TE & U1G_LIN_TE_ENABLE) ) {
        /* 汎用タイマ動作許可状態 */
        l_vog_lin_stop_timer();                             /* タイマのカウンタ停止 */
        
        if( u1a_lst_d1rc_state == U1G_LIN_LST_D1RC_COMPLETE ) {
            /* データ1受信フラグが 1 の場合、Response Too Shortを確定 */
            l_vog_lin_ResTooShort_error();                  /* Response too short エラー確定処理 */
        }
        else if( u1a_lst_d1rc_state == U1G_LIN_LST_D1RC_INCOMPLETE ) {
            /* データ1受信フラグが 0 の場合、No Response を確定 */
            l_vog_lin_NoRes_error();                        /* No response エラー確定処理 */
        }
        else{
            /* 引数異常 */
        }
        
        U1G_LIN_SFR_LST &= (~U1G_LIN_LST_D1RC_MASK);        /* LSTレジスタデータ1受信完了値 明示クリア */
    }
    else{
        /* 汎用タイマ動作禁止の場合、処理なし */
    }

}

/***** End of File *****/


/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_drv_rl78f24.h                        */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_DRV_RL78F24_H_INCLUDE
#define L_SLIN_DRV_RL78F24_H_INCLUDE

/*** MCU依存部分の定数定義 ***/

/*** LINモジュールモード遷移待ちカウント数 ************************************************/
/* 理論最大所要は [3*fclk + 4*LIN通信クロック源]、前提として [LIN通信クロック源 ≦ fCLK]  */
/*  → より長い [7 * LIN通信クロック源] cycleウェイトが保証できれば良い                   */
/* LIN通信クロック源、メインクロックを4MHz以上（4～40）の前提とする。                     */
/* 最大所要cycleは LIN通信クロック源が最小、メインクロックが最大パターンなので、          */
/*   (((40/4 * メイン・システム・クロック) * 7) ⇒ 70cycle                                */
/* ウェイクアップモード、動作モード遷移待ちループが一周で10cycleのため、7回ループとする   */
/* リセットモード遷移待ちループが一周で9cycleのため、8回ループとする                      */

#define U2G_LIN_MODE_WAIT1_CNT          ((l_u16)7U)     /* ウェイクアップモード、動作モード遷移待ちループカウント */
#define U2G_LIN_MODE_WAIT2_CNT          ((l_u16)8U)     /* リセットモード遷移待ちループカウント */

/* LCHSELレジスタ */
#if U1G_LIN_CH == U1G_LIN_LINCH_0
#define  U1G_LIN_LCHSEL                 ((l_u8)0x00U)   /* LINチャネル0を選択 */
#elif U1G_LIN_CH == U1G_LIN_LINCH_1
#define  U1G_LIN_LCHSEL                 ((l_u8)0x01U)   /* LINチャネル1を選択 */
#endif

/* LINCKSELレジスタ LINnMCKビット */
#if U1G_LIN_CLK_SRC == U1G_LIN_CLKSRC_FCLK
#define  U1G_LIN_LINMCK_SET            ((l_u8)(0x00U)) /* LINクロック選択レジスタ LINnMCKビット設定値 */
#elif U1G_LIN_CLK_SRC == U1G_LIN_CLKSRC_FMX
#define  U1G_LIN_LINMCK_SET            ((l_u8)(0x01U)) /* LINクロック選択レジスタ LINnMCKビット設定値 */
#endif

/* LWBRレジスタ */
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
#if U1G_LIN_CLK <= 12U
#define  U1G_LIN_LWBR_INIT              ((l_u8)0x70U)   /* LINウェイクアップボーレート選択レジスタ初期値（設定値） */
#define  U4G_LIN_PRESCALER              ((l_u32)8UL)
#elif U1G_LIN_CLK <= 24U
#define  U1G_LIN_LWBR_INIT              ((l_u8)0x72U)   /* LINウェイクアップボーレート選択レジスタ初期値（設定値） */
#define  U4G_LIN_PRESCALER              ((l_u32)16UL)
#else
#define  U1G_LIN_LWBR_INIT              ((l_u8)0x74U)   /* LINウェイクアップボーレート選択レジスタ初期値（設定値） */
#define  U4G_LIN_PRESCALER              ((l_u32)32UL)
#endif
#else
#define  U1G_LIN_LWBR_INIT              ((l_u8)0x00U)   /* LINウェイクアップボーレート選択レジスタ初期値（設定値） */
#define  U4G_LIN_PRESCALER              ((l_u32)16UL)
#endif

/* LBRPレジスタ */
#if U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_9600
#define  U2G_LIN_LBRP_INIT              ((l_u16)((((( (l_u32)1000000UL * (l_u32)U1G_LIN_CLK ) / U4G_LIN_PRESCALER) + ( (l_u32)9600UL / (l_u32)2UL ) ) / (l_u32)9600UL ) - (l_u32)1UL )) /* LINボーレートプリスケーラ初期値（設定値） */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_10400
#define  U2G_LIN_LBRP_INIT              ((l_u16)((((( (l_u32)1000000UL * (l_u32)U1G_LIN_CLK ) / U4G_LIN_PRESCALER) + ( (l_u32)10400UL / (l_u32)2UL ) ) / (l_u32)10400UL ) - (l_u32)1UL )) /* LINボーレートプリスケーラ初期値（設定値） */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_10417
#define  U2G_LIN_LBRP_INIT              ((l_u16)((((( (l_u32)1000000UL * (l_u32)U1G_LIN_CLK ) / U4G_LIN_PRESCALER) + ( (l_u32)10417UL / (l_u32)2UL ) ) / (l_u32)10417UL ) - (l_u32)1UL )) /* LINボーレートプリスケーラ初期値（設定値） */
#elif U1G_LIN_BAUDRATE == U1G_LIN_BAUDRATE_19200
#define  U2G_LIN_LBRP_INIT              ((l_u16)((((( (l_u32)1000000UL * (l_u32)U1G_LIN_CLK ) / U4G_LIN_PRESCALER) + ( (l_u32)19200UL / (l_u32)2UL ) ) / (l_u32)19200UL ) - (l_u32)1UL )) /* LINボーレートプリスケーラ初期値（設定値） */
#endif

/* LMDレジスタ */
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
#define  U1G_LIN_LMD_INIT               ((l_u8)0x12U)   /* LINモードレジスタ初期値（設定値） */
#else
#define  U1G_LIN_LMD_INIT               ((l_u8)0x13U)   /* LINモードレジスタ初期値（設定値） */
#endif

/* LBFCレジスタ */
#if U1G_LIN_BREAK_LENGTH == U1G_LIN_BREAK_LENGTH_11BITS
#define  U1G_LIN_LBFC_INIT              ((l_u8)0x01U)   /* LINブレークフィールド設定レジスタ初期値（設定値） */
#else
#define  U1G_LIN_LBFC_INIT              ((l_u8)0x00U)   /* LINブレークフィールド設定レジスタ初期値（設定値） */
#endif

/* LCUCレジスタ */
#define  U1G_LIN_LCUC_RESET             ((l_u8)0x00U)  /* LINモジュールリセット        */
#define  U1G_LIN_LCUC_WUP               ((l_u8)0x01U)  /* LINモジュールウェイクアップ  */
#define  U1G_LIN_LCUC_RUN               ((l_u8)0x03U)  /* LINモジュール動作            */

/* LMSTレジスタ */
#define  U1G_LIN_LMST_RESET             ((l_u8)0x00U)  /* LINモジュールリセット        */
#define  U1G_LIN_LMST_WUP               ((l_u8)0x01U)  /* LINモジュールウェイクアップ  */
#define  U1G_LIN_LMST_RUN               ((l_u8)0x03U)  /* LINモジュール動作            */
#define  U1G_LIN_LMST_MASK              ((l_u8)0x03U)  /* LINモードステータス確認用マスク値 */
#define  U1G_LIN_LMST_RESET_MASK        ((l_u8)0x01U)  /* LINモードステータス確認用マスク値(RESET) */

/* LSCレジスタ */
#define  U1G_LIN_LSC_RS                 ((l_u8)(U1G_LIN_RSSP & (l_u8)0x07U))                           /* レスポンススペース設定値 RS b2-b0*/
#define  U1G_LIN_LSC_IBS                ((l_u8)((U1G_LIN_BTSP & (l_u8)0x03U) << U1G_LIN_BIT_SFT_4))    /* インタバイトスペース設定値 IBS b5-b4 */
#define  U1G_LIN_LSC_INIT               ((l_u8)(U1G_LIN_LSC_RS | U1G_LIN_LSC_IBS))              /* スペース設定（RS、BS） */

/* LWUPレジスタ */
#define  U1G_LIN_SFR_LWUP_INIT          ((l_u8)((U1G_LIN_WUP - (l_u8)1U) << U1G_LIN_BIT_SFT_4))    /* Wakeup送信幅  WUTL b7-b4 */

/* LIEレジスタ */
#define  U1G_LIN_LIE_INIT               ((l_u8)0x00U)  /* LIEレジスタ初期値   */
#define  U1G_LIN_LIE_RESET              ((l_u8)0x00U)  /* LIEレジスタRESET時設定値   */
#define  U1G_LIN_LIE_SNDWUP             ((l_u8)0x01U)  /* LIEレジスタウェイクアップ送信時設定値   */
#define  U1G_LIN_LIE_RUN                ((l_u8)0x0FU)  /* LIEレジスタレスポンス送受信時設定値     */

/* LEDEレジスタ */
#define  U1G_LIN_LEDE_INIT              ((l_u8)0x00U)  /* LEDEレジスタ初期値   */
#define  U1G_LIN_LEDE_RESET             ((l_u8)0x00U)  /* LEDEレジスタRESET時設定値   */
#define  U1G_LIN_LEDE_SNDWUP            ((l_u8)0x00U)  /* LEDEレジスタウェイクアップ送信時設定値   */
#define  U1G_LIN_LEDE_RUN               ((l_u8)0x59U)   /* LEDEレジスタレスポンス送受信時設定値     */

/* LSTレジスタ */
#define  U1G_LIN_LST_CLR                ((l_u8)0x00U)  /* LSTレジスタクリア値   */
#define  U1G_LIN_LST_CLR_TX             ((l_u8)0xCAU)  /* LSTレジスタバッファ送信完了フラグ(FTC)クリア   */
#define  U1G_LIN_LST_CLR_RX             ((l_u8)0x09U)  /* LST b1,6,7 クリア（受信関連）   */
#define  U1G_LIN_LST_D1RC_MASK          ((l_u8)0x40U)  /* LSTレジスタデータ1受信完了マスク値 */

/* LESTレジスタ */
#define  U1G_LIN_LEST_CLR               ((l_u8)0x00U)  /* LESTレジスタクリア値   */

/* LDFCレジスタ */
#define  U1G_LIN_LDFC_RCDS              ((l_u8)0x10U)  /* レスポンスフィールド通信方向選択ビット 0:受信 1:送信 */

/* LTRCレジスタ */
#define  U1G_LIN_LTRC_RTS               ((l_u8)0x02U)  /* LTRCレジスタレスポンス送信/受信開始値(MOV書き込み限定) */
#define  U1G_LIN_LTRC_LNRR              ((l_u8)0x04U)  /* LTRCレジスタレスポンスなし要求値(MOV書き込み限定)      */
#define  U1G_LIN_LTRC_FTS               ((l_u8)0x01U)  /* LTRCレジスタフレーム送信／ウェイクアップ送受信開始 */

/* LIDBレジスタ */
#define  U1G_LIN_LIDB_ID_MASK           ((l_u8)0x3FU)  /* LIN IDバッファレジスタ IDマスク */

/* TPS レジスタ */
#if   (U1G_LIN_TIMER_CKMK_M0 == U1G_LIN_TIMER_CKMK)
#define  U2G_LIN_TPS_CLR                ((l_u16)((l_u16)0x0FU << 0x00U))                   /* プリスケーラ設定クリア値 */
#define  U2G_LIN_TPS_INIT               ((l_u16)((l_u16)U1G_LIN_FMCK_PRESCALER << 0x00U))  /* タイマ・クロック選択レジスタ プリスケーラ設定(CKm0) (fCLK/(2^U1G_LIN_FMCK_PRESCALER)) */
#elif (U1G_LIN_TIMER_CKMK_M1 == U1G_LIN_TIMER_CKMK)
#define  U2G_LIN_TPS_CLR                ((l_u16)((l_u16)0x0FU << 0x04U))                   /* プリスケーラ設定クリア値 */
#define  U2G_LIN_TPS_INIT               ((l_u16)((l_u16)U1G_LIN_FMCK_PRESCALER << 0x04U))  /* タイマ・クロック選択レジスタ プリスケーラ設定(CKm1) (fCLK/(2^U1G_LIN_FMCK_PRESCALER)) */
#elif (U1G_LIN_TIMER_CKMK_M2 == U1G_LIN_TIMER_CKMK)
#define  U2G_LIN_TPS_CLR                ((l_u16)((l_u16)0x0FU << 0x08U))                   /* プリスケーラ設定クリア値 */
#define  U2G_LIN_TPS_INIT               ((l_u16)((l_u16)U1G_LIN_FMCK_PRESCALER << 0x08U))  /* タイマ・クロック選択レジスタ プリスケーラ設定(CKm2) (fCLK/(2^U1G_LIN_FMCK_PRESCALER)) */
#elif (U1G_LIN_TIMER_CKMK_M3 == U1G_LIN_TIMER_CKMK)
#define  U2G_LIN_TPS_CLR                ((l_u16)((l_u16)0x0FU << 0x0CU))                   /* プリスケーラ設定クリア値 */
#define  U2G_LIN_TPS_INIT               ((l_u16)((l_u16)U1G_LIN_FMCK_PRESCALER << 0x0CU))  /* タイマ・クロック選択レジスタ プリスケーラ設定(CKm3) (fCLK/(2^U1G_LIN_FMCK_PRESCALER)) */
#endif

/* TMR レジスタ */
#if   ( (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_2) || (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_4) || (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_6) )
#define  U2G_LIN_TMR_INIT               ((l_u16)((l_u16)U1G_LIN_TIMER_CKMK << 0x0EU))          /* タイマ・モードレジスタ 初期値 */
#elif ( (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_1) || (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_3) )
#define  U2G_LIN_TMR_INIT               ((l_u16)((l_u16)U1G_LIN_TIMER_CKMK << 0x0EU))          /* タイマ・モードレジスタ 初期値 */
#elif ( (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_0) || (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_5) || (U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_7) )
#define  U2G_LIN_TMR_INIT               ((l_u16)((l_u16)U1G_LIN_TIMER_CKMK << 0x0EU))          /* タイマ・モードレジスタ 初期値 */
#endif

/* TO レジスタ */
#define  U1G_LIN_TO_INIT                ((l_u8)((l_u8)0x01U << U1G_LIN_TIMER_CH))  /* タイマ出力レジスタ 初期値(タイマ出力値を0とする), この値と&=演算子を用いて定義体に代入すること */

/* TE レジスタ */
#define  U1G_LIN_TE_ENABLE              ((l_u8)((l_u8)0x01U << U1G_LIN_TIMER_CH))  /* タイマ・チャネル許可ステータスレジスタ 動作許可状態 */

/* TOE レジスタ */
#define  U1G_LIN_TOE_INIT               ((l_u8)((l_u8)0x01U << U1G_LIN_TIMER_CH))  /* タイマ出力許可レジスタ 初期値(0: タイマ出力を禁止), この値と&=演算子を用いて定義体に代入すること */

/* TS レジスタ */
#define  U1G_LIN_TS_START               ((l_u8)((l_u8)0x01U << U1G_LIN_TIMER_CH))  /* タイマ・チャネル開始レジスタ 開始トリガ */

/* TT レジスタ */
#define  U1G_LIN_TT_STOP                ((l_u8)((l_u8)0x01U << U1G_LIN_TIMER_CH))  /* タイマ・チャネル停止レジスタ 停止トリガ */

/* xxPR0/xxPR1レジスタ（割り込みレベル設定） */
#define  U1G_LIN_WUP_PR0                ((l_u8)( U1G_LIN_WUP_INTLEVEL & U1G_LIN_BIT0))                  /* LIN受信端子入力割り込みレベル 下位 */
#define  U1G_LIN_WUP_PR1                ((l_u8)((U1G_LIN_WUP_INTLEVEL & U1G_LIN_BIT1) >> U1G_LIN_1))    /* LIN受信端子入力割り込みレベル 上位 */
#define  U1G_LIN_TRM_PR0                ((l_u8)( U1G_LIN_TRM_INTLEVEL & U1G_LIN_BIT0))                  /* LIN送信完了割り込みレベル 下位 */
#define  U1G_LIN_TRM_PR1                ((l_u8)((U1G_LIN_TRM_INTLEVEL & U1G_LIN_BIT1) >> U1G_LIN_1))    /* LIN送信完了割り込みレベル 上位 */
#define  U1G_LIN_RVC_PR0                ((l_u8)( U1G_LIN_RVC_INTLEVEL & U1G_LIN_BIT0))                  /* LIN受信完了割り込みレベル 下位 */
#define  U1G_LIN_RVC_PR1                ((l_u8)((U1G_LIN_RVC_INTLEVEL & U1G_LIN_BIT1) >> U1G_LIN_1))    /* LIN受信完了割り込みレベル 上位 */
#define  U1G_LIN_ERR_PR0                ((l_u8)( U1G_LIN_STA_INTLEVEL & U1G_LIN_BIT0))                  /* LINステータスエラー割り込みレベル 下位 */
#define  U1G_LIN_ERR_PR1                ((l_u8)((U1G_LIN_STA_INTLEVEL & U1G_LIN_BIT1) >> U1G_LIN_1))    /* LINステータスエラー割り込みレベル 上位 */
#define  U1G_LIN_TMPR_PR0               ((l_u8)( U1G_LIN_TIMER_INTLEVEL & U1G_LIN_BIT0))                /* TAU優先順位指定フラグレベル 下位 */
#define  U1G_LIN_TMPR_PR1               ((l_u8)((U1G_LIN_TIMER_INTLEVEL & U1G_LIN_BIT1) >> U1G_LIN_1))  /* TAU優先順位指定フラグレベル 上位 */


#define  U1G_LIN_BIT_SFT_4              ((l_u8)4U)
#define  U1G_LIN_BIT_SFT_5              ((l_u8)5U)

#define  U1G_LIN_PRSC_BASE              ((l_u8)0x01U)       /* プリスケーラ設定用底, 使用例: U1G_LIN_PRSC_BASE << U1G_LIN_FMCK_PRESCALER */
#define  U1G_LIN_FMCK_PRESCALER         ((l_u8)2U)          /* プリスケーラ設定, fCLK/2^n の n を決定する */
#define  U2G_LIN_COND_ERROR_TIME        ((l_u16)2343U)      /* Framingエラー確定に必要なタイマカウント値[us] */
#define  U4G_LIN_FCLK_FREQ              ((l_u32)((l_u32)U1G_LIN_TIMER_CLK / ((l_u32)U1G_LIN_PRSC_BASE << (l_u32)U1G_LIN_FMCK_PRESCALER)))
                                                            /* カウンタ・クロックの周波数 [MHz] */
#define  U2G_LIN_TDR_COUNT_VAL          ((l_u16)(((l_u32)U2G_LIN_COND_ERROR_TIME * U4G_LIN_FCLK_FREQ)))  /* カウンタ値の算出 */


/*** マクロ定義 ***/
#define U1G_LIN_REG_PSW_IE_MASK        ( (l_u8)0x80U)   /* IEフラグマスク値 */

/*** マクロ関数 ***/
#pragma inline_asm __inline_asm_func_DI
static void __inline_asm_func_DI(void)
{
    DI
}

#pragma inline_asm __inline_asm_func_EI
static void __inline_asm_func_EI(void)
{
    EI
}

#define l_vod_lin_DI()                                                              \
do                                                                                  \
{                                                                                   \
    l_u8 aipf_psw;                              /* PSW値 */                         \
    aipf_psw = __get_psw();                     /* PSW(アドレス：0xFFFFA) 退避 */   \
    __inline_asm_func_DI()                      /* 即時割り込み禁止 */

#define l_vod_lin_EI()                                                              \
    if( U1G_LIN_REG_PSW_IE_MASK == ( U1G_LIN_REG_PSW_IE_MASK & aipf_psw ) )        \
    {                                                                               \
        __inline_asm_func_EI();                 /* 即時割り込み許可 */              \
    }                                                                               \
    else{}                                                                          \
}                                                                                   \
while( 0 )


/*** 関数のプロトタイプ宣言(global) ***/
l_u8   l_u1g_lin_linmodule_init(void);
void   l_vog_lin_timer_init(void);
void   l_vog_lin_start_timer(void);
void   l_vog_lin_stop_timer(void);
void   l_vog_lin_int_init(void);
void   l_vog_lin_int_enb(void);
void   l_vog_lin_int_dis(void);
l_u8   l_u1g_lin_set_reset(void);
l_u8   l_u1g_lin_set_sndwkup(void);
l_u8   l_u1g_lin_set_run(void);
l_u8   l_u1g_lin_resp_snd_start(l_u8 u1a_lin_dl, l_u8 u1a_sum_type, const l_u8 pta_lin_snd_data[]);
l_u8   l_u1g_lin_resp_rcv_start(l_u8 u1a_lin_dl, l_u8 u1a_sum_type);
l_u8   l_u1g_lin_resp_noreq(void);
l_u8   l_u1g_lin_snd_wakeup(void);
void   l_vog_lin_get_rcvdata(l_u8 pta_lin_rcv_data[]);
#if U1G_LIN_BAUD_RATE_DETECT == U1G_LIN_BAUD_RATE_DETECT_ON
l_u8   l_u1g_lin_is_valid_baud_rate(void);
#endif
void l_vog_lin_determine_ResTooShort_or_NoRes(l_u8 u1a_lst_d1rc_state);

#endif

/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_hook.c                               */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/
/* LINライブラリ ROMセクション定義 */
#pragma section  text   @@LNCD
#pragma section  text  @@LNCDL
#pragma section  const   @@LNCNS
#pragma section  const  @@LNCNSL
/* LINライブラリ RAMセクション定義 */
#pragma section  bss   @@LNDT
#pragma section  bss  @@LNDTL

/***** ヘッダ インクルード *****/
#include "l_slin_user.h"
/* ここに必要なアプリヘッダファイルをインクルードしてください */


/*===========================================================================================*/

/********************************/
/* HOOK関数                     */
/********************************/
/**************************************************/
/*  SLEEP遷移HOOK関数                             */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_hook_sleep(void)
{
    /* ここに必要なアプリ処理を追加してください */
    /* 割り込み内からも実行される処理であるため極力処理時間を短くしてください */
    /* Hook処理のタイミングでIAWCTLレジスタのガードはそのままです。適宜設定してください */
}


/**************************************************/
/*  WAKEUP時HOOK関数                              */
/*------------------------------------------------*/
/*  引数： なし                                   */
/*  戻値： なし                                   */
/**************************************************/
void  l_hook_wake(void)
{
    /* ここに必要なアプリ処理を追加してください */
    /* 割り込み内からも実行される処理であるため極力処理時間を短くしてください */
    /* Hook処理のタイミングでIAWCTLレジスタのガードはそのままです。適宜設定してください */
}


/**************************************************/
/*  レスポンス正常送信完了時HOOK関数              */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : フレームの名前          */
/*  戻値： なし                                   */
/**************************************************/
void  l_hook_snd_comp(l_frame_handle  u1a_lin_frm)
{
    /* ここに必要なアプリ処理を追加してください */
    /* 割り込み内の処理であるため極力処理時間を短くしてください */
    /* Hook処理のタイミングでIAWCTLレジスタのガードはそのままです。適宜設定してください */
}


/**************************************************/
/*  レスポンス正常受信完了時HOOK関数              */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : フレームの名前          */
/*  戻値： なし                                   */
/**************************************************/
void  l_hook_rcv_comp(l_frame_handle  u1a_lin_frm)
{
    /* ここに必要なアプリ処理を追加してください */
    /* 割り込み内の処理であるため極力処理時間を短くしてください */
    /* Hook処理のタイミングでIAWCTLレジスタのガードはそのままです。適宜設定してください */
}


/**************************************************/
/*  エラー発生時HOOK関数                          */
/*------------------------------------------------*/
/*  引数： u1a_lin_frm  : フレームの名前          */
/*         u2a_lin_err  : エラー情報              */
/*  戻値： なし                                   */
/**************************************************/
void  l_hook_err(l_frame_handle  u1a_lin_frm, l_u16 u2a_lin_err)
{
    /* ここに必要なアプリ処理を追加してください */
    /* 割り込み内の処理であるため極力処理時間を短くしてください */
    /* Hook処理のタイミングでIAWCTLレジスタのガードはそのままです。適宜設定してください */
}


/***** End of File *****/




/*""FILE COMMENT""********************************************/
/* System Name : NM Module for S930-LSLibRL78F24xx           */
/* File Name   : l_slin_nmc.c                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/
/* LINライブラリ ROMセクション定義 */
#pragma section  text   @@LNCD
#pragma section  text  @@LNCDL
#pragma section  const   @@LNCNS
#pragma section  const  @@LNCNSL
/* LINライブラリ RAMセクション定義 */
#pragma section  bss   @@LNDT
#pragma section  bss  @@LNDTL

#include "l_slin_user.h"
#include "l_slin_core_rl78f24.h"
#include "l_slin_drv_rl78f24.h"

#define U1L_LIN_FLG_OFF             ((l_u8)0U)
#define U1L_LIN_FLG_ON              ((l_u8)1U)

#define U1L_LIN_SLPIND_SET          ((l_u8)0x80U)   /* SLEEP_INDビットのセット用 */
#define U1L_LIN_WUPIND_SET          ((l_u8)0x40U)   /* WAKEUP_INDビットのセット用 */

/* スレーブタスク用変数 */
static l_u8  u1l_lin_mod_slvstat;                   /* NMスレーブステータス */
static l_u16 u2l_lin_tmr_slvinit;                   /* Tslv_initカウンタ */
static l_u16 u2l_lin_tmr_wurty;                     /* Twurtyカウンタ */
static l_u16 u2l_lin_tmr_3brk;                      /* Tt3brksカウンタ */
static l_u16 u2l_lin_cnt_retry;                     /* Retryカウンタ */
static l_u8  u1l_lin_wup_ind;                       /* Wakeup.ind情報フラグ */
static l_u8  u1l_lin_cnt_msterr;                    /* マスタ監視用カウンタ */
static l_u8  u1l_lin_flg_msterr;                    /* マスタ異常発生フラグ */

static l_u8  u1l_lin_wup_seq;                       /* ウェイクアップ再送シーケンス */
static l_u8  u1l_lin_wup_en;                        /* ウェイクアップ監視許可（WAKE時用） */

/*-- 関数定義(static) --*/
static void l_vol_lin_nm_reset(void);
static void l_vol_lin_nm_sleep(l_u8 u1a_lin_slp_req);
static void l_vol_lin_nm_run_standby(l_u8 u1a_lin_slp_req);
static void l_vol_lin_nm_run_stb_ope_wake(void);
static void l_vol_lin_nm_run_stb_ope_wake_wait(l_u8 u1a_lin_slp_req);
static void l_vol_lin_nm_run(l_u8 u1a_lin_slp_req);

/****************************************************************************/
/*  NM用Tick処理API                                                         */
/*--------------------------------------------------------------------------*/
/*  引数：l_u8 u1a_lin_slp_req                                              */
/*          U1G_LIN_SLP_REQ_OFF(0)   :SLEEP要求無し、又はWAKEUP要因有り     */
/*          U1G_LIN_SLP_REQ_ON(1)    :SLEEP要求有り、又はWAKEUP要因無し     */
/*          U1G_LIN_SLP_REQ_FORCE(2) :強制SLEEP要求有り                     */
/*  戻値：なし                                                              */
/****************************************************************************/
void l_nm_tick(l_u8 u1a_lin_slp_req)
{
    l_u8  u1a_lin_stat;
    l_u8  u1a_lin_tmp_nm_dat;

    u1a_lin_tmp_nm_dat = U1G_LIN_BYTE_CLR;

    /* LINステータスのリード */
    u1a_lin_stat = (l_u8)l_ifc_read_lb_status();

    switch( u1a_lin_stat ) {
    /* LINステータスがRESET状態 */
    case U1G_LIN_STS_RESET:
        l_vol_lin_nm_reset();                           /* LINステータス=RESET時処理 */
        break;
    /* LINステータスがSLEEP状態 */
    case U1G_LIN_STS_SLEEP:
        l_vol_lin_nm_sleep(u1a_lin_slp_req);            /* LINステータス=SLEEP時処理 */
        break;
    /* LINステータスがRUN_STANDBY状態 */
    case U1G_LIN_STS_RUN_STANDBY:
        l_vol_lin_nm_run_standby(u1a_lin_slp_req);      /* LINステータス=RUN STANDBY時処理 */
        break;
    /* LINステータスがRUN状態 */
    case U1G_LIN_STS_RUN:
        l_vol_lin_nm_run(u1a_lin_slp_req);              /* LINステータス=RUN時処理 */
        break;
    default:
        /* 通常は発生しない処理（LINステータス異常） */
        u1g_lin_syserr = U1G_LIN_SYSERR_STAT;           /* システム異常(ステータス) */
        break;
    }

    /* LINライブラリのNM情報書換え処理 */
    /* Data.indについてはユーザによりセットする */
    u1a_lin_tmp_nm_dat = U1G_LIN_BYTE_CLR;
    if( U1G_LIN_SLP_REQ_ON == u1a_lin_slp_req ) {
        /* Sleep.indビットのセット */
        u1a_lin_tmp_nm_dat |= U1L_LIN_SLPIND_SET;
    }
    if( U1L_LIN_FLG_ON == u1l_lin_wup_ind ) {
        /* Wakeup.indビットのセット */
        u1a_lin_tmp_nm_dat |= U1L_LIN_WUPIND_SET;
    }
    /* NM情報書換え関数のコール */
    l_vog_lin_set_nm_info(u1a_lin_tmp_nm_dat);
}

/****************************************************************************/
/*  NM用Tick処理（LINステータス=RESET時）                                   */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：なし                                                              */
/****************************************************************************/
static void l_vol_lin_nm_reset(void)
{
    switch( u1l_lin_mod_slvstat ) {
    /* LINステータスがRESET状態 / NMスレーブステータスがINI_WAIT状態 */
    case U1G_LIN_NM_INI_WAIT:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            l_ifc_connect();                            /* LIN接続  LINステータス→SLEEP */
            l_ifc_run();                                /* RUN状態移行 LINステータス→RUN_STANDBY */

            /***  INITIALIZING -> OPERATIONAL  ACTIVE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_ACTIVE;
        }
        break;
    /* LINステータスがRESET状態 / NMスレーブステータスが */
    /* INI_WAKE、INI_OTH_WAKE、OPE_WAKE_WAIT、OPE_WAKE   */
    /* OPE_OTH_WAKE、OPE_ACTIVE状態                      */
    case U1G_LIN_NM_INI_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_INI_OTH_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_WAKE_WAIT:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_OTH_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_ACTIVE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
        u1l_lin_wup_ind = U1L_LIN_FLG_OFF;

        /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
        break;
    /* LINステータスがRESET状態 / NMスレーブステータスがBS_SLEEP状態 */
    case U1G_LIN_NM_BS_SLEEP:
        break;
    default:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
        u1l_lin_wup_ind = U1L_LIN_FLG_OFF;

        /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
        break;
    }
}

/****************************************************************************/
/*  NM用Tick処理（LINステータス=SLEEP時）                                   */
/*--------------------------------------------------------------------------*/
/*  引数：l_u8 u1a_lin_slp_req                                              */
/*          U1G_LIN_SLP_REQ_OFF(0)   :SLEEP要求無し、又はWAKEUP要因有り     */
/*          U1G_LIN_SLP_REQ_ON(1)    :SLEEP要求有り、又はWAKEUP要因無し     */
/*          U1G_LIN_SLP_REQ_FORCE(2) :強制SLEEP要求有り                     */
/*  戻値：なし                                                              */
/****************************************************************************/
static void l_vol_lin_nm_sleep(l_u8 u1a_lin_slp_req)
{
    switch( u1l_lin_mod_slvstat ) {
    /* LINステータスがSLEEP状態 / NMスレーブステータスがINI_WAIT状態 */
    case U1G_LIN_NM_INI_WAIT:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            l_ifc_run();                                /* RUN状態移行 LINステータス→RUN_STANDBY */
            /***  INITIALIZING -> OPERATIONAL  ACTIVE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_ACTIVE;
        }
        break;
    /* LINステータスがSLEEP状態 / NMスレーブステータスが */
    /* INI_OTH_WAKE、OPE_WAKE_WAIT、OPE_WAKE、           */
    /* OPE_OTH_WAKE、OPE_ACTIVE状態                      */
    case U1G_LIN_NM_INI_OTH_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_WAKE_WAIT:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_OTH_WAKE:
        /* NMステータス異常  フェールセーフとしてBS_SLEEPに遷移 */
    case U1G_LIN_NM_OPE_ACTIVE:
        /* SLEEPコマンド受信  BS_SLEEP に遷移（処理内容は同じ） */
        u1l_lin_wup_ind = U1L_LIN_FLG_OFF;

        /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
        break;
    /* LINステータスがSLEEP状態 / NMスレーブステータスがINI_WAKE状態 */
    case U1G_LIN_NM_INI_WAKE:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT_WAKE <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            u1l_lin_wup_ind     = U1L_LIN_FLG_ON;       /* wakeup.ind ON */
            /* ウェイクアップ送信開始 */
            u2l_lin_tmr_wurty   = U2G_LIN_WORD_CLR;     /* TWURTY タイムカウントクリア */
            u2l_lin_cnt_retry   = U2G_LIN_WORD_CLR;     /* Wakeup送信回数クリア */
            u1l_lin_wup_seq     = U1L_LIN_WUP_WUARTY;   /* Wakeup再送シーケンス TWUARTYカウントへ */
            u1l_lin_wup_en      = U1L_LIN_FLG_OFF;      /* ウェイクアップの監視禁止 */

            l_ifc_wake_up();                            /* ウェイクアップ送信 1回目*/

            /***  INITIALIZING -> OPERATIONAL  WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_WAKE;
        }
        break;
    /* LINステータスがSLEEP状態 / NMスレーブステータスがBS_SLEEP状態 */
    case U1G_LIN_NM_BS_SLEEP:
        if( U1G_LIN_SLP_REQ_OFF == u1a_lin_slp_req ) {
            /** wakeup要因成立 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLVINITカウントクリア */
            u1l_lin_wup_seq     = U1L_LIN_WUP_NONE;     /* ウェイクアップ信号送信終了（明示） */

            /***  BUS SLEEP MODE -> INITIALIZING  WAKE_INI 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_INI_WAKE;
        }
        break;
    default:
        /* NMステータス異常   フェールセーフとして、Bus sleep modeに遷移 */
        u1l_lin_wup_ind = U1L_LIN_FLG_OFF;

        /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
        break;
    }
}

/****************************************************************************/
/*  NM用Tick処理（LINステータス=RUN_STANDBY時）                             */
/*--------------------------------------------------------------------------*/
/*  引数：l_u8 u1a_lin_slp_req                                              */
/*          U1G_LIN_SLP_REQ_OFF(0)   :SLEEP要求無し、又はWAKEUP要因有り     */
/*          U1G_LIN_SLP_REQ_ON(1)    :SLEEP要求有り、又はWAKEUP要因無し     */
/*          U1G_LIN_SLP_REQ_FORCE(2) :強制SLEEP要求有り                     */
/*  戻値：なし                                                              */
/****************************************************************************/
static void l_vol_lin_nm_run_standby(l_u8 u1a_lin_slp_req)
{
    switch( u1l_lin_mod_slvstat ) {
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがINI_WAIT状態 */
    case U1G_LIN_NM_INI_WAIT:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            /***  INITIALIZING -> OPERATIONAL  ACTIVE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_ACTIVE;
        }
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがINI_WAKE状態 */
    case U1G_LIN_NM_INI_WAKE:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT_WAKE <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;     /* T3BRKカウンタクリア */
            /***  INITIALIZING -> OPERATIONAL  OTH_WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
        }
        else{
            u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;     /* T3BRKカウンタクリア */
            /***  INITIALIZING INI_WAKE -> INI_OTH_WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_INI_OTH_WAKE;
        }
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがINI_OTH_WAKE状態 */
    case U1G_LIN_NM_INI_OTH_WAKE:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        u2l_lin_tmr_3brk    += U2G_LIN_NM_TIME_BASE;    /* T3BRKカウント */
        if( U2G_LIN_TM_SLVINIT_WAKE <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            /***  INITIALIZING -> OPERATIONAL  OTH_WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
        }
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがOPE_WAKE_WAIT状態 */
    case U1G_LIN_NM_OPE_WAKE_WAIT:
        l_vol_lin_nm_run_stb_ope_wake_wait(u1a_lin_slp_req);    /* OPE_WAKE_WAIT処理 */
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがOPE_WAKE状態 */
    case U1G_LIN_NM_OPE_WAKE:
        /* 定常処理 */
        l_vol_lin_nm_run_stb_ope_wake();               /* OPE_WAKE処理 */
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがOPE_OTH_WAKE状態 */
    case U1G_LIN_NM_OPE_OTH_WAKE:
        u2l_lin_tmr_3brk += U2G_LIN_NM_TIME_BASE;       /* TT3BRKカウント */

        /* T3BRK待ち継続 */
        if( U2G_LIN_TM_3BRKS <= u2l_lin_tmr_3brk ) {
            /** T3BRK経過 **/
            u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;        /* TT3BRK タイムカウントクリア */
            u1l_lin_cnt_msterr++;                       /* マスタ監視用カウンタインクリメント */
            if( U1G_LIN_CNT_MSTERR <= u1l_lin_cnt_msterr ) {
                u1l_lin_flg_msterr = U1L_LIN_FLG_ON;    /* マスタ異常フラグセット */
                u1l_lin_cnt_msterr = U1G_LIN_BYTE_CLR;  /* マスタ異常カウントクリア */
            }

            l_vog_lin_clr_wupflg();                     /* coreのウェイクアップ検出フラグクリア */
            l_vog_lin_set_int_enb();                    /* INT割り込み許可 */

            /***   -> WAKE-WAIT 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_WAKE_WAIT;
        }
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがOPE_ACTIVE状態 */
    case U1G_LIN_NM_OPE_ACTIVE:
        if( U1G_LIN_SLP_REQ_FORCE == u1a_lin_slp_req ) {
            l_vod_lin_DI();                             /* 割り込み禁止設定 */
            if( U1G_LIN_BIT_SET == F1g_lin_bus_inactive ){
                /** Bus inactive検出 **/
                l_ifc_sleep();                          /* LINステータス→Sleep */
                F1g_lin_bus_inactive = U1G_LIN_BIT_CLR; /* Bus Inactiveフラグクリア */
                u1l_lin_wup_ind = U1L_LIN_FLG_OFF;      /* wakeup.ind OFF */

                /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
                u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
            }
            l_vod_lin_EI();                             /* 割り込み許可 */
        }
        break;
    /* LINステータスがRUN_STANDBY状態 / NMスレーブステータスがBS_SLEEP状態 */
    case U1G_LIN_NM_BS_SLEEP:
        /** wakeup受信 **/
        u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;         /* TSLVINITカウントクリア */
        u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;         /* T3BRKカウンタクリア */

        /***  BUS SLEEP MODE -> INITIALIZING  INI_OTH_WAKE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_INI_OTH_WAKE;
        break;
    default:
        /* NMステータス異常  フェールセーフとしてOPE_OTH_WAKEに遷移  */
        u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;         /* TSLVINITカウントクリア */
        u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;         /* T3BRKカウンタクリア */

        /***   -> OTH_WAKE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
        break;
    }
}

/****************************************************************************/
/*  NM用Tick処理（LINステータス=RUN_STANDBY  NMステータス=OPE_WAKE_WAIT時） */
/*--------------------------------------------------------------------------*/
/*  引数：l_u8 u1a_lin_slp_req                                              */
/*          U1G_LIN_SLP_REQ_OFF(0)   :SLEEP要求無し、又はWAKEUP要因有り     */
/*          U1G_LIN_SLP_REQ_ON(1)    :SLEEP要求有り、又はWAKEUP要因無し     */
/*          U1G_LIN_SLP_REQ_FORCE(2) :強制SLEEP要求有り                     */
/*  戻値：なし                                                              */
/****************************************************************************/
static void l_vol_lin_nm_run_stb_ope_wake_wait(l_u8 u1a_lin_slp_req)
{
    l_u8    u1a_lin_wup_flg;

    u1a_lin_wup_flg = l_u1g_lin_get_wupflg();       /* coreのウェイクアップ検出フラグ取得 */
    if( U1G_LIN_WUP_DET == u1a_lin_wup_flg ) {
        /** wakeup受信 **/
        u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLVINITカウントクリア */
        u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;     /* T3BRKカウンタクリア */

        /***   -> OTH_WAKE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
    }
    else if( U1G_LIN_SLP_REQ_OFF == u1a_lin_slp_req ) {
        /** wakeup要因成立 **/
        u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLVINITカウントクリア */
        u1l_lin_wup_ind     = U1L_LIN_FLG_ON;       /* wakeup.ind ON（再送） */

        /* ウェイクアップ送信開始 */
        u2l_lin_tmr_wurty   = U2G_LIN_WORD_CLR;     /* TWURTY タイムカウントクリア */
        u2l_lin_cnt_retry   = U2G_LIN_WORD_CLR;     /* Wakeup送信回数クリア */
        u1l_lin_wup_seq     = U1L_LIN_WUP_WUARTY;   /* Wakeup再送シーケンス TWUARTYカウントへ */
        u1l_lin_wup_en      = U1L_LIN_FLG_OFF;      /* ウェイクアップの監視禁止 */

        l_ifc_wake_up();                            /* ウェイクアップ送信 1回目*/

        /***   -> WAKE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_WAKE;
    }
    else if( U1G_LIN_SLP_REQ_FORCE == u1a_lin_slp_req )
    {
        l_vod_lin_DI();                             /* 割り込み禁止設定 */
        if( U1G_LIN_BIT_SET == F1g_lin_bus_inactive ){
            /** Bus inactive検出 **/
            l_ifc_sleep();                          /* LINステータス→Sleep */
            F1g_lin_bus_inactive = U1G_LIN_BIT_CLR; /* Bus Inactiveフラグクリア */
            u1l_lin_wup_ind = U1L_LIN_FLG_OFF;      /* wakeup.ind OFF */

            /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
        }
        l_vod_lin_EI();                             /* 割り込み許可 */
    }
    else{
        /* 定常処理  なし */
    }
}

/****************************************************************************/
/*  NM用Tick処理（LINステータス=RUN_STANDBY  NMステータス=OPE_WAKE時）      */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：なし                                                              */
/****************************************************************************/
static void l_vol_lin_nm_run_stb_ope_wake(void)
{
    l_u8 u1a_lin_wup_flg;

    /*** ウェイクアップ信号送信シーケンス遂行   ***/
    if( U1L_LIN_WUP_WUARTY == u1l_lin_wup_seq ) {
        /*** 再送制御 ***/
        if( U2G_LIN_CNT_RETRY > u2l_lin_cnt_retry ) {
            u2l_lin_tmr_wurty += U2G_LIN_NM_TIME_BASE;          /* TWURTYカウンタインクリメント */
            if( U2G_LIN_TM_WURTY <= u2l_lin_tmr_wurty ) {
                l_ifc_wake_up();                                /* ウェイクアップ再送 */
                u2l_lin_cnt_retry++;                            /* ウェイクアップ再送回数インクリメント */
                u2l_lin_tmr_wurty   = U2G_LIN_WORD_CLR;
                /* 最後の送信からTWURTY後にウェイクアップ検出を監視する */
                if( U2G_LIN_CNT_RETRY <= u2l_lin_cnt_retry ) {
                    /* 最後の送信完了 T3BRK待ちへ移行 */
                    u2l_lin_cnt_retry   = U2G_LIN_WORD_CLR;     /* Wakeup送信回数クリア */
                    u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR ;    /* TT3BRK タイムカウントクリア */
                    u1l_lin_wup_seq     = U1L_LIN_WUP_T3BRK;    /* Wakeup再送シーケンス TT3BRKカウントへ */
                }
            }
        }
        else{
            /* ウェイクアップ信号送信シーケンス異常  T3BRK待ちにする */
            u2l_lin_cnt_retry   = U2G_LIN_WORD_CLR;             /* Wakeup送信回数クリア */
            u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR ;            /* TT3BRK タイムカウントクリア */
            u1l_lin_wup_seq     = U1L_LIN_WUP_T3BRK;            /* Wakeup再送シーケンス TT3BRKカウントへ */
        }
    }
    else if( U1L_LIN_WUP_T3BRK == u1l_lin_wup_seq ) {
        /*** T3BRKカウント   TWURTY経過後からウェイクアップの検出を許可。検出したらOTHER-WAKEに遷移する。 ***/
        u2l_lin_tmr_3brk += U2G_LIN_NM_TIME_BASE;
        /* ウェイクアップ検出の確認（OPE_OTH_WAKE遷移条件） */
        if( U1L_LIN_FLG_ON == u1l_lin_wup_en ) {
            u1a_lin_wup_flg = l_u1g_lin_get_wupflg();           /* coreのウェイクアップ検出フラグ取得 */
            if( U1G_LIN_WUP_DET == u1a_lin_wup_flg ) {
                /** wakeup受信 **/
                u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;         /* T3BRKカウンタクリア */
                u2l_lin_tmr_wurty   = U2G_LIN_WORD_CLR;

                /***   -> 他WAKE 遷移  ***/
                u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
            }
        }
        else{
            u2l_lin_tmr_wurty += U2G_LIN_NM_TIME_BASE;
            if( U2G_LIN_TM_WURTY <= u2l_lin_tmr_wurty ) {
                u1l_lin_wup_en = U1L_LIN_FLG_ON;                /* ウェイクアップの監視開始 */
                l_vog_lin_clr_wupflg();                         /* coreのウェイクアップ検出フラグクリア */
                l_vog_lin_set_int_enb();                        /* INT割り込み許可 */
                u2l_lin_tmr_wurty   = U2G_LIN_WORD_CLR;
            }
        }

        /* T3BRK経過判定  ※上部のウェイクアップ検出→他WAKE遷移時はT3BRKカウンタをクリアすることで排他とします */
        if( U2G_LIN_TM_3BRKS <= u2l_lin_tmr_3brk ) {
            /** T3BRK経過 **/
            u2l_lin_tmr_3brk = U2G_LIN_WORD_CLR;                /* TT3BRK タイムカウントクリア */
            u1l_lin_wup_seq  = U1L_LIN_WUP_NONE;                /* ウェイクアップ信号送信シーケンス一巡 */

            u1l_lin_cnt_msterr++;                               /* マスタ監視用カウンタインクリメント */
            if( U1G_LIN_CNT_MSTERR <= u1l_lin_cnt_msterr ) {
                u1l_lin_flg_msterr = U1L_LIN_FLG_ON;            /* マスタ異常フラグセット */
                u1l_lin_cnt_msterr = U1G_LIN_BYTE_CLR;          /* マスタ異常カウントクリア */
            }

            /***   -> WAKE-WAIT 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_WAKE_WAIT;
        }
    }
    else{
        /* ウェイクアップ信号送信シーケンス異常  T3BRK待ちにする */
        u2l_lin_cnt_retry   = U2G_LIN_WORD_CLR;                 /* Wakeup送信回数クリア */
        u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR ;                /* TT3BRK タイムカウントクリア */
        u1l_lin_wup_seq     = U1L_LIN_WUP_T3BRK;                /* Wakeup再送シーケンス TT3BRKカウントへ */
    }
}

/****************************************************************************/
/*  NM用Tick処理（LINステータス=RUN時）                                     */
/*--------------------------------------------------------------------------*/
/*  引数：l_u8 u1a_lin_slp_req                                              */
/*          U1G_LIN_SLP_REQ_OFF(0)   :SLEEP要求無し、又はWAKEUP要因有り     */
/*          U1G_LIN_SLP_REQ_ON(1)    :SLEEP要求有り、又はWAKEUP要因無し     */
/*          U1G_LIN_SLP_REQ_FORCE(2) :強制SLEEP要求有り                     */
/*  戻値：なし                                                              */
/****************************************************************************/
static void l_vol_lin_nm_run(l_u8 u1a_lin_slp_req)
{
    switch( u1l_lin_mod_slvstat ) {
    /* LINステータスがRUN状態 / NMスレーブステータスがINI_WAIT状態 */
    case U1G_LIN_NM_INI_WAIT:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            /***  INITIALIZING -> OPERATIONAL  ACTIVE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_ACTIVE;
        }
        break;
    /* LINステータスがRUN状態 / NMスレーブステータスがINI_WAKE状態 */
    case U1G_LIN_NM_INI_WAKE:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        if( U2G_LIN_TM_SLVINIT_WAKE <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;     /* T3BRKカウンタクリア */
            /***  INITIALIZING -> OPERATIONAL  OTH_WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
        }
        else{
            u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;     /* T3BRKカウンタクリア */
            /***  -> INI_OTH_WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_INI_OTH_WAKE;
        }
        break;
    /* LINステータスがRUN状態 / NMスレーブステータスがINI_OTH_WAKE状態 */
    case U1G_LIN_NM_INI_OTH_WAKE:
        u2l_lin_tmr_slvinit += U2G_LIN_NM_TIME_BASE;    /* TSLV_INITカウント */
        u2l_lin_tmr_3brk    += U2G_LIN_NM_TIME_BASE;    /* T3BRKカウント */
        if( U2G_LIN_TM_SLVINIT_WAKE <= u2l_lin_tmr_slvinit ) {
            /** TSLV_INIT経過 **/
            u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLV_INITカウンタクリア */
            /***  INITIALIZING -> OPERATIONAL  OTH_WAKE 遷移  ***/
            u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_OTH_WAKE;
        }
        break;
    /* LINステータスがRUN状態 / NMスレーブステータスが */
    /* OPE_WAKE_WAIT、OPE_WAKE、OPE_OTH_WAKE状態       */
    case U1G_LIN_NM_OPE_WAKE_WAIT:
        /* NMステータス異常  フェールセーフとしてOPE  ACTIVEに遷移（処理内容は同じ） */
    case U1G_LIN_NM_OPE_WAKE:
        /* スケジュール検出  OPE  ACTIVE に遷移 */
    case U1G_LIN_NM_OPE_OTH_WAKE:
        /* スケジュール検出  OPE  ACTIVE に遷移 */
        u1l_lin_wup_seq     = U1L_LIN_WUP_NONE;     /* ウェイクアップ信号送信終了 */

        u1l_lin_cnt_msterr = U1G_LIN_BYTE_CLR;      /* マスタ監視用カウンタクリア */
        u1l_lin_flg_msterr = U1L_LIN_FLG_OFF;       /* マスタ異常フラグクリア */
        /***   -> ACTIVE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_ACTIVE;
        break;
    /* LINステータスがRUN状態 / NMスレーブステータスがOPE_ACTIVE状態 */
    case U1G_LIN_NM_OPE_ACTIVE:
        if( U1G_LIN_SLP_REQ_FORCE == u1a_lin_slp_req ){
            l_vod_lin_DI();                             /* 割り込み禁止設定 */
            if( U1G_LIN_BIT_SET == F1g_lin_bus_inactive ){
                /** Bus inactive検出 **/
                l_ifc_sleep();                          /* LINステータス→Sleep */
                F1g_lin_bus_inactive = U1G_LIN_BIT_CLR; /* Bus Inactiveフラグクリア */
                u1l_lin_wup_ind = U1L_LIN_FLG_OFF;      /* wakeup.ind OFF */

                /***  OPERATIONAL -> BUS SLEEP MODE 遷移  ***/
                u1l_lin_mod_slvstat = U1G_LIN_NM_BS_SLEEP;
            }
            l_vod_lin_EI();                             /* 割り込み許可 */
        }
        break;
    /* LINステータスがRUN状態 / NMスレーブステータスがBS_SLEEP状態 */
    case U1G_LIN_NM_BS_SLEEP:
        /** wakeup受信 **/
        u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;     /* TSLVINITカウントクリア */
        u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;     /* T3BRKカウンタクリア */

        /***  BUS SLEEP MODE -> INITIALIZING  OTH_WAKE_INI 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_INI_OTH_WAKE;
        break;
    default:
        /* NMステータス異常  フェールセーフとしてOPE_ACTIVEに遷移 */
        u1l_lin_wup_seq     = U1L_LIN_WUP_NONE;     /* ウェイクアップ信号送信終了 */

        u1l_lin_cnt_msterr  = U1G_LIN_BYTE_CLR;     /* マスタ監視用カウンタクリア */
        u1l_lin_flg_msterr  = U1L_LIN_FLG_OFF;      /* マスタ異常フラグクリア */
        /***   -> ACTIVE 遷移  ***/
        u1l_lin_mod_slvstat = U1G_LIN_NM_OPE_ACTIVE;
        break;
    }
}


/****************************************************************************/
/*  NM用初期化処理API                                                       */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：なし                                                              */
/****************************************************************************/
void l_nm_init(void)
{
/* スレーブタスク用変数 */
    u1l_lin_mod_slvstat = U1G_LIN_NM_INI_WAIT;
    u2l_lin_tmr_slvinit = U2G_LIN_WORD_CLR;

    u2l_lin_tmr_wurty   = U2G_LIN_WORD_CLR;
    u2l_lin_tmr_3brk    = U2G_LIN_WORD_CLR;
    u2l_lin_cnt_retry   = U2G_LIN_WORD_CLR;
    u1l_lin_wup_ind     = U1L_LIN_FLG_OFF;
    u1l_lin_cnt_msterr  = U1G_LIN_BYTE_CLR;
    u1l_lin_flg_msterr  = U1L_LIN_FLG_OFF;

    u1l_lin_wup_seq     = U1L_LIN_WUP_NONE;
    u1l_lin_wup_en      = U1L_LIN_FLG_OFF;
}


/****************************************************************************/
/*  NMスレーブステータスリードAPI                                           */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：l_u8  NMスレーブステータス                                        */
/****************************************************************************/
l_u8 l_nm_rd_slv_stat(void)
{
    return (u1l_lin_mod_slvstat);
}


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/****************************************************************************/
/*  マスタ異常フラグのリードAPI                                             */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：l_u8  0：マスタ異常なし, 1:マスタ異常あり                         */
/****************************************************************************/
l_u8 l_nm_rd_mst_err(void)
{
    return (u1l_lin_flg_msterr);
}
#endif


#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
/****************************************************************************/
/*  マスタ異常フラグのクリアAPI                                             */
/*--------------------------------------------------------------------------*/
/*  引数：なし                                                              */
/*  戻値：なし                                                              */
/****************************************************************************/
void l_nm_clr_mst_err(void)
{
    u1l_lin_flg_msterr = U1L_LIN_FLG_OFF;
}
#endif

/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : NM Module for S930-LSLibRL78F24xx           */
/* File Name   : l_slin_nmc.h                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_NMC_H_INCLUDE
#define L_SLIN_NMC_H_INCLUDE

/* ユーザ編集可能な定数定義 */
/* スレーブタスク用定数 */
#define U2G_LIN_TM_SLVINIT          ((l_u16)0U)     /* 初期化完了時間 ～100ms （起動時） */
#define U2G_LIN_TM_SLVINIT_WAKE     ((l_u16)0U)     /* 初期化完了時間 ～100ms （Wakeup時） */

#define U2G_LIN_TM_WURTY            ((l_u16)155U)   /* ウェイクアップ信号リトライ時間 “150 + U2G_LIN_NM_TIME_BASE”以上の値を設定してください。 */
                                                    /* U2G_LIN_TM_WURTYは、前回のWakeup信号の立下がりエッジから、次回のWakeup信号の立下がりエッジまでの間隔で、 */
                                                    /* LIN規格では、前回のWakeup信号の立上がりエッジから、次のWakeup信号の立下がりエッジまでの間隔を150ms以上と規定しており、 */
                                                    /* Wakeup信号の長さ分、表す時間に差があるため。*/
#define U2G_LIN_TM_3BRKS            ((l_u16)1500U)  /* TIME-OUT AFTER THREE BREAKS */
#define U2G_LIN_CNT_RETRY           ((l_u16)2U)     /* ウェイクアップリトライ回数 */
#define U2G_LIN_NM_TIME_BASE        ((l_u16)5U)     /* NM用タイムベース時間 */
#define U1G_LIN_CNT_MSTERR          ((l_u8)3U)      /* マスタ異常検出までのウェイクアップ失敗回数 */

/* ライブラリ参照用定数定義(ユーザ編集不可) */
/* スレーブタスク用定数 */
#define U1G_LIN_NM_INI_WAIT         ((l_u8)0U)      /* NM INITIALIZING状態 起動時 */
#define U1G_LIN_NM_INI_WAKE         ((l_u8)1U)      /* NM INITIALIZING状態 自ノードWakeup時 */
#define U1G_LIN_NM_INI_OTH_WAKE     ((l_u8)2U)      /* NM INITIALIZING状態 他ノードWakeup時 */
#define U1G_LIN_NM_OPE_WAKE_WAIT    ((l_u8)3U)      /* NM OPERATIONAL状態 Wakeup待ち状態 */
#define U1G_LIN_NM_OPE_WAKE         ((l_u8)4U)      /* NM OPERATIONAL状態 自ノードWakeup時 */
#define U1G_LIN_NM_OPE_OTH_WAKE     ((l_u8)5U)      /* NM OPERATIONAL状態 他ノードWakeup時 */
#define U1G_LIN_NM_OPE_ACTIVE       ((l_u8)6U)      /* NM OPERATIONAL状態 スケジュール検出時 */
#define U1G_LIN_NM_BS_SLEEP         ((l_u8)7U)      /* NM BUS SLEEP MODE状態 */


/* ウェイクアップ再送制御用定数 */
#define U1L_LIN_WUP_NONE            ((l_u8)0U)      /* Wakeup再送制御 停止 */
#define U1L_LIN_WUP_T3BRK           ((l_u8)1U)      /* Wakeup再送制御 TT3BRKカウント中 */
#define U1L_LIN_WUP_WUARTY          ((l_u8)2U)      /* Wakeup再送制御 TWUARTYカウント中 */

#define U1G_LIN_SLP_REQ_OFF         ((l_u8)0U)      /* スリープ要求無し,又はウェイクアップ要因有り */
#define U1G_LIN_SLP_REQ_ON          ((l_u8)1U)      /* スリープ要求有り,又はウェイクアップ要因無し */
#define U1G_LIN_SLP_REQ_FORCE       ((l_u8)2U)      /* 強制スリープ要因有り */

/*** 関数のプロトタイプ宣言(global) ***/
void l_nm_init(void);
void l_nm_tick(l_u8 u1a_lin_slp_req);
l_u8 l_nm_rd_slv_stat(void);
#if U1G_LIN_ROM_SHRINK == U1G_LIN_ROM_SHRINK_OFF
l_u8 l_nm_rd_mst_err(void);
void l_nm_clr_mst_err(void);
#endif

#endif

/***** End of File *****/





/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_sfr.h                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_SFR_RL78F24_H_INCLUDE
#define L_SLIN_SFR_RL78F24_H_INCLUDE

#include "aipf_sfr_rl78_f24.h"


/**** Clock ****/
#define U1G_LIN_SFR_PER2                PER2                                            /* 周辺イネーブル・レジスタ2 PER2 */
#define U1G_LIN_SFR_LINCKSEL            LINCKSEL                                        /* LINクロック選択レジスタ LINCKSEL */

#if U1G_LIN_CH == U1G_LIN_LINCH_0
#define U1G_LIN_SFR_BIT_LINEN           LIN0EN                                          /* LIN0EN bit   LIN0の入力クロック供給の制御 */
#define U1G_LIN_SFR_BIT_LINMCKE         LIN0MCKE                                        /* LIN0MCKE bit   LIN0のエンジンクロック供給/停止制御 */
#define U1G_LIN_SFR_BIT_LINMCK          LIN0MCK                                         /* LIN0MCK bit   LIN0のエンジンクロック選択制御 */
#elif U1G_LIN_CH == U1G_LIN_LINCH_1
#define U1G_LIN_SFR_BIT_LINEN           LIN1EN                                          /* LIN1EN bit   LIN1の入力クロック供給の制御 */
#define U1G_LIN_SFR_BIT_LINMCKE         LIN1MCKE                                        /* LIN1MCKE bit   LIN1のエンジンクロック供給/停止制御 */
#define U1G_LIN_SFR_BIT_LINMCK          LIN1MCK                                         /* LIN1MCK bit   LIN1のエンジンクロック選択制御 */
#endif

#if U1G_LIN_TIMER_UNIT == U1G_LIN_TIMER_UNIT_0
#define U1G_LIN_SFR_BIT_TAUEN           TAU0EN
#elif U1G_LIN_TIMER_UNIT == U1G_LIN_TIMER_UNIT_1
#define U1G_LIN_SFR_BIT_TAUEN           TAU1EN
#endif

/***** LIN *****/
#define U1G_LIN_SFR_IF0H                IF0H                                            /* 割り込み要求フラグ・レジスタ IF0H */
#define U1G_LIN_SFR_MK0H                MK0H                                            /* 割り込みマスク・フラグ・レジスタ MK0H */
#define U1G_LIN_SFR_PR_0X0H             PR00H                                           /* 優先順位指定フラグ・レジスタ PR00H */
#define U1G_LIN_SFR_PR_1X0H             PR10H                                           /* 優先順位指定フラグ・レジスタ PR10H */

#define U1G_LIN_SFR_IF1L                IF1L                                            /* 割り込み要求フラグ・レジスタ IF1L */
#define U1G_LIN_SFR_MK1L                MK1L                                            /* 割り込みマスク・フラグ・レジスタ MK1L */
#define U1G_LIN_SFR_PR_0X1L             PR01L                                           /* 優先順位指定フラグ・レジスタ PR01L */
#define U1G_LIN_SFR_PR_1X1L             PR11L                                           /* 優先順位指定フラグ・レジスタ PR11L */

#define U1G_LIN_SFR_IF3L                IF3L                                            /* 割り込み要求フラグ・レジスタ IF3L */
#define U1G_LIN_SFR_MK3L                MK3L                                            /* 割り込みマスク・フラグ・レジスタ MK3L */
#define U1G_LIN_SFR_PR_0X3L             PR03L                                           /* 優先順位指定フラグ・レジスタ PR03L */
#define U1G_LIN_SFR_PR_1X3L             PR13L                                           /* 優先順位指定フラグ・レジスタ PR13L */

#define U1G_LIN_SFR_LCHSEL              LCHSEL                                          /* LINチャネル選択レジスタ LCHSEL */

#if U1G_LIN_CH == U1G_LIN_LINCH_0
#define U1G_LIN_SFR_LWBR                LWBR0                                           /* LINウェイクアップボーレート選択レジスタ LWBR */
#define U2G_LIN_SFR_LBRP                LBRP0                                           /* LINボーレートプリスケーラレジスタ LBRP */
#define U1G_LIN_SFR_LMD                 LMD0                                            /* LINモードレジスタ LMD */
#define U1G_LIN_SFR_LBFC                LBFC0                                           /* LINブレークフィールド設定レジスタ LBFC */
#define U1G_LIN_SFR_LSC                 LSC0                                            /* LINスペース設定レジスタ LSC */
#define U1G_LIN_SFR_LWUP                LWUP0                                           /* LINウェイクアップ設定レジスタ LWUP */
#define U1G_LIN_SFR_LIE                 LIE0                                            /* LIN割り込み許可レジスタ LIE */
#define U1G_LIN_SFR_LEDE                LEDE0                                           /* LINエラー検出許可レジスタ LEDE */
#define U1G_LIN_SFR_LCUC                LCUC0                                           /* LIN制御レジスタ LCUC */
#define U1G_LIN_SFR_LTRC                LTRC0                                           /* LIN送信制御レジスタ LTRC */
#define U1G_LIN_SFR_LMST                LMST0                                           /* LINモードステータスレジスタ LMST */
#define U1G_LIN_SFR_LST                 LST0                                            /* LINステータスレジスタ LST */
#define U1G_LIN_SFR_LEST                LEST0                                           /* LINエラーステータスレジスタ LEST */
#define U1G_LIN_SFR_LDFC                LDFC0                                           /* LINレスポンスフィールド設定レジスタ LDFC */
#define U1G_LIN_SFR_LIDB                LIDB0                                           /* LIN IDバッファレジスタ LIDB */
#define U1G_LIN_SFR_LDB1                LDB01                                           /* LINデータ1バッファレジスタ LDB1 */
#define U1G_LIN_SFR_LDB2                LDB02                                           /* LINデータ2バッファレジスタ LDB2 */
#define U1G_LIN_SFR_LDB3                LDB03                                           /* LINデータ3バッファレジスタ LDB3 */
#define U1G_LIN_SFR_LDB4                LDB04                                           /* LINデータ4バッファレジスタ LDB4 */
#define U1G_LIN_SFR_LDB5                LDB05                                           /* LINデータ5バッファレジスタ LDB5 */
#define U1G_LIN_SFR_LDB6                LDB06                                           /* LINデータ6バッファレジスタ LDB6 */
#define U1G_LIN_SFR_LDB7                LDB07                                           /* LINデータ7バッファレジスタ LDB7 */
#define U1G_LIN_SFR_LDB8                LDB08                                           /* LINデータ8バッファレジスタ LDB8 */
#elif U1G_LIN_CH == U1G_LIN_LINCH_1
#define U1G_LIN_SFR_LWBR                LWBR1                                           /* LINウェイクアップボーレート選択レジスタ LWBR */
#define U2G_LIN_SFR_LBRP                LBRP1                                           /* LINボーレートプリスケーラレジスタ LBRP */
#define U1G_LIN_SFR_LMD                 LMD1                                            /* LINモードレジスタ LMD */
#define U1G_LIN_SFR_LBFC                LBFC1                                           /* LINブレークフィールド設定レジスタ LBFC */
#define U1G_LIN_SFR_LSC                 LSC1                                            /* LINスペース設定レジスタ LSC */
#define U1G_LIN_SFR_LWUP                LWUP1                                           /* LINウェイクアップ設定レジスタ LWUP */
#define U1G_LIN_SFR_LIE                 LIE1                                            /* LIN割り込み許可レジスタ LIE */
#define U1G_LIN_SFR_LEDE                LEDE1                                           /* LINエラー検出許可レジスタ LEDE */
#define U1G_LIN_SFR_LCUC                LCUC1                                           /* LIN制御レジスタ LCUC */
#define U1G_LIN_SFR_LTRC                LTRC1                                           /* LIN送信制御レジスタ LTRC */
#define U1G_LIN_SFR_LMST                LMST1                                           /* LINモードステータスレジスタ LMST */
#define U1G_LIN_SFR_LST                 LST1                                            /* LINステータスレジスタ LST */
#define U1G_LIN_SFR_LEST                LEST1                                           /* LINエラーステータスレジスタ LEST */
#define U1G_LIN_SFR_LDFC                LDFC1                                           /* LINレスポンスフィールド設定レジスタ LDFC */
#define U1G_LIN_SFR_LIDB                LIDB1                                           /* LIN IDバッファレジスタ LIDB */
#define U1G_LIN_SFR_LDB1                LDB11                                           /* LINデータ1バッファレジスタ LDB1 */
#define U1G_LIN_SFR_LDB2                LDB12                                           /* LINデータ2バッファレジスタ LDB2 */
#define U1G_LIN_SFR_LDB3                LDB13                                           /* LINデータ3バッファレジスタ LDB3 */
#define U1G_LIN_SFR_LDB4                LDB14                                           /* LINデータ4バッファレジスタ LDB4 */
#define U1G_LIN_SFR_LDB5                LDB15                                           /* LINデータ5バッファレジスタ LDB5 */
#define U1G_LIN_SFR_LDB6                LDB16                                           /* LINデータ6バッファレジスタ LDB6 */
#define U1G_LIN_SFR_LDB7                LDB17                                           /* LINデータ7バッファレジスタ LDB7 */
#define U1G_LIN_SFR_LDB8                LDB18                                           /* LINデータ8バッファレジスタ LDB8 */
#endif

#if U1G_LIN_CH == U1G_LIN_LINCH_0
#define U1G_LIN_SFR_BIT_LINTRMIF        LIN0TRMIF                                       /* LIN0TRMIF bit   LIN0送信割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINTRMMK        LIN0TRMMK                                       /* LIN0TRMMK bit   LIN0送信割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINTRMPR0       LIN0TRMPR0                                      /* LIN0TRMPR0 bit  LIN0送信割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINTRMPR1       LIN0TRMPR1                                      /* LIN0TRMPR1 bit  LIN0送信割り込み優先順位指定フラグ1 */

#define U1G_LIN_SFR_BIT_LINRVCIF        LIN0RVCIF                                       /* LIN0RVCIF bit   LIN0受信割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINRVCMK        LIN0RVCMK                                       /* LIN0RVCMK bit   LIN0受信割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINRVCPR0       LIN0RVCPR0                                      /* LIN0RVCPR0 bit  LIN0受信割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINRVCPR1       LIN0RVCPR1                                      /* LIN0RVCPR1 bit  LIN0受信割り込み優先順位指定フラグ1 */

#define U1G_LIN_SFR_BIT_LINSTAIF        LIN0STAIF                                       /* LIN0STAIF bit   LIN0ステータスエラー割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINSTAMK        LIN0STAMK                                       /* LIN0STAMK bit   LIN0ステータスエラー割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINSTAPR0       LIN0STAPR0                                      /* LIN0STAPR0 bit  LIN0ステータスエラー割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINSTAPR1       LIN0STAPR1                                      /* LIN0STAPR1 bit  LIN0ステータスエラー割り込み優先順位指定フラグ1 */
#elif U1G_LIN_CH == U1G_LIN_LINCH_1
#define U1G_LIN_SFR_BIT_LINTRMIF        LIN1TRMIF                                       /* LIN1TRMIF bit   LIN1送信割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINTRMMK        LIN1TRMMK                                       /* LIN1TRMMK bit   LIN1送信割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINTRMPR0       LIN1TRMPR0                                      /* LIN1TRMPR0 bit  LIN1送信割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINTRMPR1       LIN1TRMPR1                                      /* LIN1TRMPR1 bit  LIN1送信割り込み優先順位指定フラグ1 */

#define U1G_LIN_SFR_BIT_LINRVCIF        LIN1RVCIF                                       /* LIN1RVCIF bit   LIN1受信割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINRVCMK        LIN1RVCMK                                       /* LIN1RVCMK bit   LIN1受信割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINRVCPR0       LIN1RVCPR0                                      /* LIN1RVCPR0 bit  LIN1受信割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINRVCPR1       LIN1RVCPR1                                      /* LIN1RVCPR1 bit  LIN1受信割り込み優先順位指定フラグ1 */

#define U1G_LIN_SFR_BIT_LINSTAIF        LIN1STAIF                                       /* LIN1STAIF bit   LIN1ステータスエラー割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINSTAMK        LIN1STAMK                                       /* LIN1STAMK bit   LIN1ステータスエラー割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINSTAPR0       LIN1STAPR0                                      /* LIN1STAPR0 bit  LIN1ステータスエラー割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINSTAPR1       LIN1STAPR1                                      /* LIN1STAPR1 bit  LIN1ステータスエラー割り込み優先順位指定フラグ1 */
#endif

/* INT */
#define U1G_LIN_SFR_ISC                 ISC                                             /* 入力切り替え制御レジスタ ISC */
#define U1G_LIN_SFR_EGP1                EGP1                                            /* 外部割り込み立ち上がりエッジ許可レジスタ EGP1 */
#define U1G_LIN_SFR_EGN1                EGN1                                            /* 外部割り込み立ち下がりエッジ許可レジスタ EGN1 */
#define U1G_LIN_SFR_IF2L                IF2L                                            /* 割り込み要求フラグ・レジスタ IF2L */
#define U1G_LIN_SFR_MK2L                MK2L                                            /* 割り込みマスク・フラグ・レジスタ MK2L */
#define U1G_LIN_SFR_PR_0X2L             PR02L                                           /* 優先順位指定フラグ・レジスタ PR02L */
#define U1G_LIN_SFR_PR_1X2L             PR12L                                           /* 優先順位指定フラグ・レジスタ PR12L */

#if U1G_LIN_CH == U1G_LIN_LINCH_0
#define U1G_LIN_SFR_BIT_ISC             ISC_bit.no2                                     /* ISC2 bit   外部割り込み（INTP11）の入力選択 */
#define U1G_LIN_SFR_BIT_LINWUPIF        LIN0WUPIF                                       /* LIN0WUPIF bit   LIN0受信端子入力割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINWUPMK        LIN0WUPMK                                       /* LIN0WUPMK bit   LIN0受信端子入力割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINWUPPR0       LIN0WUPPR0                                      /* LIN0WUPPR0 bit  LIN0受信端子入力割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINWUPPR1       LIN0WUPPR1                                      /* LIN0WUPPR1 bit  LIN0受信端子入力割り込み優先順位指定フラグ1 */
#define U1G_LIN_SFR_BIT_EGP             EGP1_bit.no3                                    /* EGP11 bit   INTPn端子の有効エッジの選択（立ち上がり許可） */
#define U1G_LIN_SFR_BIT_EGN             EGN1_bit.no3                                    /* EGN11 bit   INTPn端子の有効エッジの選択（立ち下がり許可） */
#elif U1G_LIN_CH == U1G_LIN_LINCH_1
#define U1G_LIN_SFR_BIT_ISC             ISC_bit.no3                                     /* ISC3 bit   外部割り込み（INTP12）の入力選択 */
#define U1G_LIN_SFR_BIT_LINWUPIF        LIN1WUPIF                                       /* LIN1WUPIF bit   LIN1受信端子入力割り込み要求フラグ */
#define U1G_LIN_SFR_BIT_LINWUPMK        LIN1WUPMK                                       /* LIN1WUPMK bit   LIN1受信端子入力割り込みマスク・フラグ */
#define U1G_LIN_SFR_BIT_LINWUPPR0       LIN1WUPPR0                                      /* LIN1WUPPR0 bit  LIN1受信端子入力割り込み優先順位指定フラグ0 */
#define U1G_LIN_SFR_BIT_LINWUPPR1       LIN1WUPPR1                                      /* LIN1WUPPR1 bit  LIN1受信端子入力割り込み優先順位指定フラグ1 */
#define U1G_LIN_SFR_BIT_EGP             EGP1_bit.no4                                    /* EGP12 bit   INTPn端子の有効エッジの選択（立ち上がり許可） */
#define U1G_LIN_SFR_BIT_EGN             EGN1_bit.no4                                    /* EGN12 bit   INTPn端子の有効エッジの選択（立ち下がり許可） */
#endif

/* SFRガード機能制御レジスタ */
#define U1G_LIN_SFR_IAWCTL              IAWCTL                                          /* 不正メモリ・アクセス検出制御レジスタ IAWCTL */


/***** TAU *****/
#if U1G_LIN_TIMER_UNIT == U1G_LIN_TIMER_UNIT_0
#define U2G_LIN_TAU_TPS                 TPS0                                            /* タイマ・クロック選択レジスタ TPS */
#define U1G_LIN_TAU_TO                  TO0L                                            /* タイマ出力レジスタ TO */
#define U1G_LIN_TAU_TE                  TE0L                                            /* タイマ・チャネル許可ステータス・レジスタ TE */
#define U1G_LIN_TAU_TOE                 TOE0L                                           /* タイマ出力許可レジスタ TOE */
#define U1G_LIN_TAU_TS                  TS0L                                            /* タイマ・チャネル開始レジスタ TS */
#define U1G_LIN_TAU_TT                  TT0L                                            /* タイマ・チャネル停止レジスタ TT */
#if U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_0
#define U2G_LIN_TAU_TMR                 TMR00                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR00                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR000                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR100                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK00                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF00                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_1
#define U2G_LIN_TAU_TMR                 TMR01                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR01                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR001                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR101                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK01                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF01                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_2
#define U2G_LIN_TAU_TMR                 TMR02                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR02                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR002                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR102                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK02                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF02                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_3
#define U2G_LIN_TAU_TMR                 TMR03                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR03                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR003                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR103                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK03                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF03                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_4
#define U2G_LIN_TAU_TMR                 TMR04                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR04                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR004                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR104                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK04                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF04                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_5
#define U2G_LIN_TAU_TMR                 TMR05                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR05                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR005                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR105                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK05                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF05                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_6
#define U2G_LIN_TAU_TMR                 TMR06                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR06                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR006                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR106                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK06                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF06                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_7
#define U2G_LIN_TAU_TMR                 TMR07                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR07                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR007                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR107                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK07                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF07                                          /* 割り込み要求フラグ・レジスタ TMIF */
#endif
#elif U1G_LIN_TIMER_UNIT == U1G_LIN_TIMER_UNIT_1
#define U2G_LIN_TAU_TPS                 TPS1                                            /* タイマ・クロック選択レジスタ TPS */
#define U1G_LIN_TAU_TO                  TO1L                                            /* タイマ出力レジスタ TO */
#define U1G_LIN_TAU_TE                  TE1L                                            /* タイマ・チャネル許可ステータス・レジスタ TE */
#define U1G_LIN_TAU_TOE                 TOE1L                                           /* タイマ出力許可レジスタ TOE */
#define U1G_LIN_TAU_TS                  TS1L                                            /* タイマ・チャネル開始レジスタ TS */
#define U1G_LIN_TAU_TT                  TT1L                                            /* タイマ・チャネル停止レジスタ TT */
#if U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_0
#define U2G_LIN_TAU_TMR                 TMR10                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR10                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR010                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR110                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK10                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF10                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_1
#define U2G_LIN_TAU_TMR                 TMR11                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR11                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR011                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR111                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK11                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF11                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_2
#define U2G_LIN_TAU_TMR                 TMR12                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR12                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR012                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR112                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK12                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF12                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_3
#define U2G_LIN_TAU_TMR                 TMR13                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR13                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR013                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR113                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK13                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF13                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_4
#define U2G_LIN_TAU_TMR                 TMR14                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR14                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR014                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR114                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK14                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF14                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_5
#define U2G_LIN_TAU_TMR                 TMR15                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR15                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR015                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR115                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK15                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF15                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_6
#define U2G_LIN_TAU_TMR                 TMR16                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR16                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR016                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR116                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK16                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF16                                          /* 割り込み要求フラグ・レジスタ TMIF */
#elif U1G_LIN_TIMER_CH == U1G_LIN_TIMER_CH_7
#define U2G_LIN_TAU_TMR                 TMR17                                           /* TAU タイマ・モードレジスタ TMR */
#define U2G_LIN_TAU_TDR                 TDR17                                           /* TAU タイマ・データレジスタ TDR */
#define U1G_LIN_TAU_BIT_TMPR0           TMPR017                                         /* 優先順位指定フラグ・レジスタ TMPR0 */
#define U1G_LIN_TAU_BIT_TMPR1           TMPR117                                         /* 優先順位指定フラグ・レジスタ TMPR1 */
#define U1G_LIN_TAU_BIT_TMMK            TMMK17                                          /* 割り込みマスク・フラグ TMMK */
#define U1G_LIN_TAU_BIT_TMIF            TMIF17                                          /* 割り込み要求フラグ・レジスタ TMIF */
#endif
#endif

#endif

/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_tbl.c                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/
/* LINライブラリ ROMセクション定義 */
#pragma section  text   @@LNCD
#pragma section  text  @@LNCDL
#pragma section  const   @@LNCNS
#pragma section  const  @@LNCNSL
/* LINライブラリ RAMセクション定義 */
#pragma section  bss   @@LNDT
#pragma section  bss  @@LNDTL

#include "l_slin_user.h"

/********************************/
/* スレーブタスク用テーブル設定 */
/********************************/
/* ID情報テーブル 実体 (LDF: Frames) */

const l_u8  u1g_lin_id_tbl[ U1G_LIN_MAX_SLOT_NUM ] = {
    (l_u8)0xFFU, (l_u8)0x01U, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0x00U, (l_u8)0xFFU  /* Identifier : 0x00 - 0x07 */
   ,(l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU  /* Identifier : 0x08 - 0x0F */
   ,(l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0x02U  /* Identifier : 0x10 - 0x17 */
   ,(l_u8)0xFFU, (l_u8)0x04U, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU  /* Identifier : 0x18 - 0x1F */
   ,(l_u8)0xFFU, (l_u8)0x03U, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU  /* Identifier : 0x20 - 0x27 */
   ,(l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU  /* Identifier : 0x28 - 0x2F */
   ,(l_u8)0xFFU, (l_u8)0x05U, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU  /* Identifier : 0x30 - 0x37 */
   ,(l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0xFFU, (l_u8)0x06U, (l_u8)0x07U, (l_u8)0xFFU, (l_u8)0xFFU  /* Identifier : 0x38 - 0x3F */
};

/* スロット情報テーブル 実体 */
const st_lin_slot_info_type  xng_lin_slot_tbl[ U1G_LIN_MAX_SLOT ] = {
    { (l_u8)0x06U, U1G_LIN_DL_2, U1G_LIN_CMD_SND, U1G_LIN_NM_USE, U1G_LIN_SUM_ENHANCED
       ,{ (l_u8)0x8AU, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x01U, U1G_LIN_DL_2, U1G_LIN_CMD_RCV, U1G_LIN_NM_NO_USE, U1G_LIN_SUM_ENHANCED
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x17U, U1G_LIN_DL_4, U1G_LIN_CMD_SND, U1G_LIN_NM_USE, U1G_LIN_SUM_ENHANCED
       ,{ (l_u8)0x8AU, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x21U, U1G_LIN_DL_4, U1G_LIN_CMD_RCV, U1G_LIN_NM_NO_USE, U1G_LIN_SUM_ENHANCED
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x19U, U1G_LIN_DL_8, U1G_LIN_CMD_SND, U1G_LIN_NM_USE, U1G_LIN_SUM_ENHANCED
       ,{ (l_u8)0x8AU, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x31U, U1G_LIN_DL_8, U1G_LIN_CMD_RCV, U1G_LIN_NM_NO_USE, U1G_LIN_SUM_ENHANCED
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x3CU, U1G_LIN_DL_8, U1G_LIN_CMD_RCV, U1G_LIN_NM_NO_USE, U1G_LIN_SUM_CLASSIC
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
   ,{ (l_u8)0x3DU, U1G_LIN_DL_8, U1G_LIN_CMD_SND, U1G_LIN_NM_NO_USE, U1G_LIN_SUM_CLASSIC
       ,{ (l_u8)0xAAU, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
       ,{ (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U, (l_u8)0x00U }
    }
};


/***************************************************************************/
/***************************************************************************/
/*           !!!以降は絶対に 変更、削除をおこなわないで下さい!!!           */
/***************************************************************************/
/***************************************************************************/

/* 保護IDテーブル 実体 */
const l_u8  u1g_lin_protid_tbl[ U1G_LIN_MAX_SLOT_NUM ] = {
     (l_u8)0x80U, (l_u8)0xC1U, (l_u8)0x42U, (l_u8)0x03U, (l_u8)0xC4U, (l_u8)0x85U, (l_u8)0x06U, (l_u8)0x47U  /* 0x00 - 0x07 */
    ,(l_u8)0x08U, (l_u8)0x49U, (l_u8)0xCAU, (l_u8)0x8BU, (l_u8)0x4CU, (l_u8)0x0DU, (l_u8)0x8EU, (l_u8)0xCFU  /* 0x08 - 0x0F */
    ,(l_u8)0x50U, (l_u8)0x11U, (l_u8)0x92U, (l_u8)0xD3U, (l_u8)0x14U, (l_u8)0x55U, (l_u8)0xD6U, (l_u8)0x97U  /* 0x10 - 0x17 */
    ,(l_u8)0xD8U, (l_u8)0x99U, (l_u8)0x1AU, (l_u8)0x5BU, (l_u8)0x9CU, (l_u8)0xDDU, (l_u8)0x5EU, (l_u8)0x1FU  /* 0x18 - 0x1F */
    ,(l_u8)0x20U, (l_u8)0x61U, (l_u8)0xE2U, (l_u8)0xA3U, (l_u8)0x64U, (l_u8)0x25U, (l_u8)0xA6U, (l_u8)0xE7U  /* 0x20 - 0x27 */
    ,(l_u8)0xA8U, (l_u8)0xE9U, (l_u8)0x6AU, (l_u8)0x2BU, (l_u8)0xECU, (l_u8)0xADU, (l_u8)0x2EU, (l_u8)0x6FU  /* 0x28 - 0x2F */
    ,(l_u8)0xF0U, (l_u8)0xB1U, (l_u8)0x32U, (l_u8)0x73U, (l_u8)0xB4U, (l_u8)0xF5U, (l_u8)0x76U, (l_u8)0x37U  /* 0x30 - 0x37 */
    ,(l_u8)0x78U, (l_u8)0x39U, (l_u8)0xBAU, (l_u8)0xFBU, (l_u8)0x3CU, (l_u8)0x7DU, (l_u8)0xFEU, (l_u8)0xBFU  /* 0x38 - 0x3F */
};


/* フラグセットテーブル(16bit) 実体 */
const l_u16  u2g_lin_flg_set_tbl[ U1G_LIN_WORD_BIT ] = {
     (l_u16)0x0001U, (l_u16)0x0002U, (l_u16)0x0004U, (l_u16)0x0008U
    ,(l_u16)0x0010U, (l_u16)0x0020U, (l_u16)0x0040U, (l_u16)0x0080U
    ,(l_u16)0x0100U, (l_u16)0x0200U, (l_u16)0x0400U, (l_u16)0x0800U
    ,(l_u16)0x1000U, (l_u16)0x2000U, (l_u16)0x4000U, (l_u16)0x8000U
};


/* LIN STATUS BUF 実体 */
st_lin_state_type  xng_lin_sts_buf;

/* LIN FRAME BUF 実体 */
st_lin_buf_type  xng_lin_frm_buf[ U1G_LIN_MAX_SLOT ];

/* システム異常フラグ */
l_u8  u1g_lin_syserr;

/***** End of File *****/





/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_tbl.h                                */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_TBL_H_INCLUDE
#define L_SLIN_TBL_H_INCLUDE

/*** 構造体、共用体定義 ***/

/*=============== エンディアンタイプによるコンパイルスイッチの開始 ===============*/

/*=============== リトルエンディアンタイプ ===============*/
#if  U1G_LIN_ENDIAN_TYPE == U1G_LIN_ENDIAN_LITTLE

/* LIN ステータスバッファの定義 */
typedef struct {
    l_u8   u1g_lin_nad;
    l_u8   u1g_lin_sts;
    l_u8   u1g_lin_bus_inactive;
    l_u8   u1g_lin_e_uart;
    l_u8   u1g_lin_e_sync;
    l_u8   u1g_lin_e_pari;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_node1:1;
            l_u16   u2g_lin_node2:1;
            l_u16   u2g_lin_node3:1;
            l_u16   u2g_lin_node4:1;
            l_u16   u2g_lin_node5:1;
            l_u16   u2g_lin_node6:1;
            l_u16   u2g_lin_node7:1;
            l_u16   u2g_lin_node8:1;
            l_u16   u2g_lin_node9:1;
            l_u16   u2g_lin_node10:1;
            l_u16   u2g_lin_node11:1;
            l_u16   u2g_lin_node12:1;
            l_u16   u2g_lin_node13:1;
            l_u16   u2g_lin_node14:1;
            l_u16   u2g_lin_node15:1;
            l_u16   u2g_lin_node16:1;
        } st_bit;
    } un_node_flg;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot1:1;
            l_u16   u2g_lin_slot2:1;
            l_u16   u2g_lin_slot3:1;
            l_u16   u2g_lin_slot4:1;
            l_u16   u2g_lin_slot5:1;
            l_u16   u2g_lin_slot6:1;
            l_u16   u2g_lin_slot7:1;
            l_u16   u2g_lin_slot8:1;
            l_u16   u2g_lin_slot9:1;
            l_u16   u2g_lin_slot10:1;
            l_u16   u2g_lin_slot11:1;
            l_u16   u2g_lin_slot12:1;
            l_u16   u2g_lin_slot13:1;
            l_u16   u2g_lin_slot14:1;
            l_u16   u2g_lin_slot15:1;
            l_u16   u2g_lin_slot16:1;
        } st_bit;
    } un_rs_flg1;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot17:1;
            l_u16   u2g_lin_slot18:1;
            l_u16   u2g_lin_slot19:1;
            l_u16   u2g_lin_slot20:1;
            l_u16   u2g_lin_slot21:1;
            l_u16   u2g_lin_slot22:1;
            l_u16   u2g_lin_slot23:1;
            l_u16   u2g_lin_slot24:1;
            l_u16   u2g_lin_slot25:1;
            l_u16   u2g_lin_slot26:1;
            l_u16   u2g_lin_slot27:1;
            l_u16   u2g_lin_slot28:1;
            l_u16   u2g_lin_slot29:1;
            l_u16   u2g_lin_slot30:1;
            l_u16   u2g_lin_slot31:1;
            l_u16   u2g_lin_slot32:1;
        } st_bit;
    } un_rs_flg2;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot33:1;
            l_u16   u2g_lin_slot34:1;
            l_u16   u2g_lin_slot35:1;
            l_u16   u2g_lin_slot36:1;
            l_u16   u2g_lin_slot37:1;
            l_u16   u2g_lin_slot38:1;
            l_u16   u2g_lin_slot39:1;
            l_u16   u2g_lin_slot40:1;
            l_u16   u2g_lin_slot41:1;
            l_u16   u2g_lin_slot42:1;
            l_u16   u2g_lin_slot43:1;
            l_u16   u2g_lin_slot44:1;
            l_u16   u2g_lin_slot45:1;
            l_u16   u2g_lin_slot46:1;
            l_u16   u2g_lin_slot47:1;
            l_u16   u2g_lin_slot48:1;
        } st_bit;
    } un_rs_flg3;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot49:1;
            l_u16   u2g_lin_slot50:1;
            l_u16   u2g_lin_slot51:1;
            l_u16   u2g_lin_slot52:1;
            l_u16   u2g_lin_slot53:1;
            l_u16   u2g_lin_slot54:1;
            l_u16   u2g_lin_slot55:1;
            l_u16   u2g_lin_slot56:1;
            l_u16   u2g_lin_slot57:1;
            l_u16   u2g_lin_slot58:1;
            l_u16   u2g_lin_slot59:1;
            l_u16   u2g_lin_slot60:1;
            l_u16   u2g_lin_slot61:1;
            l_u16   u2g_lin_slot62:1;
            l_u16   u2g_lin_slot63:1;
            l_u16   u2g_lin_slot64:1;
        } st_bit;
    } un_rs_flg4;
} st_lin_state_type;


/*=============== ビッグエンディアンタイプ ===============*/
#elif  U1G_LIN_ENDIAN_TYPE == U1G_LIN_ENDIAN_BIG
/* LIN ステータスバッファの定義 */
typedef struct {
    l_u8   u1g_lin_e_pari;
    l_u8   u1g_lin_e_sync;
    l_u8   u1g_lin_e_uart;
    l_u8   u1g_lin_bus_inactive;
    l_u8   u1g_lin_sts;
    l_u8   u1g_lin_nad;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_node16:1;
            l_u16   u2g_lin_node15:1;
            l_u16   u2g_lin_node14:1;
            l_u16   u2g_lin_node13:1;
            l_u16   u2g_lin_node12:1;
            l_u16   u2g_lin_node11:1;
            l_u16   u2g_lin_node10:1;
            l_u16   u2g_lin_node9:1;
            l_u16   u2g_lin_node8:1;
            l_u16   u2g_lin_node7:1;
            l_u16   u2g_lin_node6:1;
            l_u16   u2g_lin_node5:1;
            l_u16   u2g_lin_node4:1;
            l_u16   u2g_lin_node3:1;
            l_u16   u2g_lin_node2:1;
            l_u16   u2g_lin_node1:1;
        } st_bit;
    } un_node_flg;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot16:1;
            l_u16   u2g_lin_slot15:1;
            l_u16   u2g_lin_slot14:1;
            l_u16   u2g_lin_slot13:1;
            l_u16   u2g_lin_slot12:1;
            l_u16   u2g_lin_slot11:1;
            l_u16   u2g_lin_slot10:1;
            l_u16   u2g_lin_slot9:1;
            l_u16   u2g_lin_slot8:1;
            l_u16   u2g_lin_slot7:1;
            l_u16   u2g_lin_slot6:1;
            l_u16   u2g_lin_slot5:1;
            l_u16   u2g_lin_slot4:1;
            l_u16   u2g_lin_slot3:1;
            l_u16   u2g_lin_slot2:1;
            l_u16   u2g_lin_slot1:1;
        } st_bit;
    } un_rs_flg1;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot32:1;
            l_u16   u2g_lin_slot31:1;
            l_u16   u2g_lin_slot30:1;
            l_u16   u2g_lin_slot29:1;
            l_u16   u2g_lin_slot28:1;
            l_u16   u2g_lin_slot27:1;
            l_u16   u2g_lin_slot26:1;
            l_u16   u2g_lin_slot25:1;
            l_u16   u2g_lin_slot24:1;
            l_u16   u2g_lin_slot23:1;
            l_u16   u2g_lin_slot22:1;
            l_u16   u2g_lin_slot21:1;
            l_u16   u2g_lin_slot20:1;
            l_u16   u2g_lin_slot19:1;
            l_u16   u2g_lin_slot18:1;
            l_u16   u2g_lin_slot17:1;
        } st_bit;
    } un_rs_flg2;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot48:1;
            l_u16   u2g_lin_slot47:1;
            l_u16   u2g_lin_slot46:1;
            l_u16   u2g_lin_slot45:1;
            l_u16   u2g_lin_slot44:1;
            l_u16   u2g_lin_slot43:1;
            l_u16   u2g_lin_slot42:1;
            l_u16   u2g_lin_slot41:1;
            l_u16   u2g_lin_slot40:1;
            l_u16   u2g_lin_slot39:1;
            l_u16   u2g_lin_slot38:1;
            l_u16   u2g_lin_slot37:1;
            l_u16   u2g_lin_slot36:1;
            l_u16   u2g_lin_slot35:1;
            l_u16   u2g_lin_slot34:1;
            l_u16   u2g_lin_slot33:1;
        } st_bit;
    } un_rs_flg3;
    union {
        l_u16   u2g_lin_word;
        struct {
            l_u16   u2g_lin_slot64:1;
            l_u16   u2g_lin_slot63:1;
            l_u16   u2g_lin_slot62:1;
            l_u16   u2g_lin_slot61:1;
            l_u16   u2g_lin_slot60:1;
            l_u16   u2g_lin_slot59:1;
            l_u16   u2g_lin_slot58:1;
            l_u16   u2g_lin_slot57:1;
            l_u16   u2g_lin_slot56:1;
            l_u16   u2g_lin_slot55:1;
            l_u16   u2g_lin_slot54:1;
            l_u16   u2g_lin_slot53:1;
            l_u16   u2g_lin_slot52:1;
            l_u16   u2g_lin_slot51:1;
            l_u16   u2g_lin_slot50:1;
            l_u16   u2g_lin_slot49:1;
        } st_bit;
    } un_rs_flg4;
} st_lin_state_type;

#endif
/*=============== エンディアンタイプによるコンパイルスイッチの終了 ===============*/

/* LINフレームバッファの定義 */
typedef struct {
    un_lin_data_type  xng_lin_data;
    l_u8   u1g_lin_no_use;
    l_u8   u1g_lin_status;
    l_u8   u1g_lin_e_res_sht;
    l_u8   u1g_lin_e_sum;
    l_u8   u1g_lin_e_bit;
    l_u8   u1g_lin_e_uart;
    l_u8   u1g_lin_e_nores;
} st_lin_buf_type;


/* LIN Busステータス */
typedef struct {
    l_u8  u1g_lin_last_id;
    l_u8  u1g_lin_head_err;
    l_u8  u1g_lin_bus_err;
    l_u8  u1g_lin_goto_sleep;
    l_u8  u1g_lin_ovr_run;
    l_u8  u1g_lin_ok_resp;
    l_u8  u1g_lin_err_resp;
} st_lin_bus_status_type;

/* LIN スロット情報テーブルの定義 */
typedef struct {
    l_u8    u1g_lin_id;                     /* ID(00h～3Fh) */
    l_u8    u1g_lin_frm_sz;                 /* DL(1～8) */
    l_u8    u1g_lin_sndrcv;                 /* 0b:Snd, 1b:Rcv */
    l_u8    u1g_lin_nm_use;                 /* NM有効 (0:no use 1:use) */
    l_u8    u1g_lin_sum_type;               /* Checksum (0:classic 1:enhanced) */
    l_u8    u1g_lin_def[U1G_LIN_MAX_DL];    /* デフォルト値 */
    l_u8    u1g_lin_fail[U1G_LIN_MAX_DL];   /* フェールセーフ値 */
} st_lin_slot_info_type;


/***** 外部参照定義 *****/
extern st_lin_state_type  xng_lin_sts_buf;
extern st_lin_buf_type  xng_lin_frm_buf[U1G_LIN_MAX_SLOT];
extern l_u8  u1g_lin_syserr;                        /* システム異常フラグ */

extern const l_u8   u1g_lin_id_tbl[ U1G_LIN_MAX_SLOT_NUM ];
extern const l_u8   u1g_lin_protid_tbl[ U1G_LIN_MAX_SLOT_NUM ];
extern const l_u16  u2g_lin_flg_set_tbl[ U1G_LIN_WORD_BIT ];
extern const st_lin_slot_info_type  xng_lin_slot_tbl[ U1G_LIN_MAX_SLOT ];

#endif


/***** End of File *****/



/*""FILE COMMENT""********************************************/
/* System Name : S930-LSLibRL78F24xx                         */
/* File Name   : l_slin_user.h                               */
/* Note        :                                             */
/*""FILE COMMENT END""****************************************/

#ifndef L_SLIN_USER_H_INCLUDE
#define L_SLIN_USER_H_INCLUDE


/******************** ヘッダ インクルード ********************/
#include "l_slin_cmn.h"
#include "l_slin_def.h"
#include "l_slin_api.h"
#include "l_slin_tbl.h"
#include "l_slin_nmc.h"

#endif

/*** End of file *************************************************************************************/

